
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ChatSession
 * 
 */
export type ChatSession = $Result.DefaultSelection<Prisma.$ChatSessionPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model UserService
 * 
 */
export type UserService = $Result.DefaultSelection<Prisma.$UserServicePayload>
/**
 * Model PasswordReset
 * 
 */
export type PasswordReset = $Result.DefaultSelection<Prisma.$PasswordResetPayload>
/**
 * Model TenantWebsite
 * 
 */
export type TenantWebsite = $Result.DefaultSelection<Prisma.$TenantWebsitePayload>
/**
 * Model RestaurantCategory
 * 
 */
export type RestaurantCategory = $Result.DefaultSelection<Prisma.$RestaurantCategoryPayload>
/**
 * Model RestaurantDish
 * 
 */
export type RestaurantDish = $Result.DefaultSelection<Prisma.$RestaurantDishPayload>
/**
 * Model RestaurantTable
 * 
 */
export type RestaurantTable = $Result.DefaultSelection<Prisma.$RestaurantTablePayload>
/**
 * Model RestaurantWaiter
 * 
 */
export type RestaurantWaiter = $Result.DefaultSelection<Prisma.$RestaurantWaiterPayload>
/**
 * Model RestaurantOrder
 * 
 */
export type RestaurantOrder = $Result.DefaultSelection<Prisma.$RestaurantOrderPayload>
/**
 * Model RestaurantOrderItem
 * 
 */
export type RestaurantOrderItem = $Result.DefaultSelection<Prisma.$RestaurantOrderItemPayload>
/**
 * Model CabinetService
 * 
 */
export type CabinetService = $Result.DefaultSelection<Prisma.$CabinetServicePayload>
/**
 * Model CabinetClient
 * 
 */
export type CabinetClient = $Result.DefaultSelection<Prisma.$CabinetClientPayload>
/**
 * Model CabinetAppointment
 * 
 */
export type CabinetAppointment = $Result.DefaultSelection<Prisma.$CabinetAppointmentPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatSession`: Exposes CRUD operations for the **ChatSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatSessions
    * const chatSessions = await prisma.chatSession.findMany()
    * ```
    */
  get chatSession(): Prisma.ChatSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userService`: Exposes CRUD operations for the **UserService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserServices
    * const userServices = await prisma.userService.findMany()
    * ```
    */
  get userService(): Prisma.UserServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordReset`: Exposes CRUD operations for the **PasswordReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResets
    * const passwordResets = await prisma.passwordReset.findMany()
    * ```
    */
  get passwordReset(): Prisma.PasswordResetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantWebsite`: Exposes CRUD operations for the **TenantWebsite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantWebsites
    * const tenantWebsites = await prisma.tenantWebsite.findMany()
    * ```
    */
  get tenantWebsite(): Prisma.TenantWebsiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.restaurantCategory`: Exposes CRUD operations for the **RestaurantCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RestaurantCategories
    * const restaurantCategories = await prisma.restaurantCategory.findMany()
    * ```
    */
  get restaurantCategory(): Prisma.RestaurantCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.restaurantDish`: Exposes CRUD operations for the **RestaurantDish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RestaurantDishes
    * const restaurantDishes = await prisma.restaurantDish.findMany()
    * ```
    */
  get restaurantDish(): Prisma.RestaurantDishDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.restaurantTable`: Exposes CRUD operations for the **RestaurantTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RestaurantTables
    * const restaurantTables = await prisma.restaurantTable.findMany()
    * ```
    */
  get restaurantTable(): Prisma.RestaurantTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.restaurantWaiter`: Exposes CRUD operations for the **RestaurantWaiter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RestaurantWaiters
    * const restaurantWaiters = await prisma.restaurantWaiter.findMany()
    * ```
    */
  get restaurantWaiter(): Prisma.RestaurantWaiterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.restaurantOrder`: Exposes CRUD operations for the **RestaurantOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RestaurantOrders
    * const restaurantOrders = await prisma.restaurantOrder.findMany()
    * ```
    */
  get restaurantOrder(): Prisma.RestaurantOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.restaurantOrderItem`: Exposes CRUD operations for the **RestaurantOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RestaurantOrderItems
    * const restaurantOrderItems = await prisma.restaurantOrderItem.findMany()
    * ```
    */
  get restaurantOrderItem(): Prisma.RestaurantOrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetService`: Exposes CRUD operations for the **CabinetService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetServices
    * const cabinetServices = await prisma.cabinetService.findMany()
    * ```
    */
  get cabinetService(): Prisma.CabinetServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetClient`: Exposes CRUD operations for the **CabinetClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetClients
    * const cabinetClients = await prisma.cabinetClient.findMany()
    * ```
    */
  get cabinetClient(): Prisma.CabinetClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cabinetAppointment`: Exposes CRUD operations for the **CabinetAppointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CabinetAppointments
    * const cabinetAppointments = await prisma.cabinetAppointment.findMany()
    * ```
    */
  get cabinetAppointment(): Prisma.CabinetAppointmentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ChatSession: 'ChatSession',
    ChatMessage: 'ChatMessage',
    Notification: 'Notification',
    Service: 'Service',
    UserService: 'UserService',
    PasswordReset: 'PasswordReset',
    TenantWebsite: 'TenantWebsite',
    RestaurantCategory: 'RestaurantCategory',
    RestaurantDish: 'RestaurantDish',
    RestaurantTable: 'RestaurantTable',
    RestaurantWaiter: 'RestaurantWaiter',
    RestaurantOrder: 'RestaurantOrder',
    RestaurantOrderItem: 'RestaurantOrderItem',
    CabinetService: 'CabinetService',
    CabinetClient: 'CabinetClient',
    CabinetAppointment: 'CabinetAppointment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "chatSession" | "chatMessage" | "notification" | "service" | "userService" | "passwordReset" | "tenantWebsite" | "restaurantCategory" | "restaurantDish" | "restaurantTable" | "restaurantWaiter" | "restaurantOrder" | "restaurantOrderItem" | "cabinetService" | "cabinetClient" | "cabinetAppointment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ChatSession: {
        payload: Prisma.$ChatSessionPayload<ExtArgs>
        fields: Prisma.ChatSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findFirst: {
            args: Prisma.ChatSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findMany: {
            args: Prisma.ChatSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          create: {
            args: Prisma.ChatSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          createMany: {
            args: Prisma.ChatSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          delete: {
            args: Prisma.ChatSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          update: {
            args: Prisma.ChatSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          deleteMany: {
            args: Prisma.ChatSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          upsert: {
            args: Prisma.ChatSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          aggregate: {
            args: Prisma.ChatSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatSession>
          }
          groupBy: {
            args: Prisma.ChatSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      UserService: {
        payload: Prisma.$UserServicePayload<ExtArgs>
        fields: Prisma.UserServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserServicePayload>
          }
          findFirst: {
            args: Prisma.UserServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserServicePayload>
          }
          findMany: {
            args: Prisma.UserServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserServicePayload>[]
          }
          create: {
            args: Prisma.UserServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserServicePayload>
          }
          createMany: {
            args: Prisma.UserServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserServicePayload>[]
          }
          delete: {
            args: Prisma.UserServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserServicePayload>
          }
          update: {
            args: Prisma.UserServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserServicePayload>
          }
          deleteMany: {
            args: Prisma.UserServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserServicePayload>[]
          }
          upsert: {
            args: Prisma.UserServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserServicePayload>
          }
          aggregate: {
            args: Prisma.UserServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserService>
          }
          groupBy: {
            args: Prisma.UserServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserServiceCountArgs<ExtArgs>
            result: $Utils.Optional<UserServiceCountAggregateOutputType> | number
          }
        }
      }
      PasswordReset: {
        payload: Prisma.$PasswordResetPayload<ExtArgs>
        fields: Prisma.PasswordResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findMany: {
            args: Prisma.PasswordResetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          create: {
            args: Prisma.PasswordResetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          createMany: {
            args: Prisma.PasswordResetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          update: {
            args: Prisma.PasswordResetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordReset>
          }
          groupBy: {
            args: Prisma.PasswordResetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetCountAggregateOutputType> | number
          }
        }
      }
      TenantWebsite: {
        payload: Prisma.$TenantWebsitePayload<ExtArgs>
        fields: Prisma.TenantWebsiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantWebsiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantWebsiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          findFirst: {
            args: Prisma.TenantWebsiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantWebsiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          findMany: {
            args: Prisma.TenantWebsiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>[]
          }
          create: {
            args: Prisma.TenantWebsiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          createMany: {
            args: Prisma.TenantWebsiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantWebsiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>[]
          }
          delete: {
            args: Prisma.TenantWebsiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          update: {
            args: Prisma.TenantWebsiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          deleteMany: {
            args: Prisma.TenantWebsiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantWebsiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantWebsiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>[]
          }
          upsert: {
            args: Prisma.TenantWebsiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantWebsitePayload>
          }
          aggregate: {
            args: Prisma.TenantWebsiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantWebsite>
          }
          groupBy: {
            args: Prisma.TenantWebsiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantWebsiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantWebsiteCountArgs<ExtArgs>
            result: $Utils.Optional<TenantWebsiteCountAggregateOutputType> | number
          }
        }
      }
      RestaurantCategory: {
        payload: Prisma.$RestaurantCategoryPayload<ExtArgs>
        fields: Prisma.RestaurantCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantCategoryPayload>
          }
          findFirst: {
            args: Prisma.RestaurantCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantCategoryPayload>
          }
          findMany: {
            args: Prisma.RestaurantCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantCategoryPayload>[]
          }
          create: {
            args: Prisma.RestaurantCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantCategoryPayload>
          }
          createMany: {
            args: Prisma.RestaurantCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestaurantCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantCategoryPayload>[]
          }
          delete: {
            args: Prisma.RestaurantCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantCategoryPayload>
          }
          update: {
            args: Prisma.RestaurantCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantCategoryPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RestaurantCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantCategoryPayload>[]
          }
          upsert: {
            args: Prisma.RestaurantCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantCategoryPayload>
          }
          aggregate: {
            args: Prisma.RestaurantCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurantCategory>
          }
          groupBy: {
            args: Prisma.RestaurantCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantCategoryCountAggregateOutputType> | number
          }
        }
      }
      RestaurantDish: {
        payload: Prisma.$RestaurantDishPayload<ExtArgs>
        fields: Prisma.RestaurantDishFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantDishFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantDishPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantDishFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantDishPayload>
          }
          findFirst: {
            args: Prisma.RestaurantDishFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantDishPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantDishFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantDishPayload>
          }
          findMany: {
            args: Prisma.RestaurantDishFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantDishPayload>[]
          }
          create: {
            args: Prisma.RestaurantDishCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantDishPayload>
          }
          createMany: {
            args: Prisma.RestaurantDishCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestaurantDishCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantDishPayload>[]
          }
          delete: {
            args: Prisma.RestaurantDishDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantDishPayload>
          }
          update: {
            args: Prisma.RestaurantDishUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantDishPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantDishDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantDishUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RestaurantDishUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantDishPayload>[]
          }
          upsert: {
            args: Prisma.RestaurantDishUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantDishPayload>
          }
          aggregate: {
            args: Prisma.RestaurantDishAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurantDish>
          }
          groupBy: {
            args: Prisma.RestaurantDishGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantDishGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantDishCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantDishCountAggregateOutputType> | number
          }
        }
      }
      RestaurantTable: {
        payload: Prisma.$RestaurantTablePayload<ExtArgs>
        fields: Prisma.RestaurantTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantTablePayload>
          }
          findFirst: {
            args: Prisma.RestaurantTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantTablePayload>
          }
          findMany: {
            args: Prisma.RestaurantTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantTablePayload>[]
          }
          create: {
            args: Prisma.RestaurantTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantTablePayload>
          }
          createMany: {
            args: Prisma.RestaurantTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestaurantTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantTablePayload>[]
          }
          delete: {
            args: Prisma.RestaurantTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantTablePayload>
          }
          update: {
            args: Prisma.RestaurantTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantTablePayload>
          }
          deleteMany: {
            args: Prisma.RestaurantTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RestaurantTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantTablePayload>[]
          }
          upsert: {
            args: Prisma.RestaurantTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantTablePayload>
          }
          aggregate: {
            args: Prisma.RestaurantTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurantTable>
          }
          groupBy: {
            args: Prisma.RestaurantTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantTableCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantTableCountAggregateOutputType> | number
          }
        }
      }
      RestaurantWaiter: {
        payload: Prisma.$RestaurantWaiterPayload<ExtArgs>
        fields: Prisma.RestaurantWaiterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantWaiterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaiterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantWaiterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaiterPayload>
          }
          findFirst: {
            args: Prisma.RestaurantWaiterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaiterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantWaiterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaiterPayload>
          }
          findMany: {
            args: Prisma.RestaurantWaiterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaiterPayload>[]
          }
          create: {
            args: Prisma.RestaurantWaiterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaiterPayload>
          }
          createMany: {
            args: Prisma.RestaurantWaiterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestaurantWaiterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaiterPayload>[]
          }
          delete: {
            args: Prisma.RestaurantWaiterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaiterPayload>
          }
          update: {
            args: Prisma.RestaurantWaiterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaiterPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantWaiterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantWaiterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RestaurantWaiterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaiterPayload>[]
          }
          upsert: {
            args: Prisma.RestaurantWaiterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaiterPayload>
          }
          aggregate: {
            args: Prisma.RestaurantWaiterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurantWaiter>
          }
          groupBy: {
            args: Prisma.RestaurantWaiterGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantWaiterGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantWaiterCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantWaiterCountAggregateOutputType> | number
          }
        }
      }
      RestaurantOrder: {
        payload: Prisma.$RestaurantOrderPayload<ExtArgs>
        fields: Prisma.RestaurantOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderPayload>
          }
          findFirst: {
            args: Prisma.RestaurantOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderPayload>
          }
          findMany: {
            args: Prisma.RestaurantOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderPayload>[]
          }
          create: {
            args: Prisma.RestaurantOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderPayload>
          }
          createMany: {
            args: Prisma.RestaurantOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestaurantOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderPayload>[]
          }
          delete: {
            args: Prisma.RestaurantOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderPayload>
          }
          update: {
            args: Prisma.RestaurantOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RestaurantOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderPayload>[]
          }
          upsert: {
            args: Prisma.RestaurantOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderPayload>
          }
          aggregate: {
            args: Prisma.RestaurantOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurantOrder>
          }
          groupBy: {
            args: Prisma.RestaurantOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantOrderCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantOrderCountAggregateOutputType> | number
          }
        }
      }
      RestaurantOrderItem: {
        payload: Prisma.$RestaurantOrderItemPayload<ExtArgs>
        fields: Prisma.RestaurantOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderItemPayload>
          }
          findFirst: {
            args: Prisma.RestaurantOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderItemPayload>
          }
          findMany: {
            args: Prisma.RestaurantOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderItemPayload>[]
          }
          create: {
            args: Prisma.RestaurantOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderItemPayload>
          }
          createMany: {
            args: Prisma.RestaurantOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestaurantOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderItemPayload>[]
          }
          delete: {
            args: Prisma.RestaurantOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderItemPayload>
          }
          update: {
            args: Prisma.RestaurantOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RestaurantOrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderItemPayload>[]
          }
          upsert: {
            args: Prisma.RestaurantOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantOrderItemPayload>
          }
          aggregate: {
            args: Prisma.RestaurantOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurantOrderItem>
          }
          groupBy: {
            args: Prisma.RestaurantOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantOrderItemCountAggregateOutputType> | number
          }
        }
      }
      CabinetService: {
        payload: Prisma.$CabinetServicePayload<ExtArgs>
        fields: Prisma.CabinetServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetServicePayload>
          }
          findFirst: {
            args: Prisma.CabinetServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetServicePayload>
          }
          findMany: {
            args: Prisma.CabinetServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetServicePayload>[]
          }
          create: {
            args: Prisma.CabinetServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetServicePayload>
          }
          createMany: {
            args: Prisma.CabinetServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetServicePayload>[]
          }
          delete: {
            args: Prisma.CabinetServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetServicePayload>
          }
          update: {
            args: Prisma.CabinetServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetServicePayload>
          }
          deleteMany: {
            args: Prisma.CabinetServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetServicePayload>[]
          }
          upsert: {
            args: Prisma.CabinetServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetServicePayload>
          }
          aggregate: {
            args: Prisma.CabinetServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetService>
          }
          groupBy: {
            args: Prisma.CabinetServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetServiceCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetServiceCountAggregateOutputType> | number
          }
        }
      }
      CabinetClient: {
        payload: Prisma.$CabinetClientPayload<ExtArgs>
        fields: Prisma.CabinetClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetClientPayload>
          }
          findFirst: {
            args: Prisma.CabinetClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetClientPayload>
          }
          findMany: {
            args: Prisma.CabinetClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetClientPayload>[]
          }
          create: {
            args: Prisma.CabinetClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetClientPayload>
          }
          createMany: {
            args: Prisma.CabinetClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetClientPayload>[]
          }
          delete: {
            args: Prisma.CabinetClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetClientPayload>
          }
          update: {
            args: Prisma.CabinetClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetClientPayload>
          }
          deleteMany: {
            args: Prisma.CabinetClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetClientPayload>[]
          }
          upsert: {
            args: Prisma.CabinetClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetClientPayload>
          }
          aggregate: {
            args: Prisma.CabinetClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetClient>
          }
          groupBy: {
            args: Prisma.CabinetClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetClientCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetClientCountAggregateOutputType> | number
          }
        }
      }
      CabinetAppointment: {
        payload: Prisma.$CabinetAppointmentPayload<ExtArgs>
        fields: Prisma.CabinetAppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CabinetAppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetAppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CabinetAppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetAppointmentPayload>
          }
          findFirst: {
            args: Prisma.CabinetAppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetAppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CabinetAppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetAppointmentPayload>
          }
          findMany: {
            args: Prisma.CabinetAppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetAppointmentPayload>[]
          }
          create: {
            args: Prisma.CabinetAppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetAppointmentPayload>
          }
          createMany: {
            args: Prisma.CabinetAppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CabinetAppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetAppointmentPayload>[]
          }
          delete: {
            args: Prisma.CabinetAppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetAppointmentPayload>
          }
          update: {
            args: Prisma.CabinetAppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetAppointmentPayload>
          }
          deleteMany: {
            args: Prisma.CabinetAppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CabinetAppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CabinetAppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetAppointmentPayload>[]
          }
          upsert: {
            args: Prisma.CabinetAppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CabinetAppointmentPayload>
          }
          aggregate: {
            args: Prisma.CabinetAppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCabinetAppointment>
          }
          groupBy: {
            args: Prisma.CabinetAppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CabinetAppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CabinetAppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<CabinetAppointmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    chatSession?: ChatSessionOmit
    chatMessage?: ChatMessageOmit
    notification?: NotificationOmit
    service?: ServiceOmit
    userService?: UserServiceOmit
    passwordReset?: PasswordResetOmit
    tenantWebsite?: TenantWebsiteOmit
    restaurantCategory?: RestaurantCategoryOmit
    restaurantDish?: RestaurantDishOmit
    restaurantTable?: RestaurantTableOmit
    restaurantWaiter?: RestaurantWaiterOmit
    restaurantOrder?: RestaurantOrderOmit
    restaurantOrderItem?: RestaurantOrderItemOmit
    cabinetService?: CabinetServiceOmit
    cabinetClient?: CabinetClientOmit
    cabinetAppointment?: CabinetAppointmentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    services: number
    notifications: number
    websites: number
    chatSessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | UserCountOutputTypeCountServicesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    websites?: boolean | UserCountOutputTypeCountWebsitesArgs
    chatSessions?: boolean | UserCountOutputTypeCountChatSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserServiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWebsitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWebsiteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
  }


  /**
   * Count Type ChatSessionCountOutputType
   */

  export type ChatSessionCountOutputType = {
    messages: number
  }

  export type ChatSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatSessionCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSessionCountOutputType
     */
    select?: ChatSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    users: number
    websites: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ServiceCountOutputTypeCountUsersArgs
    websites?: boolean | ServiceCountOutputTypeCountWebsitesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountWebsitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWebsiteWhereInput
  }


  /**
   * Count Type TenantWebsiteCountOutputType
   */

  export type TenantWebsiteCountOutputType = {
    categories: number
    tables: number
    waiters: number
    cabinetServices: number
    cabinetClients: number
    cabinetAppointments: number
  }

  export type TenantWebsiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | TenantWebsiteCountOutputTypeCountCategoriesArgs
    tables?: boolean | TenantWebsiteCountOutputTypeCountTablesArgs
    waiters?: boolean | TenantWebsiteCountOutputTypeCountWaitersArgs
    cabinetServices?: boolean | TenantWebsiteCountOutputTypeCountCabinetServicesArgs
    cabinetClients?: boolean | TenantWebsiteCountOutputTypeCountCabinetClientsArgs
    cabinetAppointments?: boolean | TenantWebsiteCountOutputTypeCountCabinetAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * TenantWebsiteCountOutputType without action
   */
  export type TenantWebsiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsiteCountOutputType
     */
    select?: TenantWebsiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantWebsiteCountOutputType without action
   */
  export type TenantWebsiteCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantCategoryWhereInput
  }

  /**
   * TenantWebsiteCountOutputType without action
   */
  export type TenantWebsiteCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantTableWhereInput
  }

  /**
   * TenantWebsiteCountOutputType without action
   */
  export type TenantWebsiteCountOutputTypeCountWaitersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWaiterWhereInput
  }

  /**
   * TenantWebsiteCountOutputType without action
   */
  export type TenantWebsiteCountOutputTypeCountCabinetServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetServiceWhereInput
  }

  /**
   * TenantWebsiteCountOutputType without action
   */
  export type TenantWebsiteCountOutputTypeCountCabinetClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetClientWhereInput
  }

  /**
   * TenantWebsiteCountOutputType without action
   */
  export type TenantWebsiteCountOutputTypeCountCabinetAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetAppointmentWhereInput
  }


  /**
   * Count Type RestaurantCategoryCountOutputType
   */

  export type RestaurantCategoryCountOutputType = {
    dishes: number
  }

  export type RestaurantCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dishes?: boolean | RestaurantCategoryCountOutputTypeCountDishesArgs
  }

  // Custom InputTypes
  /**
   * RestaurantCategoryCountOutputType without action
   */
  export type RestaurantCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategoryCountOutputType
     */
    select?: RestaurantCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RestaurantCategoryCountOutputType without action
   */
  export type RestaurantCategoryCountOutputTypeCountDishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantDishWhereInput
  }


  /**
   * Count Type RestaurantTableCountOutputType
   */

  export type RestaurantTableCountOutputType = {
    orders: number
  }

  export type RestaurantTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | RestaurantTableCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * RestaurantTableCountOutputType without action
   */
  export type RestaurantTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTableCountOutputType
     */
    select?: RestaurantTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RestaurantTableCountOutputType without action
   */
  export type RestaurantTableCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantOrderWhereInput
  }


  /**
   * Count Type RestaurantWaiterCountOutputType
   */

  export type RestaurantWaiterCountOutputType = {
    tables: number
  }

  export type RestaurantWaiterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | RestaurantWaiterCountOutputTypeCountTablesArgs
  }

  // Custom InputTypes
  /**
   * RestaurantWaiterCountOutputType without action
   */
  export type RestaurantWaiterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiterCountOutputType
     */
    select?: RestaurantWaiterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RestaurantWaiterCountOutputType without action
   */
  export type RestaurantWaiterCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantTableWhereInput
  }


  /**
   * Count Type RestaurantOrderCountOutputType
   */

  export type RestaurantOrderCountOutputType = {
    items: number
  }

  export type RestaurantOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | RestaurantOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * RestaurantOrderCountOutputType without action
   */
  export type RestaurantOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderCountOutputType
     */
    select?: RestaurantOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RestaurantOrderCountOutputType without action
   */
  export type RestaurantOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantOrderItemWhereInput
  }


  /**
   * Count Type CabinetServiceCountOutputType
   */

  export type CabinetServiceCountOutputType = {
    appointments: number
  }

  export type CabinetServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | CabinetServiceCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * CabinetServiceCountOutputType without action
   */
  export type CabinetServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetServiceCountOutputType
     */
    select?: CabinetServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CabinetServiceCountOutputType without action
   */
  export type CabinetServiceCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetAppointmentWhereInput
  }


  /**
   * Count Type CabinetClientCountOutputType
   */

  export type CabinetClientCountOutputType = {
    appointments: number
  }

  export type CabinetClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | CabinetClientCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * CabinetClientCountOutputType without action
   */
  export type CabinetClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClientCountOutputType
     */
    select?: CabinetClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CabinetClientCountOutputType without action
   */
  export type CabinetClientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetAppointmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    companyName: string | null
    role: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    companyName: string | null
    role: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    companyName: number
    role: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    companyName?: true
    role?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    companyName?: true
    role?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    companyName?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    companyName: string
    role: string
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    companyName?: boolean
    role?: boolean
    createdAt?: boolean
    services?: boolean | User$servicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    websites?: boolean | User$websitesArgs<ExtArgs>
    chatSessions?: boolean | User$chatSessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    companyName?: boolean
    role?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    companyName?: boolean
    role?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    companyName?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "companyName" | "role" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | User$servicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    websites?: boolean | User$websitesArgs<ExtArgs>
    chatSessions?: boolean | User$chatSessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      services: Prisma.$UserServicePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      websites: Prisma.$TenantWebsitePayload<ExtArgs>[]
      chatSessions: Prisma.$ChatSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      companyName: string
      role: string
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends User$servicesArgs<ExtArgs> = {}>(args?: Subset<T, User$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    websites<T extends User$websitesArgs<ExtArgs> = {}>(args?: Subset<T, User$websitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatSessions<T extends User$chatSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly companyName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.services
   */
  export type User$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
    where?: UserServiceWhereInput
    orderBy?: UserServiceOrderByWithRelationInput | UserServiceOrderByWithRelationInput[]
    cursor?: UserServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserServiceScalarFieldEnum | UserServiceScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.websites
   */
  export type User$websitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    where?: TenantWebsiteWhereInput
    orderBy?: TenantWebsiteOrderByWithRelationInput | TenantWebsiteOrderByWithRelationInput[]
    cursor?: TenantWebsiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantWebsiteScalarFieldEnum | TenantWebsiteScalarFieldEnum[]
  }

  /**
   * User.chatSessions
   */
  export type User$chatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    cursor?: ChatSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ChatSession
   */

  export type AggregateChatSession = {
    _count: ChatSessionCountAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  export type ChatSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatSessionCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatSessionMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatSessionCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSession to aggregate.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatSessions
    **/
    _count?: true | ChatSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatSessionMaxAggregateInputType
  }

  export type GetChatSessionAggregateType<T extends ChatSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateChatSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatSession[P]>
      : GetScalarType<T[P], AggregateChatSession[P]>
  }




  export type ChatSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithAggregationInput | ChatSessionOrderByWithAggregationInput[]
    by: ChatSessionScalarFieldEnum[] | ChatSessionScalarFieldEnum
    having?: ChatSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatSessionCountAggregateInputType | true
    _min?: ChatSessionMinAggregateInputType
    _max?: ChatSessionMaxAggregateInputType
  }

  export type ChatSessionGroupByOutputType = {
    id: string
    userId: string
    title: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChatSessionCountAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  type GetChatSessionGroupByPayload<T extends ChatSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
        }
      >
    >


  export type ChatSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messages?: boolean | ChatSession$messagesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ChatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "createdAt" | "updatedAt", ExtArgs["result"]["chatSession"]>
  export type ChatSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatSession$messagesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ChatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatSession"
    objects: {
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chatSession"]>
    composites: {}
  }

  type ChatSessionGetPayload<S extends boolean | null | undefined | ChatSessionDefaultArgs> = $Result.GetResult<Prisma.$ChatSessionPayload, S>

  type ChatSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatSessionCountAggregateInputType | true
    }

  export interface ChatSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatSession'], meta: { name: 'ChatSession' } }
    /**
     * Find zero or one ChatSession that matches the filter.
     * @param {ChatSessionFindUniqueArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatSessionFindUniqueArgs>(args: SelectSubset<T, ChatSessionFindUniqueArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatSessionFindUniqueOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatSessionFindFirstArgs>(args?: SelectSubset<T, ChatSessionFindFirstArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatSessions
     * const chatSessions = await prisma.chatSession.findMany()
     * 
     * // Get first 10 ChatSessions
     * const chatSessions = await prisma.chatSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatSessionFindManyArgs>(args?: SelectSubset<T, ChatSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatSession.
     * @param {ChatSessionCreateArgs} args - Arguments to create a ChatSession.
     * @example
     * // Create one ChatSession
     * const ChatSession = await prisma.chatSession.create({
     *   data: {
     *     // ... data to create a ChatSession
     *   }
     * })
     * 
     */
    create<T extends ChatSessionCreateArgs>(args: SelectSubset<T, ChatSessionCreateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatSessions.
     * @param {ChatSessionCreateManyArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatSessionCreateManyArgs>(args?: SelectSubset<T, ChatSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatSessions and returns the data saved in the database.
     * @param {ChatSessionCreateManyAndReturnArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatSessions and only return the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatSession.
     * @param {ChatSessionDeleteArgs} args - Arguments to delete one ChatSession.
     * @example
     * // Delete one ChatSession
     * const ChatSession = await prisma.chatSession.delete({
     *   where: {
     *     // ... filter to delete one ChatSession
     *   }
     * })
     * 
     */
    delete<T extends ChatSessionDeleteArgs>(args: SelectSubset<T, ChatSessionDeleteArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatSession.
     * @param {ChatSessionUpdateArgs} args - Arguments to update one ChatSession.
     * @example
     * // Update one ChatSession
     * const chatSession = await prisma.chatSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatSessionUpdateArgs>(args: SelectSubset<T, ChatSessionUpdateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatSessions.
     * @param {ChatSessionDeleteManyArgs} args - Arguments to filter ChatSessions to delete.
     * @example
     * // Delete a few ChatSessions
     * const { count } = await prisma.chatSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatSessionDeleteManyArgs>(args?: SelectSubset<T, ChatSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatSessions
     * const chatSession = await prisma.chatSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatSessionUpdateManyArgs>(args: SelectSubset<T, ChatSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessions and returns the data updated in the database.
     * @param {ChatSessionUpdateManyAndReturnArgs} args - Arguments to update many ChatSessions.
     * @example
     * // Update many ChatSessions
     * const chatSession = await prisma.chatSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatSessions and only return the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatSession.
     * @param {ChatSessionUpsertArgs} args - Arguments to update or create a ChatSession.
     * @example
     * // Update or create a ChatSession
     * const chatSession = await prisma.chatSession.upsert({
     *   create: {
     *     // ... data to create a ChatSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatSession we want to update
     *   }
     * })
     */
    upsert<T extends ChatSessionUpsertArgs>(args: SelectSubset<T, ChatSessionUpsertArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionCountArgs} args - Arguments to filter ChatSessions to count.
     * @example
     * // Count the number of ChatSessions
     * const count = await prisma.chatSession.count({
     *   where: {
     *     // ... the filter for the ChatSessions we want to count
     *   }
     * })
    **/
    count<T extends ChatSessionCountArgs>(
      args?: Subset<T, ChatSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatSessionAggregateArgs>(args: Subset<T, ChatSessionAggregateArgs>): Prisma.PrismaPromise<GetChatSessionAggregateType<T>>

    /**
     * Group by ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatSessionGroupByArgs['orderBy'] }
        : { orderBy?: ChatSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatSession model
   */
  readonly fields: ChatSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends ChatSession$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatSession$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatSession model
   */
  interface ChatSessionFieldRefs {
    readonly id: FieldRef<"ChatSession", 'String'>
    readonly userId: FieldRef<"ChatSession", 'String'>
    readonly title: FieldRef<"ChatSession", 'String'>
    readonly createdAt: FieldRef<"ChatSession", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatSession findUnique
   */
  export type ChatSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findUniqueOrThrow
   */
  export type ChatSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findFirst
   */
  export type ChatSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findFirstOrThrow
   */
  export type ChatSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findMany
   */
  export type ChatSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSessions to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession create
   */
  export type ChatSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatSession.
     */
    data: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
  }

  /**
   * ChatSession createMany
   */
  export type ChatSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
  }

  /**
   * ChatSession createManyAndReturn
   */
  export type ChatSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatSession update
   */
  export type ChatSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatSession.
     */
    data: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
    /**
     * Choose, which ChatSession to update.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession updateMany
   */
  export type ChatSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatSessions.
     */
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessions to update
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to update.
     */
    limit?: number
  }

  /**
   * ChatSession updateManyAndReturn
   */
  export type ChatSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * The data used to update ChatSessions.
     */
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessions to update
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatSession upsert
   */
  export type ChatSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatSession to update in case it exists.
     */
    where: ChatSessionWhereUniqueInput
    /**
     * In case the ChatSession found by the `where` argument doesn't exist, create a new ChatSession with this data.
     */
    create: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
    /**
     * In case the ChatSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
  }

  /**
   * ChatSession delete
   */
  export type ChatSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter which ChatSession to delete.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession deleteMany
   */
  export type ChatSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSessions to delete
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to delete.
     */
    limit?: number
  }

  /**
   * ChatSession.messages
   */
  export type ChatSession$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatSession without action
   */
  export type ChatSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    role: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    role: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    sessionId: number
    role: number
    content: number
    createdAt: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    sessionId: string
    role: string
    content: string
    createdAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "role" | "content" | "createdAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      session: Prisma.$ChatSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      role: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends ChatSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatSessionDefaultArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly sessionId: FieldRef<"ChatMessage", 'String'>
    readonly role: FieldRef<"ChatMessage", 'String'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    status: string | null
    category: string | null
    createdAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    status: string | null
    category: string | null
    createdAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    status: number
    category: number
    createdAt: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    status?: true
    category?: true
    createdAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    status?: true
    category?: true
    createdAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    status?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    status: string
    category: string | null
    createdAt: Date
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    status?: boolean
    category?: boolean
    createdAt?: boolean
    users?: boolean | Service$usersArgs<ExtArgs>
    websites?: boolean | Service$websitesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    status?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    status?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    status?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "status" | "category" | "createdAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Service$usersArgs<ExtArgs>
    websites?: boolean | Service$websitesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      users: Prisma.$UserServicePayload<ExtArgs>[]
      websites: Prisma.$TenantWebsitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      status: string
      category: string | null
      createdAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Service$usersArgs<ExtArgs> = {}>(args?: Subset<T, Service$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    websites<T extends Service$websitesArgs<ExtArgs> = {}>(args?: Subset<T, Service$websitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly slug: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly status: FieldRef<"Service", 'String'>
    readonly category: FieldRef<"Service", 'String'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.users
   */
  export type Service$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
    where?: UserServiceWhereInput
    orderBy?: UserServiceOrderByWithRelationInput | UserServiceOrderByWithRelationInput[]
    cursor?: UserServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserServiceScalarFieldEnum | UserServiceScalarFieldEnum[]
  }

  /**
   * Service.websites
   */
  export type Service$websitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    where?: TenantWebsiteWhereInput
    orderBy?: TenantWebsiteOrderByWithRelationInput | TenantWebsiteOrderByWithRelationInput[]
    cursor?: TenantWebsiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantWebsiteScalarFieldEnum | TenantWebsiteScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model UserService
   */

  export type AggregateUserService = {
    _count: UserServiceCountAggregateOutputType | null
    _min: UserServiceMinAggregateOutputType | null
    _max: UserServiceMaxAggregateOutputType | null
  }

  export type UserServiceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    notify: boolean | null
    selectedAt: Date | null
  }

  export type UserServiceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    notify: boolean | null
    selectedAt: Date | null
  }

  export type UserServiceCountAggregateOutputType = {
    id: number
    userId: number
    serviceId: number
    notify: number
    selectedAt: number
    _all: number
  }


  export type UserServiceMinAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    notify?: true
    selectedAt?: true
  }

  export type UserServiceMaxAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    notify?: true
    selectedAt?: true
  }

  export type UserServiceCountAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    notify?: true
    selectedAt?: true
    _all?: true
  }

  export type UserServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserService to aggregate.
     */
    where?: UserServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserServices to fetch.
     */
    orderBy?: UserServiceOrderByWithRelationInput | UserServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserServices
    **/
    _count?: true | UserServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserServiceMaxAggregateInputType
  }

  export type GetUserServiceAggregateType<T extends UserServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserService[P]>
      : GetScalarType<T[P], AggregateUserService[P]>
  }




  export type UserServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserServiceWhereInput
    orderBy?: UserServiceOrderByWithAggregationInput | UserServiceOrderByWithAggregationInput[]
    by: UserServiceScalarFieldEnum[] | UserServiceScalarFieldEnum
    having?: UserServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserServiceCountAggregateInputType | true
    _min?: UserServiceMinAggregateInputType
    _max?: UserServiceMaxAggregateInputType
  }

  export type UserServiceGroupByOutputType = {
    id: string
    userId: string
    serviceId: string
    notify: boolean
    selectedAt: Date
    _count: UserServiceCountAggregateOutputType | null
    _min: UserServiceMinAggregateOutputType | null
    _max: UserServiceMaxAggregateOutputType | null
  }

  type GetUserServiceGroupByPayload<T extends UserServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserServiceGroupByOutputType[P]>
            : GetScalarType<T[P], UserServiceGroupByOutputType[P]>
        }
      >
    >


  export type UserServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    notify?: boolean
    selectedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userService"]>

  export type UserServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    notify?: boolean
    selectedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userService"]>

  export type UserServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    notify?: boolean
    selectedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userService"]>

  export type UserServiceSelectScalar = {
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    notify?: boolean
    selectedAt?: boolean
  }

  export type UserServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "serviceId" | "notify" | "selectedAt", ExtArgs["result"]["userService"]>
  export type UserServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type UserServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type UserServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $UserServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserService"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      serviceId: string
      notify: boolean
      selectedAt: Date
    }, ExtArgs["result"]["userService"]>
    composites: {}
  }

  type UserServiceGetPayload<S extends boolean | null | undefined | UserServiceDefaultArgs> = $Result.GetResult<Prisma.$UserServicePayload, S>

  type UserServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserServiceCountAggregateInputType | true
    }

  export interface UserServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserService'], meta: { name: 'UserService' } }
    /**
     * Find zero or one UserService that matches the filter.
     * @param {UserServiceFindUniqueArgs} args - Arguments to find a UserService
     * @example
     * // Get one UserService
     * const userService = await prisma.userService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserServiceFindUniqueArgs>(args: SelectSubset<T, UserServiceFindUniqueArgs<ExtArgs>>): Prisma__UserServiceClient<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserServiceFindUniqueOrThrowArgs} args - Arguments to find a UserService
     * @example
     * // Get one UserService
     * const userService = await prisma.userService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserServiceClient<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserServiceFindFirstArgs} args - Arguments to find a UserService
     * @example
     * // Get one UserService
     * const userService = await prisma.userService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserServiceFindFirstArgs>(args?: SelectSubset<T, UserServiceFindFirstArgs<ExtArgs>>): Prisma__UserServiceClient<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserServiceFindFirstOrThrowArgs} args - Arguments to find a UserService
     * @example
     * // Get one UserService
     * const userService = await prisma.userService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserServiceClient<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserServices
     * const userServices = await prisma.userService.findMany()
     * 
     * // Get first 10 UserServices
     * const userServices = await prisma.userService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userServiceWithIdOnly = await prisma.userService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserServiceFindManyArgs>(args?: SelectSubset<T, UserServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserService.
     * @param {UserServiceCreateArgs} args - Arguments to create a UserService.
     * @example
     * // Create one UserService
     * const UserService = await prisma.userService.create({
     *   data: {
     *     // ... data to create a UserService
     *   }
     * })
     * 
     */
    create<T extends UserServiceCreateArgs>(args: SelectSubset<T, UserServiceCreateArgs<ExtArgs>>): Prisma__UserServiceClient<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserServices.
     * @param {UserServiceCreateManyArgs} args - Arguments to create many UserServices.
     * @example
     * // Create many UserServices
     * const userService = await prisma.userService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserServiceCreateManyArgs>(args?: SelectSubset<T, UserServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserServices and returns the data saved in the database.
     * @param {UserServiceCreateManyAndReturnArgs} args - Arguments to create many UserServices.
     * @example
     * // Create many UserServices
     * const userService = await prisma.userService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserServices and only return the `id`
     * const userServiceWithIdOnly = await prisma.userService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserService.
     * @param {UserServiceDeleteArgs} args - Arguments to delete one UserService.
     * @example
     * // Delete one UserService
     * const UserService = await prisma.userService.delete({
     *   where: {
     *     // ... filter to delete one UserService
     *   }
     * })
     * 
     */
    delete<T extends UserServiceDeleteArgs>(args: SelectSubset<T, UserServiceDeleteArgs<ExtArgs>>): Prisma__UserServiceClient<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserService.
     * @param {UserServiceUpdateArgs} args - Arguments to update one UserService.
     * @example
     * // Update one UserService
     * const userService = await prisma.userService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserServiceUpdateArgs>(args: SelectSubset<T, UserServiceUpdateArgs<ExtArgs>>): Prisma__UserServiceClient<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserServices.
     * @param {UserServiceDeleteManyArgs} args - Arguments to filter UserServices to delete.
     * @example
     * // Delete a few UserServices
     * const { count } = await prisma.userService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserServiceDeleteManyArgs>(args?: SelectSubset<T, UserServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserServices
     * const userService = await prisma.userService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserServiceUpdateManyArgs>(args: SelectSubset<T, UserServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserServices and returns the data updated in the database.
     * @param {UserServiceUpdateManyAndReturnArgs} args - Arguments to update many UserServices.
     * @example
     * // Update many UserServices
     * const userService = await prisma.userService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserServices and only return the `id`
     * const userServiceWithIdOnly = await prisma.userService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserService.
     * @param {UserServiceUpsertArgs} args - Arguments to update or create a UserService.
     * @example
     * // Update or create a UserService
     * const userService = await prisma.userService.upsert({
     *   create: {
     *     // ... data to create a UserService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserService we want to update
     *   }
     * })
     */
    upsert<T extends UserServiceUpsertArgs>(args: SelectSubset<T, UserServiceUpsertArgs<ExtArgs>>): Prisma__UserServiceClient<$Result.GetResult<Prisma.$UserServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserServiceCountArgs} args - Arguments to filter UserServices to count.
     * @example
     * // Count the number of UserServices
     * const count = await prisma.userService.count({
     *   where: {
     *     // ... the filter for the UserServices we want to count
     *   }
     * })
    **/
    count<T extends UserServiceCountArgs>(
      args?: Subset<T, UserServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserServiceAggregateArgs>(args: Subset<T, UserServiceAggregateArgs>): Prisma.PrismaPromise<GetUserServiceAggregateType<T>>

    /**
     * Group by UserService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserServiceGroupByArgs['orderBy'] }
        : { orderBy?: UserServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserService model
   */
  readonly fields: UserServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserService model
   */
  interface UserServiceFieldRefs {
    readonly id: FieldRef<"UserService", 'String'>
    readonly userId: FieldRef<"UserService", 'String'>
    readonly serviceId: FieldRef<"UserService", 'String'>
    readonly notify: FieldRef<"UserService", 'Boolean'>
    readonly selectedAt: FieldRef<"UserService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserService findUnique
   */
  export type UserServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
    /**
     * Filter, which UserService to fetch.
     */
    where: UserServiceWhereUniqueInput
  }

  /**
   * UserService findUniqueOrThrow
   */
  export type UserServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
    /**
     * Filter, which UserService to fetch.
     */
    where: UserServiceWhereUniqueInput
  }

  /**
   * UserService findFirst
   */
  export type UserServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
    /**
     * Filter, which UserService to fetch.
     */
    where?: UserServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserServices to fetch.
     */
    orderBy?: UserServiceOrderByWithRelationInput | UserServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserServices.
     */
    cursor?: UserServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserServices.
     */
    distinct?: UserServiceScalarFieldEnum | UserServiceScalarFieldEnum[]
  }

  /**
   * UserService findFirstOrThrow
   */
  export type UserServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
    /**
     * Filter, which UserService to fetch.
     */
    where?: UserServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserServices to fetch.
     */
    orderBy?: UserServiceOrderByWithRelationInput | UserServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserServices.
     */
    cursor?: UserServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserServices.
     */
    distinct?: UserServiceScalarFieldEnum | UserServiceScalarFieldEnum[]
  }

  /**
   * UserService findMany
   */
  export type UserServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
    /**
     * Filter, which UserServices to fetch.
     */
    where?: UserServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserServices to fetch.
     */
    orderBy?: UserServiceOrderByWithRelationInput | UserServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserServices.
     */
    cursor?: UserServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserServices.
     */
    skip?: number
    distinct?: UserServiceScalarFieldEnum | UserServiceScalarFieldEnum[]
  }

  /**
   * UserService create
   */
  export type UserServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserService.
     */
    data: XOR<UserServiceCreateInput, UserServiceUncheckedCreateInput>
  }

  /**
   * UserService createMany
   */
  export type UserServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserServices.
     */
    data: UserServiceCreateManyInput | UserServiceCreateManyInput[]
  }

  /**
   * UserService createManyAndReturn
   */
  export type UserServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * The data used to create many UserServices.
     */
    data: UserServiceCreateManyInput | UserServiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserService update
   */
  export type UserServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserService.
     */
    data: XOR<UserServiceUpdateInput, UserServiceUncheckedUpdateInput>
    /**
     * Choose, which UserService to update.
     */
    where: UserServiceWhereUniqueInput
  }

  /**
   * UserService updateMany
   */
  export type UserServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserServices.
     */
    data: XOR<UserServiceUpdateManyMutationInput, UserServiceUncheckedUpdateManyInput>
    /**
     * Filter which UserServices to update
     */
    where?: UserServiceWhereInput
    /**
     * Limit how many UserServices to update.
     */
    limit?: number
  }

  /**
   * UserService updateManyAndReturn
   */
  export type UserServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * The data used to update UserServices.
     */
    data: XOR<UserServiceUpdateManyMutationInput, UserServiceUncheckedUpdateManyInput>
    /**
     * Filter which UserServices to update
     */
    where?: UserServiceWhereInput
    /**
     * Limit how many UserServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserService upsert
   */
  export type UserServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserService to update in case it exists.
     */
    where: UserServiceWhereUniqueInput
    /**
     * In case the UserService found by the `where` argument doesn't exist, create a new UserService with this data.
     */
    create: XOR<UserServiceCreateInput, UserServiceUncheckedCreateInput>
    /**
     * In case the UserService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserServiceUpdateInput, UserServiceUncheckedUpdateInput>
  }

  /**
   * UserService delete
   */
  export type UserServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
    /**
     * Filter which UserService to delete.
     */
    where: UserServiceWhereUniqueInput
  }

  /**
   * UserService deleteMany
   */
  export type UserServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserServices to delete
     */
    where?: UserServiceWhereInput
    /**
     * Limit how many UserServices to delete.
     */
    limit?: number
  }

  /**
   * UserService without action
   */
  export type UserServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserService
     */
    select?: UserServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserService
     */
    omit?: UserServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserServiceInclude<ExtArgs> | null
  }


  /**
   * Model PasswordReset
   */

  export type AggregatePasswordReset = {
    _count: PasswordResetCountAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  export type PasswordResetMinAggregateOutputType = {
    id: string | null
    email: string | null
    code: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetMaxAggregateOutputType = {
    id: string | null
    email: string | null
    code: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetCountAggregateOutputType = {
    id: number
    email: number
    code: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetMinAggregateInputType = {
    id?: true
    email?: true
    code?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PasswordResetMaxAggregateInputType = {
    id?: true
    email?: true
    code?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PasswordResetCountAggregateInputType = {
    id?: true
    email?: true
    code?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordReset to aggregate.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResets
    **/
    _count?: true | PasswordResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetMaxAggregateInputType
  }

  export type GetPasswordResetAggregateType<T extends PasswordResetAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordReset[P]>
      : GetScalarType<T[P], AggregatePasswordReset[P]>
  }




  export type PasswordResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithAggregationInput | PasswordResetOrderByWithAggregationInput[]
    by: PasswordResetScalarFieldEnum[] | PasswordResetScalarFieldEnum
    having?: PasswordResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetCountAggregateInputType | true
    _min?: PasswordResetMinAggregateInputType
    _max?: PasswordResetMaxAggregateInputType
  }

  export type PasswordResetGroupByOutputType = {
    id: string
    email: string
    code: string
    expiresAt: Date
    createdAt: Date
    _count: PasswordResetCountAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  type GetPasswordResetGroupByPayload<T extends PasswordResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    code?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    code?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    code?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectScalar = {
    id?: boolean
    email?: boolean
    code?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "code" | "expiresAt" | "createdAt", ExtArgs["result"]["passwordReset"]>

  export type $PasswordResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordReset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      code: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["passwordReset"]>
    composites: {}
  }

  type PasswordResetGetPayload<S extends boolean | null | undefined | PasswordResetDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetPayload, S>

  type PasswordResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetCountAggregateInputType | true
    }

  export interface PasswordResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordReset'], meta: { name: 'PasswordReset' } }
    /**
     * Find zero or one PasswordReset that matches the filter.
     * @param {PasswordResetFindUniqueArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetFindUniqueArgs>(args: SelectSubset<T, PasswordResetFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordReset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetFindUniqueOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetFindFirstArgs>(args?: SelectSubset<T, PasswordResetFindFirstArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany()
     * 
     * // Get first 10 PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetFindManyArgs>(args?: SelectSubset<T, PasswordResetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordReset.
     * @param {PasswordResetCreateArgs} args - Arguments to create a PasswordReset.
     * @example
     * // Create one PasswordReset
     * const PasswordReset = await prisma.passwordReset.create({
     *   data: {
     *     // ... data to create a PasswordReset
     *   }
     * })
     * 
     */
    create<T extends PasswordResetCreateArgs>(args: SelectSubset<T, PasswordResetCreateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResets.
     * @param {PasswordResetCreateManyArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetCreateManyArgs>(args?: SelectSubset<T, PasswordResetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResets and returns the data saved in the database.
     * @param {PasswordResetCreateManyAndReturnArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordReset.
     * @param {PasswordResetDeleteArgs} args - Arguments to delete one PasswordReset.
     * @example
     * // Delete one PasswordReset
     * const PasswordReset = await prisma.passwordReset.delete({
     *   where: {
     *     // ... filter to delete one PasswordReset
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetDeleteArgs>(args: SelectSubset<T, PasswordResetDeleteArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordReset.
     * @param {PasswordResetUpdateArgs} args - Arguments to update one PasswordReset.
     * @example
     * // Update one PasswordReset
     * const passwordReset = await prisma.passwordReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetUpdateArgs>(args: SelectSubset<T, PasswordResetUpdateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResets.
     * @param {PasswordResetDeleteManyArgs} args - Arguments to filter PasswordResets to delete.
     * @example
     * // Delete a few PasswordResets
     * const { count } = await prisma.passwordReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetDeleteManyArgs>(args?: SelectSubset<T, PasswordResetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetUpdateManyArgs>(args: SelectSubset<T, PasswordResetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets and returns the data updated in the database.
     * @param {PasswordResetUpdateManyAndReturnArgs} args - Arguments to update many PasswordResets.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordReset.
     * @param {PasswordResetUpsertArgs} args - Arguments to update or create a PasswordReset.
     * @example
     * // Update or create a PasswordReset
     * const passwordReset = await prisma.passwordReset.upsert({
     *   create: {
     *     // ... data to create a PasswordReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordReset we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetUpsertArgs>(args: SelectSubset<T, PasswordResetUpsertArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetCountArgs} args - Arguments to filter PasswordResets to count.
     * @example
     * // Count the number of PasswordResets
     * const count = await prisma.passwordReset.count({
     *   where: {
     *     // ... the filter for the PasswordResets we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetCountArgs>(
      args?: Subset<T, PasswordResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetAggregateArgs>(args: Subset<T, PasswordResetAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetAggregateType<T>>

    /**
     * Group by PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordReset model
   */
  readonly fields: PasswordResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordReset model
   */
  interface PasswordResetFieldRefs {
    readonly id: FieldRef<"PasswordReset", 'String'>
    readonly email: FieldRef<"PasswordReset", 'String'>
    readonly code: FieldRef<"PasswordReset", 'String'>
    readonly expiresAt: FieldRef<"PasswordReset", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordReset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordReset findUnique
   */
  export type PasswordResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findUniqueOrThrow
   */
  export type PasswordResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findFirst
   */
  export type PasswordResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findFirstOrThrow
   */
  export type PasswordResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findMany
   */
  export type PasswordResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset create
   */
  export type PasswordResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data needed to create a PasswordReset.
     */
    data: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
  }

  /**
   * PasswordReset createMany
   */
  export type PasswordResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
  }

  /**
   * PasswordReset createManyAndReturn
   */
  export type PasswordResetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
  }

  /**
   * PasswordReset update
   */
  export type PasswordResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data needed to update a PasswordReset.
     */
    data: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
    /**
     * Choose, which PasswordReset to update.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset updateMany
   */
  export type PasswordResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
  }

  /**
   * PasswordReset updateManyAndReturn
   */
  export type PasswordResetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
  }

  /**
   * PasswordReset upsert
   */
  export type PasswordResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The filter to search for the PasswordReset to update in case it exists.
     */
    where: PasswordResetWhereUniqueInput
    /**
     * In case the PasswordReset found by the `where` argument doesn't exist, create a new PasswordReset with this data.
     */
    create: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
    /**
     * In case the PasswordReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
  }

  /**
   * PasswordReset delete
   */
  export type PasswordResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Filter which PasswordReset to delete.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset deleteMany
   */
  export type PasswordResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResets to delete
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to delete.
     */
    limit?: number
  }

  /**
   * PasswordReset without action
   */
  export type PasswordResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
  }


  /**
   * Model TenantWebsite
   */

  export type AggregateTenantWebsite = {
    _count: TenantWebsiteCountAggregateOutputType | null
    _min: TenantWebsiteMinAggregateOutputType | null
    _max: TenantWebsiteMaxAggregateOutputType | null
  }

  export type TenantWebsiteMinAggregateOutputType = {
    id: string | null
    slug: string | null
    userId: string | null
    serviceId: string | null
    siteName: string | null
    description: string | null
    logo: string | null
    coverImage: string | null
    primaryColor: string | null
    config: string | null
    designTemplate: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantWebsiteMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    userId: string | null
    serviceId: string | null
    siteName: string | null
    description: string | null
    logo: string | null
    coverImage: string | null
    primaryColor: string | null
    config: string | null
    designTemplate: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantWebsiteCountAggregateOutputType = {
    id: number
    slug: number
    userId: number
    serviceId: number
    siteName: number
    description: number
    logo: number
    coverImage: number
    primaryColor: number
    config: number
    designTemplate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantWebsiteMinAggregateInputType = {
    id?: true
    slug?: true
    userId?: true
    serviceId?: true
    siteName?: true
    description?: true
    logo?: true
    coverImage?: true
    primaryColor?: true
    config?: true
    designTemplate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantWebsiteMaxAggregateInputType = {
    id?: true
    slug?: true
    userId?: true
    serviceId?: true
    siteName?: true
    description?: true
    logo?: true
    coverImage?: true
    primaryColor?: true
    config?: true
    designTemplate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantWebsiteCountAggregateInputType = {
    id?: true
    slug?: true
    userId?: true
    serviceId?: true
    siteName?: true
    description?: true
    logo?: true
    coverImage?: true
    primaryColor?: true
    config?: true
    designTemplate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantWebsiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantWebsite to aggregate.
     */
    where?: TenantWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantWebsites to fetch.
     */
    orderBy?: TenantWebsiteOrderByWithRelationInput | TenantWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantWebsites
    **/
    _count?: true | TenantWebsiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantWebsiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantWebsiteMaxAggregateInputType
  }

  export type GetTenantWebsiteAggregateType<T extends TenantWebsiteAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantWebsite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantWebsite[P]>
      : GetScalarType<T[P], AggregateTenantWebsite[P]>
  }




  export type TenantWebsiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWebsiteWhereInput
    orderBy?: TenantWebsiteOrderByWithAggregationInput | TenantWebsiteOrderByWithAggregationInput[]
    by: TenantWebsiteScalarFieldEnum[] | TenantWebsiteScalarFieldEnum
    having?: TenantWebsiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantWebsiteCountAggregateInputType | true
    _min?: TenantWebsiteMinAggregateInputType
    _max?: TenantWebsiteMaxAggregateInputType
  }

  export type TenantWebsiteGroupByOutputType = {
    id: string
    slug: string
    userId: string
    serviceId: string
    siteName: string
    description: string | null
    logo: string | null
    coverImage: string | null
    primaryColor: string
    config: string
    designTemplate: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TenantWebsiteCountAggregateOutputType | null
    _min: TenantWebsiteMinAggregateOutputType | null
    _max: TenantWebsiteMaxAggregateOutputType | null
  }

  type GetTenantWebsiteGroupByPayload<T extends TenantWebsiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantWebsiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantWebsiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantWebsiteGroupByOutputType[P]>
            : GetScalarType<T[P], TenantWebsiteGroupByOutputType[P]>
        }
      >
    >


  export type TenantWebsiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    userId?: boolean
    serviceId?: boolean
    siteName?: boolean
    description?: boolean
    logo?: boolean
    coverImage?: boolean
    primaryColor?: boolean
    config?: boolean
    designTemplate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categories?: boolean | TenantWebsite$categoriesArgs<ExtArgs>
    tables?: boolean | TenantWebsite$tablesArgs<ExtArgs>
    waiters?: boolean | TenantWebsite$waitersArgs<ExtArgs>
    cabinetServices?: boolean | TenantWebsite$cabinetServicesArgs<ExtArgs>
    cabinetClients?: boolean | TenantWebsite$cabinetClientsArgs<ExtArgs>
    cabinetAppointments?: boolean | TenantWebsite$cabinetAppointmentsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    _count?: boolean | TenantWebsiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantWebsite"]>

  export type TenantWebsiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    userId?: boolean
    serviceId?: boolean
    siteName?: boolean
    description?: boolean
    logo?: boolean
    coverImage?: boolean
    primaryColor?: boolean
    config?: boolean
    designTemplate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantWebsite"]>

  export type TenantWebsiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    userId?: boolean
    serviceId?: boolean
    siteName?: boolean
    description?: boolean
    logo?: boolean
    coverImage?: boolean
    primaryColor?: boolean
    config?: boolean
    designTemplate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantWebsite"]>

  export type TenantWebsiteSelectScalar = {
    id?: boolean
    slug?: boolean
    userId?: boolean
    serviceId?: boolean
    siteName?: boolean
    description?: boolean
    logo?: boolean
    coverImage?: boolean
    primaryColor?: boolean
    config?: boolean
    designTemplate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantWebsiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "userId" | "serviceId" | "siteName" | "description" | "logo" | "coverImage" | "primaryColor" | "config" | "designTemplate" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantWebsite"]>
  export type TenantWebsiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | TenantWebsite$categoriesArgs<ExtArgs>
    tables?: boolean | TenantWebsite$tablesArgs<ExtArgs>
    waiters?: boolean | TenantWebsite$waitersArgs<ExtArgs>
    cabinetServices?: boolean | TenantWebsite$cabinetServicesArgs<ExtArgs>
    cabinetClients?: boolean | TenantWebsite$cabinetClientsArgs<ExtArgs>
    cabinetAppointments?: boolean | TenantWebsite$cabinetAppointmentsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    _count?: boolean | TenantWebsiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantWebsiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type TenantWebsiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $TenantWebsitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantWebsite"
    objects: {
      categories: Prisma.$RestaurantCategoryPayload<ExtArgs>[]
      tables: Prisma.$RestaurantTablePayload<ExtArgs>[]
      waiters: Prisma.$RestaurantWaiterPayload<ExtArgs>[]
      cabinetServices: Prisma.$CabinetServicePayload<ExtArgs>[]
      cabinetClients: Prisma.$CabinetClientPayload<ExtArgs>[]
      cabinetAppointments: Prisma.$CabinetAppointmentPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      userId: string
      serviceId: string
      siteName: string
      description: string | null
      logo: string | null
      coverImage: string | null
      primaryColor: string
      config: string
      designTemplate: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantWebsite"]>
    composites: {}
  }

  type TenantWebsiteGetPayload<S extends boolean | null | undefined | TenantWebsiteDefaultArgs> = $Result.GetResult<Prisma.$TenantWebsitePayload, S>

  type TenantWebsiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantWebsiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantWebsiteCountAggregateInputType | true
    }

  export interface TenantWebsiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantWebsite'], meta: { name: 'TenantWebsite' } }
    /**
     * Find zero or one TenantWebsite that matches the filter.
     * @param {TenantWebsiteFindUniqueArgs} args - Arguments to find a TenantWebsite
     * @example
     * // Get one TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantWebsiteFindUniqueArgs>(args: SelectSubset<T, TenantWebsiteFindUniqueArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantWebsite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantWebsiteFindUniqueOrThrowArgs} args - Arguments to find a TenantWebsite
     * @example
     * // Get one TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantWebsiteFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantWebsiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantWebsite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteFindFirstArgs} args - Arguments to find a TenantWebsite
     * @example
     * // Get one TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantWebsiteFindFirstArgs>(args?: SelectSubset<T, TenantWebsiteFindFirstArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantWebsite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteFindFirstOrThrowArgs} args - Arguments to find a TenantWebsite
     * @example
     * // Get one TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantWebsiteFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantWebsiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantWebsites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantWebsites
     * const tenantWebsites = await prisma.tenantWebsite.findMany()
     * 
     * // Get first 10 TenantWebsites
     * const tenantWebsites = await prisma.tenantWebsite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWebsiteWithIdOnly = await prisma.tenantWebsite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantWebsiteFindManyArgs>(args?: SelectSubset<T, TenantWebsiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantWebsite.
     * @param {TenantWebsiteCreateArgs} args - Arguments to create a TenantWebsite.
     * @example
     * // Create one TenantWebsite
     * const TenantWebsite = await prisma.tenantWebsite.create({
     *   data: {
     *     // ... data to create a TenantWebsite
     *   }
     * })
     * 
     */
    create<T extends TenantWebsiteCreateArgs>(args: SelectSubset<T, TenantWebsiteCreateArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantWebsites.
     * @param {TenantWebsiteCreateManyArgs} args - Arguments to create many TenantWebsites.
     * @example
     * // Create many TenantWebsites
     * const tenantWebsite = await prisma.tenantWebsite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantWebsiteCreateManyArgs>(args?: SelectSubset<T, TenantWebsiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantWebsites and returns the data saved in the database.
     * @param {TenantWebsiteCreateManyAndReturnArgs} args - Arguments to create many TenantWebsites.
     * @example
     * // Create many TenantWebsites
     * const tenantWebsite = await prisma.tenantWebsite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantWebsites and only return the `id`
     * const tenantWebsiteWithIdOnly = await prisma.tenantWebsite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantWebsiteCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantWebsiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantWebsite.
     * @param {TenantWebsiteDeleteArgs} args - Arguments to delete one TenantWebsite.
     * @example
     * // Delete one TenantWebsite
     * const TenantWebsite = await prisma.tenantWebsite.delete({
     *   where: {
     *     // ... filter to delete one TenantWebsite
     *   }
     * })
     * 
     */
    delete<T extends TenantWebsiteDeleteArgs>(args: SelectSubset<T, TenantWebsiteDeleteArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantWebsite.
     * @param {TenantWebsiteUpdateArgs} args - Arguments to update one TenantWebsite.
     * @example
     * // Update one TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantWebsiteUpdateArgs>(args: SelectSubset<T, TenantWebsiteUpdateArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantWebsites.
     * @param {TenantWebsiteDeleteManyArgs} args - Arguments to filter TenantWebsites to delete.
     * @example
     * // Delete a few TenantWebsites
     * const { count } = await prisma.tenantWebsite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantWebsiteDeleteManyArgs>(args?: SelectSubset<T, TenantWebsiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantWebsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantWebsites
     * const tenantWebsite = await prisma.tenantWebsite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantWebsiteUpdateManyArgs>(args: SelectSubset<T, TenantWebsiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantWebsites and returns the data updated in the database.
     * @param {TenantWebsiteUpdateManyAndReturnArgs} args - Arguments to update many TenantWebsites.
     * @example
     * // Update many TenantWebsites
     * const tenantWebsite = await prisma.tenantWebsite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantWebsites and only return the `id`
     * const tenantWebsiteWithIdOnly = await prisma.tenantWebsite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantWebsiteUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantWebsiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantWebsite.
     * @param {TenantWebsiteUpsertArgs} args - Arguments to update or create a TenantWebsite.
     * @example
     * // Update or create a TenantWebsite
     * const tenantWebsite = await prisma.tenantWebsite.upsert({
     *   create: {
     *     // ... data to create a TenantWebsite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantWebsite we want to update
     *   }
     * })
     */
    upsert<T extends TenantWebsiteUpsertArgs>(args: SelectSubset<T, TenantWebsiteUpsertArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantWebsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteCountArgs} args - Arguments to filter TenantWebsites to count.
     * @example
     * // Count the number of TenantWebsites
     * const count = await prisma.tenantWebsite.count({
     *   where: {
     *     // ... the filter for the TenantWebsites we want to count
     *   }
     * })
    **/
    count<T extends TenantWebsiteCountArgs>(
      args?: Subset<T, TenantWebsiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantWebsiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantWebsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantWebsiteAggregateArgs>(args: Subset<T, TenantWebsiteAggregateArgs>): Prisma.PrismaPromise<GetTenantWebsiteAggregateType<T>>

    /**
     * Group by TenantWebsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantWebsiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantWebsiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantWebsiteGroupByArgs['orderBy'] }
        : { orderBy?: TenantWebsiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantWebsiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantWebsiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantWebsite model
   */
  readonly fields: TenantWebsiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantWebsite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantWebsiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends TenantWebsite$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsite$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tables<T extends TenantWebsite$tablesArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsite$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waiters<T extends TenantWebsite$waitersArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsite$waitersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cabinetServices<T extends TenantWebsite$cabinetServicesArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsite$cabinetServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cabinetClients<T extends TenantWebsite$cabinetClientsArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsite$cabinetClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cabinetAppointments<T extends TenantWebsite$cabinetAppointmentsArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsite$cabinetAppointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantWebsite model
   */
  interface TenantWebsiteFieldRefs {
    readonly id: FieldRef<"TenantWebsite", 'String'>
    readonly slug: FieldRef<"TenantWebsite", 'String'>
    readonly userId: FieldRef<"TenantWebsite", 'String'>
    readonly serviceId: FieldRef<"TenantWebsite", 'String'>
    readonly siteName: FieldRef<"TenantWebsite", 'String'>
    readonly description: FieldRef<"TenantWebsite", 'String'>
    readonly logo: FieldRef<"TenantWebsite", 'String'>
    readonly coverImage: FieldRef<"TenantWebsite", 'String'>
    readonly primaryColor: FieldRef<"TenantWebsite", 'String'>
    readonly config: FieldRef<"TenantWebsite", 'String'>
    readonly designTemplate: FieldRef<"TenantWebsite", 'String'>
    readonly isActive: FieldRef<"TenantWebsite", 'Boolean'>
    readonly createdAt: FieldRef<"TenantWebsite", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantWebsite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantWebsite findUnique
   */
  export type TenantWebsiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which TenantWebsite to fetch.
     */
    where: TenantWebsiteWhereUniqueInput
  }

  /**
   * TenantWebsite findUniqueOrThrow
   */
  export type TenantWebsiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which TenantWebsite to fetch.
     */
    where: TenantWebsiteWhereUniqueInput
  }

  /**
   * TenantWebsite findFirst
   */
  export type TenantWebsiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which TenantWebsite to fetch.
     */
    where?: TenantWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantWebsites to fetch.
     */
    orderBy?: TenantWebsiteOrderByWithRelationInput | TenantWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantWebsites.
     */
    cursor?: TenantWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantWebsites.
     */
    distinct?: TenantWebsiteScalarFieldEnum | TenantWebsiteScalarFieldEnum[]
  }

  /**
   * TenantWebsite findFirstOrThrow
   */
  export type TenantWebsiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which TenantWebsite to fetch.
     */
    where?: TenantWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantWebsites to fetch.
     */
    orderBy?: TenantWebsiteOrderByWithRelationInput | TenantWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantWebsites.
     */
    cursor?: TenantWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantWebsites.
     */
    distinct?: TenantWebsiteScalarFieldEnum | TenantWebsiteScalarFieldEnum[]
  }

  /**
   * TenantWebsite findMany
   */
  export type TenantWebsiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which TenantWebsites to fetch.
     */
    where?: TenantWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantWebsites to fetch.
     */
    orderBy?: TenantWebsiteOrderByWithRelationInput | TenantWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantWebsites.
     */
    cursor?: TenantWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantWebsites.
     */
    skip?: number
    distinct?: TenantWebsiteScalarFieldEnum | TenantWebsiteScalarFieldEnum[]
  }

  /**
   * TenantWebsite create
   */
  export type TenantWebsiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantWebsite.
     */
    data: XOR<TenantWebsiteCreateInput, TenantWebsiteUncheckedCreateInput>
  }

  /**
   * TenantWebsite createMany
   */
  export type TenantWebsiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantWebsites.
     */
    data: TenantWebsiteCreateManyInput | TenantWebsiteCreateManyInput[]
  }

  /**
   * TenantWebsite createManyAndReturn
   */
  export type TenantWebsiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * The data used to create many TenantWebsites.
     */
    data: TenantWebsiteCreateManyInput | TenantWebsiteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantWebsite update
   */
  export type TenantWebsiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantWebsite.
     */
    data: XOR<TenantWebsiteUpdateInput, TenantWebsiteUncheckedUpdateInput>
    /**
     * Choose, which TenantWebsite to update.
     */
    where: TenantWebsiteWhereUniqueInput
  }

  /**
   * TenantWebsite updateMany
   */
  export type TenantWebsiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantWebsites.
     */
    data: XOR<TenantWebsiteUpdateManyMutationInput, TenantWebsiteUncheckedUpdateManyInput>
    /**
     * Filter which TenantWebsites to update
     */
    where?: TenantWebsiteWhereInput
    /**
     * Limit how many TenantWebsites to update.
     */
    limit?: number
  }

  /**
   * TenantWebsite updateManyAndReturn
   */
  export type TenantWebsiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * The data used to update TenantWebsites.
     */
    data: XOR<TenantWebsiteUpdateManyMutationInput, TenantWebsiteUncheckedUpdateManyInput>
    /**
     * Filter which TenantWebsites to update
     */
    where?: TenantWebsiteWhereInput
    /**
     * Limit how many TenantWebsites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantWebsite upsert
   */
  export type TenantWebsiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantWebsite to update in case it exists.
     */
    where: TenantWebsiteWhereUniqueInput
    /**
     * In case the TenantWebsite found by the `where` argument doesn't exist, create a new TenantWebsite with this data.
     */
    create: XOR<TenantWebsiteCreateInput, TenantWebsiteUncheckedCreateInput>
    /**
     * In case the TenantWebsite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantWebsiteUpdateInput, TenantWebsiteUncheckedUpdateInput>
  }

  /**
   * TenantWebsite delete
   */
  export type TenantWebsiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
    /**
     * Filter which TenantWebsite to delete.
     */
    where: TenantWebsiteWhereUniqueInput
  }

  /**
   * TenantWebsite deleteMany
   */
  export type TenantWebsiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantWebsites to delete
     */
    where?: TenantWebsiteWhereInput
    /**
     * Limit how many TenantWebsites to delete.
     */
    limit?: number
  }

  /**
   * TenantWebsite.categories
   */
  export type TenantWebsite$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryInclude<ExtArgs> | null
    where?: RestaurantCategoryWhereInput
    orderBy?: RestaurantCategoryOrderByWithRelationInput | RestaurantCategoryOrderByWithRelationInput[]
    cursor?: RestaurantCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantCategoryScalarFieldEnum | RestaurantCategoryScalarFieldEnum[]
  }

  /**
   * TenantWebsite.tables
   */
  export type TenantWebsite$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
    where?: RestaurantTableWhereInput
    orderBy?: RestaurantTableOrderByWithRelationInput | RestaurantTableOrderByWithRelationInput[]
    cursor?: RestaurantTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantTableScalarFieldEnum | RestaurantTableScalarFieldEnum[]
  }

  /**
   * TenantWebsite.waiters
   */
  export type TenantWebsite$waitersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
    where?: RestaurantWaiterWhereInput
    orderBy?: RestaurantWaiterOrderByWithRelationInput | RestaurantWaiterOrderByWithRelationInput[]
    cursor?: RestaurantWaiterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantWaiterScalarFieldEnum | RestaurantWaiterScalarFieldEnum[]
  }

  /**
   * TenantWebsite.cabinetServices
   */
  export type TenantWebsite$cabinetServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceInclude<ExtArgs> | null
    where?: CabinetServiceWhereInput
    orderBy?: CabinetServiceOrderByWithRelationInput | CabinetServiceOrderByWithRelationInput[]
    cursor?: CabinetServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetServiceScalarFieldEnum | CabinetServiceScalarFieldEnum[]
  }

  /**
   * TenantWebsite.cabinetClients
   */
  export type TenantWebsite$cabinetClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientInclude<ExtArgs> | null
    where?: CabinetClientWhereInput
    orderBy?: CabinetClientOrderByWithRelationInput | CabinetClientOrderByWithRelationInput[]
    cursor?: CabinetClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetClientScalarFieldEnum | CabinetClientScalarFieldEnum[]
  }

  /**
   * TenantWebsite.cabinetAppointments
   */
  export type TenantWebsite$cabinetAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    where?: CabinetAppointmentWhereInput
    orderBy?: CabinetAppointmentOrderByWithRelationInput | CabinetAppointmentOrderByWithRelationInput[]
    cursor?: CabinetAppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetAppointmentScalarFieldEnum | CabinetAppointmentScalarFieldEnum[]
  }

  /**
   * TenantWebsite without action
   */
  export type TenantWebsiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantWebsite
     */
    select?: TenantWebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantWebsite
     */
    omit?: TenantWebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantWebsiteInclude<ExtArgs> | null
  }


  /**
   * Model RestaurantCategory
   */

  export type AggregateRestaurantCategory = {
    _count: RestaurantCategoryCountAggregateOutputType | null
    _avg: RestaurantCategoryAvgAggregateOutputType | null
    _sum: RestaurantCategorySumAggregateOutputType | null
    _min: RestaurantCategoryMinAggregateOutputType | null
    _max: RestaurantCategoryMaxAggregateOutputType | null
  }

  export type RestaurantCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type RestaurantCategorySumAggregateOutputType = {
    order: number | null
  }

  export type RestaurantCategoryMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    order: number | null
    isActive: boolean | null
  }

  export type RestaurantCategoryMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    order: number | null
    isActive: boolean | null
  }

  export type RestaurantCategoryCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    order: number
    isActive: number
    _all: number
  }


  export type RestaurantCategoryAvgAggregateInputType = {
    order?: true
  }

  export type RestaurantCategorySumAggregateInputType = {
    order?: true
  }

  export type RestaurantCategoryMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    order?: true
    isActive?: true
  }

  export type RestaurantCategoryMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    order?: true
    isActive?: true
  }

  export type RestaurantCategoryCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    order?: true
    isActive?: true
    _all?: true
  }

  export type RestaurantCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantCategory to aggregate.
     */
    where?: RestaurantCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantCategories to fetch.
     */
    orderBy?: RestaurantCategoryOrderByWithRelationInput | RestaurantCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RestaurantCategories
    **/
    _count?: true | RestaurantCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestaurantCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestaurantCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantCategoryMaxAggregateInputType
  }

  export type GetRestaurantCategoryAggregateType<T extends RestaurantCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurantCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurantCategory[P]>
      : GetScalarType<T[P], AggregateRestaurantCategory[P]>
  }




  export type RestaurantCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantCategoryWhereInput
    orderBy?: RestaurantCategoryOrderByWithAggregationInput | RestaurantCategoryOrderByWithAggregationInput[]
    by: RestaurantCategoryScalarFieldEnum[] | RestaurantCategoryScalarFieldEnum
    having?: RestaurantCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantCategoryCountAggregateInputType | true
    _avg?: RestaurantCategoryAvgAggregateInputType
    _sum?: RestaurantCategorySumAggregateInputType
    _min?: RestaurantCategoryMinAggregateInputType
    _max?: RestaurantCategoryMaxAggregateInputType
  }

  export type RestaurantCategoryGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    order: number
    isActive: boolean
    _count: RestaurantCategoryCountAggregateOutputType | null
    _avg: RestaurantCategoryAvgAggregateOutputType | null
    _sum: RestaurantCategorySumAggregateOutputType | null
    _min: RestaurantCategoryMinAggregateOutputType | null
    _max: RestaurantCategoryMaxAggregateOutputType | null
  }

  type GetRestaurantCategoryGroupByPayload<T extends RestaurantCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantCategoryGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    order?: boolean
    isActive?: boolean
    dishes?: boolean | RestaurantCategory$dishesArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    _count?: boolean | RestaurantCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantCategory"]>

  export type RestaurantCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    order?: boolean
    isActive?: boolean
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantCategory"]>

  export type RestaurantCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    order?: boolean
    isActive?: boolean
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantCategory"]>

  export type RestaurantCategorySelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    order?: boolean
    isActive?: boolean
  }

  export type RestaurantCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "order" | "isActive", ExtArgs["result"]["restaurantCategory"]>
  export type RestaurantCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dishes?: boolean | RestaurantCategory$dishesArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    _count?: boolean | RestaurantCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RestaurantCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type RestaurantCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }

  export type $RestaurantCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RestaurantCategory"
    objects: {
      dishes: Prisma.$RestaurantDishPayload<ExtArgs>[]
      tenant: Prisma.$TenantWebsitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      order: number
      isActive: boolean
    }, ExtArgs["result"]["restaurantCategory"]>
    composites: {}
  }

  type RestaurantCategoryGetPayload<S extends boolean | null | undefined | RestaurantCategoryDefaultArgs> = $Result.GetResult<Prisma.$RestaurantCategoryPayload, S>

  type RestaurantCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestaurantCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RestaurantCategoryCountAggregateInputType | true
    }

  export interface RestaurantCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RestaurantCategory'], meta: { name: 'RestaurantCategory' } }
    /**
     * Find zero or one RestaurantCategory that matches the filter.
     * @param {RestaurantCategoryFindUniqueArgs} args - Arguments to find a RestaurantCategory
     * @example
     * // Get one RestaurantCategory
     * const restaurantCategory = await prisma.restaurantCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantCategoryFindUniqueArgs>(args: SelectSubset<T, RestaurantCategoryFindUniqueArgs<ExtArgs>>): Prisma__RestaurantCategoryClient<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RestaurantCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestaurantCategoryFindUniqueOrThrowArgs} args - Arguments to find a RestaurantCategory
     * @example
     * // Get one RestaurantCategory
     * const restaurantCategory = await prisma.restaurantCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantCategoryClient<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCategoryFindFirstArgs} args - Arguments to find a RestaurantCategory
     * @example
     * // Get one RestaurantCategory
     * const restaurantCategory = await prisma.restaurantCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantCategoryFindFirstArgs>(args?: SelectSubset<T, RestaurantCategoryFindFirstArgs<ExtArgs>>): Prisma__RestaurantCategoryClient<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCategoryFindFirstOrThrowArgs} args - Arguments to find a RestaurantCategory
     * @example
     * // Get one RestaurantCategory
     * const restaurantCategory = await prisma.restaurantCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantCategoryClient<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RestaurantCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestaurantCategories
     * const restaurantCategories = await prisma.restaurantCategory.findMany()
     * 
     * // Get first 10 RestaurantCategories
     * const restaurantCategories = await prisma.restaurantCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantCategoryWithIdOnly = await prisma.restaurantCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantCategoryFindManyArgs>(args?: SelectSubset<T, RestaurantCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RestaurantCategory.
     * @param {RestaurantCategoryCreateArgs} args - Arguments to create a RestaurantCategory.
     * @example
     * // Create one RestaurantCategory
     * const RestaurantCategory = await prisma.restaurantCategory.create({
     *   data: {
     *     // ... data to create a RestaurantCategory
     *   }
     * })
     * 
     */
    create<T extends RestaurantCategoryCreateArgs>(args: SelectSubset<T, RestaurantCategoryCreateArgs<ExtArgs>>): Prisma__RestaurantCategoryClient<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RestaurantCategories.
     * @param {RestaurantCategoryCreateManyArgs} args - Arguments to create many RestaurantCategories.
     * @example
     * // Create many RestaurantCategories
     * const restaurantCategory = await prisma.restaurantCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantCategoryCreateManyArgs>(args?: SelectSubset<T, RestaurantCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RestaurantCategories and returns the data saved in the database.
     * @param {RestaurantCategoryCreateManyAndReturnArgs} args - Arguments to create many RestaurantCategories.
     * @example
     * // Create many RestaurantCategories
     * const restaurantCategory = await prisma.restaurantCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RestaurantCategories and only return the `id`
     * const restaurantCategoryWithIdOnly = await prisma.restaurantCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestaurantCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, RestaurantCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RestaurantCategory.
     * @param {RestaurantCategoryDeleteArgs} args - Arguments to delete one RestaurantCategory.
     * @example
     * // Delete one RestaurantCategory
     * const RestaurantCategory = await prisma.restaurantCategory.delete({
     *   where: {
     *     // ... filter to delete one RestaurantCategory
     *   }
     * })
     * 
     */
    delete<T extends RestaurantCategoryDeleteArgs>(args: SelectSubset<T, RestaurantCategoryDeleteArgs<ExtArgs>>): Prisma__RestaurantCategoryClient<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RestaurantCategory.
     * @param {RestaurantCategoryUpdateArgs} args - Arguments to update one RestaurantCategory.
     * @example
     * // Update one RestaurantCategory
     * const restaurantCategory = await prisma.restaurantCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantCategoryUpdateArgs>(args: SelectSubset<T, RestaurantCategoryUpdateArgs<ExtArgs>>): Prisma__RestaurantCategoryClient<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RestaurantCategories.
     * @param {RestaurantCategoryDeleteManyArgs} args - Arguments to filter RestaurantCategories to delete.
     * @example
     * // Delete a few RestaurantCategories
     * const { count } = await prisma.restaurantCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantCategoryDeleteManyArgs>(args?: SelectSubset<T, RestaurantCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestaurantCategories
     * const restaurantCategory = await prisma.restaurantCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantCategoryUpdateManyArgs>(args: SelectSubset<T, RestaurantCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantCategories and returns the data updated in the database.
     * @param {RestaurantCategoryUpdateManyAndReturnArgs} args - Arguments to update many RestaurantCategories.
     * @example
     * // Update many RestaurantCategories
     * const restaurantCategory = await prisma.restaurantCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RestaurantCategories and only return the `id`
     * const restaurantCategoryWithIdOnly = await prisma.restaurantCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RestaurantCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, RestaurantCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RestaurantCategory.
     * @param {RestaurantCategoryUpsertArgs} args - Arguments to update or create a RestaurantCategory.
     * @example
     * // Update or create a RestaurantCategory
     * const restaurantCategory = await prisma.restaurantCategory.upsert({
     *   create: {
     *     // ... data to create a RestaurantCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestaurantCategory we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantCategoryUpsertArgs>(args: SelectSubset<T, RestaurantCategoryUpsertArgs<ExtArgs>>): Prisma__RestaurantCategoryClient<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RestaurantCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCategoryCountArgs} args - Arguments to filter RestaurantCategories to count.
     * @example
     * // Count the number of RestaurantCategories
     * const count = await prisma.restaurantCategory.count({
     *   where: {
     *     // ... the filter for the RestaurantCategories we want to count
     *   }
     * })
    **/
    count<T extends RestaurantCategoryCountArgs>(
      args?: Subset<T, RestaurantCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RestaurantCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantCategoryAggregateArgs>(args: Subset<T, RestaurantCategoryAggregateArgs>): Prisma.PrismaPromise<GetRestaurantCategoryAggregateType<T>>

    /**
     * Group by RestaurantCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantCategoryGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RestaurantCategory model
   */
  readonly fields: RestaurantCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestaurantCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dishes<T extends RestaurantCategory$dishesArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantCategory$dishesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantWebsiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsiteDefaultArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RestaurantCategory model
   */
  interface RestaurantCategoryFieldRefs {
    readonly id: FieldRef<"RestaurantCategory", 'String'>
    readonly tenantId: FieldRef<"RestaurantCategory", 'String'>
    readonly name: FieldRef<"RestaurantCategory", 'String'>
    readonly order: FieldRef<"RestaurantCategory", 'Int'>
    readonly isActive: FieldRef<"RestaurantCategory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RestaurantCategory findUnique
   */
  export type RestaurantCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantCategory to fetch.
     */
    where: RestaurantCategoryWhereUniqueInput
  }

  /**
   * RestaurantCategory findUniqueOrThrow
   */
  export type RestaurantCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantCategory to fetch.
     */
    where: RestaurantCategoryWhereUniqueInput
  }

  /**
   * RestaurantCategory findFirst
   */
  export type RestaurantCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantCategory to fetch.
     */
    where?: RestaurantCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantCategories to fetch.
     */
    orderBy?: RestaurantCategoryOrderByWithRelationInput | RestaurantCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantCategories.
     */
    cursor?: RestaurantCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantCategories.
     */
    distinct?: RestaurantCategoryScalarFieldEnum | RestaurantCategoryScalarFieldEnum[]
  }

  /**
   * RestaurantCategory findFirstOrThrow
   */
  export type RestaurantCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantCategory to fetch.
     */
    where?: RestaurantCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantCategories to fetch.
     */
    orderBy?: RestaurantCategoryOrderByWithRelationInput | RestaurantCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantCategories.
     */
    cursor?: RestaurantCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantCategories.
     */
    distinct?: RestaurantCategoryScalarFieldEnum | RestaurantCategoryScalarFieldEnum[]
  }

  /**
   * RestaurantCategory findMany
   */
  export type RestaurantCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantCategories to fetch.
     */
    where?: RestaurantCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantCategories to fetch.
     */
    orderBy?: RestaurantCategoryOrderByWithRelationInput | RestaurantCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RestaurantCategories.
     */
    cursor?: RestaurantCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantCategories.
     */
    skip?: number
    distinct?: RestaurantCategoryScalarFieldEnum | RestaurantCategoryScalarFieldEnum[]
  }

  /**
   * RestaurantCategory create
   */
  export type RestaurantCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a RestaurantCategory.
     */
    data: XOR<RestaurantCategoryCreateInput, RestaurantCategoryUncheckedCreateInput>
  }

  /**
   * RestaurantCategory createMany
   */
  export type RestaurantCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RestaurantCategories.
     */
    data: RestaurantCategoryCreateManyInput | RestaurantCategoryCreateManyInput[]
  }

  /**
   * RestaurantCategory createManyAndReturn
   */
  export type RestaurantCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many RestaurantCategories.
     */
    data: RestaurantCategoryCreateManyInput | RestaurantCategoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantCategory update
   */
  export type RestaurantCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a RestaurantCategory.
     */
    data: XOR<RestaurantCategoryUpdateInput, RestaurantCategoryUncheckedUpdateInput>
    /**
     * Choose, which RestaurantCategory to update.
     */
    where: RestaurantCategoryWhereUniqueInput
  }

  /**
   * RestaurantCategory updateMany
   */
  export type RestaurantCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RestaurantCategories.
     */
    data: XOR<RestaurantCategoryUpdateManyMutationInput, RestaurantCategoryUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantCategories to update
     */
    where?: RestaurantCategoryWhereInput
    /**
     * Limit how many RestaurantCategories to update.
     */
    limit?: number
  }

  /**
   * RestaurantCategory updateManyAndReturn
   */
  export type RestaurantCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * The data used to update RestaurantCategories.
     */
    data: XOR<RestaurantCategoryUpdateManyMutationInput, RestaurantCategoryUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantCategories to update
     */
    where?: RestaurantCategoryWhereInput
    /**
     * Limit how many RestaurantCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantCategory upsert
   */
  export type RestaurantCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the RestaurantCategory to update in case it exists.
     */
    where: RestaurantCategoryWhereUniqueInput
    /**
     * In case the RestaurantCategory found by the `where` argument doesn't exist, create a new RestaurantCategory with this data.
     */
    create: XOR<RestaurantCategoryCreateInput, RestaurantCategoryUncheckedCreateInput>
    /**
     * In case the RestaurantCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantCategoryUpdateInput, RestaurantCategoryUncheckedUpdateInput>
  }

  /**
   * RestaurantCategory delete
   */
  export type RestaurantCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryInclude<ExtArgs> | null
    /**
     * Filter which RestaurantCategory to delete.
     */
    where: RestaurantCategoryWhereUniqueInput
  }

  /**
   * RestaurantCategory deleteMany
   */
  export type RestaurantCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantCategories to delete
     */
    where?: RestaurantCategoryWhereInput
    /**
     * Limit how many RestaurantCategories to delete.
     */
    limit?: number
  }

  /**
   * RestaurantCategory.dishes
   */
  export type RestaurantCategory$dishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishInclude<ExtArgs> | null
    where?: RestaurantDishWhereInput
    orderBy?: RestaurantDishOrderByWithRelationInput | RestaurantDishOrderByWithRelationInput[]
    cursor?: RestaurantDishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantDishScalarFieldEnum | RestaurantDishScalarFieldEnum[]
  }

  /**
   * RestaurantCategory without action
   */
  export type RestaurantCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCategory
     */
    select?: RestaurantCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantCategory
     */
    omit?: RestaurantCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantCategoryInclude<ExtArgs> | null
  }


  /**
   * Model RestaurantDish
   */

  export type AggregateRestaurantDish = {
    _count: RestaurantDishCountAggregateOutputType | null
    _avg: RestaurantDishAvgAggregateOutputType | null
    _sum: RestaurantDishSumAggregateOutputType | null
    _min: RestaurantDishMinAggregateOutputType | null
    _max: RestaurantDishMaxAggregateOutputType | null
  }

  export type RestaurantDishAvgAggregateOutputType = {
    price: number | null
    order: number | null
  }

  export type RestaurantDishSumAggregateOutputType = {
    price: number | null
    order: number | null
  }

  export type RestaurantDishMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    description: string | null
    price: number | null
    image: string | null
    isActive: boolean | null
    order: number | null
  }

  export type RestaurantDishMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    description: string | null
    price: number | null
    image: string | null
    isActive: boolean | null
    order: number | null
  }

  export type RestaurantDishCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    description: number
    price: number
    image: number
    isActive: number
    order: number
    _all: number
  }


  export type RestaurantDishAvgAggregateInputType = {
    price?: true
    order?: true
  }

  export type RestaurantDishSumAggregateInputType = {
    price?: true
    order?: true
  }

  export type RestaurantDishMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    description?: true
    price?: true
    image?: true
    isActive?: true
    order?: true
  }

  export type RestaurantDishMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    description?: true
    price?: true
    image?: true
    isActive?: true
    order?: true
  }

  export type RestaurantDishCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    description?: true
    price?: true
    image?: true
    isActive?: true
    order?: true
    _all?: true
  }

  export type RestaurantDishAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantDish to aggregate.
     */
    where?: RestaurantDishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantDishes to fetch.
     */
    orderBy?: RestaurantDishOrderByWithRelationInput | RestaurantDishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantDishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantDishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantDishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RestaurantDishes
    **/
    _count?: true | RestaurantDishCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestaurantDishAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestaurantDishSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantDishMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantDishMaxAggregateInputType
  }

  export type GetRestaurantDishAggregateType<T extends RestaurantDishAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurantDish]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurantDish[P]>
      : GetScalarType<T[P], AggregateRestaurantDish[P]>
  }




  export type RestaurantDishGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantDishWhereInput
    orderBy?: RestaurantDishOrderByWithAggregationInput | RestaurantDishOrderByWithAggregationInput[]
    by: RestaurantDishScalarFieldEnum[] | RestaurantDishScalarFieldEnum
    having?: RestaurantDishScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantDishCountAggregateInputType | true
    _avg?: RestaurantDishAvgAggregateInputType
    _sum?: RestaurantDishSumAggregateInputType
    _min?: RestaurantDishMinAggregateInputType
    _max?: RestaurantDishMaxAggregateInputType
  }

  export type RestaurantDishGroupByOutputType = {
    id: string
    categoryId: string
    name: string
    description: string | null
    price: number
    image: string | null
    isActive: boolean
    order: number
    _count: RestaurantDishCountAggregateOutputType | null
    _avg: RestaurantDishAvgAggregateOutputType | null
    _sum: RestaurantDishSumAggregateOutputType | null
    _min: RestaurantDishMinAggregateOutputType | null
    _max: RestaurantDishMaxAggregateOutputType | null
  }

  type GetRestaurantDishGroupByPayload<T extends RestaurantDishGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantDishGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantDishGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantDishGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantDishGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantDishSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    image?: boolean
    isActive?: boolean
    order?: boolean
    category?: boolean | RestaurantCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantDish"]>

  export type RestaurantDishSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    image?: boolean
    isActive?: boolean
    order?: boolean
    category?: boolean | RestaurantCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantDish"]>

  export type RestaurantDishSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    image?: boolean
    isActive?: boolean
    order?: boolean
    category?: boolean | RestaurantCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantDish"]>

  export type RestaurantDishSelectScalar = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    image?: boolean
    isActive?: boolean
    order?: boolean
  }

  export type RestaurantDishOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "name" | "description" | "price" | "image" | "isActive" | "order", ExtArgs["result"]["restaurantDish"]>
  export type RestaurantDishInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | RestaurantCategoryDefaultArgs<ExtArgs>
  }
  export type RestaurantDishIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | RestaurantCategoryDefaultArgs<ExtArgs>
  }
  export type RestaurantDishIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | RestaurantCategoryDefaultArgs<ExtArgs>
  }

  export type $RestaurantDishPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RestaurantDish"
    objects: {
      category: Prisma.$RestaurantCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      name: string
      description: string | null
      price: number
      image: string | null
      isActive: boolean
      order: number
    }, ExtArgs["result"]["restaurantDish"]>
    composites: {}
  }

  type RestaurantDishGetPayload<S extends boolean | null | undefined | RestaurantDishDefaultArgs> = $Result.GetResult<Prisma.$RestaurantDishPayload, S>

  type RestaurantDishCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestaurantDishFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RestaurantDishCountAggregateInputType | true
    }

  export interface RestaurantDishDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RestaurantDish'], meta: { name: 'RestaurantDish' } }
    /**
     * Find zero or one RestaurantDish that matches the filter.
     * @param {RestaurantDishFindUniqueArgs} args - Arguments to find a RestaurantDish
     * @example
     * // Get one RestaurantDish
     * const restaurantDish = await prisma.restaurantDish.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantDishFindUniqueArgs>(args: SelectSubset<T, RestaurantDishFindUniqueArgs<ExtArgs>>): Prisma__RestaurantDishClient<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RestaurantDish that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestaurantDishFindUniqueOrThrowArgs} args - Arguments to find a RestaurantDish
     * @example
     * // Get one RestaurantDish
     * const restaurantDish = await prisma.restaurantDish.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantDishFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantDishFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantDishClient<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantDish that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantDishFindFirstArgs} args - Arguments to find a RestaurantDish
     * @example
     * // Get one RestaurantDish
     * const restaurantDish = await prisma.restaurantDish.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantDishFindFirstArgs>(args?: SelectSubset<T, RestaurantDishFindFirstArgs<ExtArgs>>): Prisma__RestaurantDishClient<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantDish that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantDishFindFirstOrThrowArgs} args - Arguments to find a RestaurantDish
     * @example
     * // Get one RestaurantDish
     * const restaurantDish = await prisma.restaurantDish.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantDishFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantDishFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantDishClient<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RestaurantDishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantDishFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestaurantDishes
     * const restaurantDishes = await prisma.restaurantDish.findMany()
     * 
     * // Get first 10 RestaurantDishes
     * const restaurantDishes = await prisma.restaurantDish.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantDishWithIdOnly = await prisma.restaurantDish.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantDishFindManyArgs>(args?: SelectSubset<T, RestaurantDishFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RestaurantDish.
     * @param {RestaurantDishCreateArgs} args - Arguments to create a RestaurantDish.
     * @example
     * // Create one RestaurantDish
     * const RestaurantDish = await prisma.restaurantDish.create({
     *   data: {
     *     // ... data to create a RestaurantDish
     *   }
     * })
     * 
     */
    create<T extends RestaurantDishCreateArgs>(args: SelectSubset<T, RestaurantDishCreateArgs<ExtArgs>>): Prisma__RestaurantDishClient<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RestaurantDishes.
     * @param {RestaurantDishCreateManyArgs} args - Arguments to create many RestaurantDishes.
     * @example
     * // Create many RestaurantDishes
     * const restaurantDish = await prisma.restaurantDish.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantDishCreateManyArgs>(args?: SelectSubset<T, RestaurantDishCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RestaurantDishes and returns the data saved in the database.
     * @param {RestaurantDishCreateManyAndReturnArgs} args - Arguments to create many RestaurantDishes.
     * @example
     * // Create many RestaurantDishes
     * const restaurantDish = await prisma.restaurantDish.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RestaurantDishes and only return the `id`
     * const restaurantDishWithIdOnly = await prisma.restaurantDish.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestaurantDishCreateManyAndReturnArgs>(args?: SelectSubset<T, RestaurantDishCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RestaurantDish.
     * @param {RestaurantDishDeleteArgs} args - Arguments to delete one RestaurantDish.
     * @example
     * // Delete one RestaurantDish
     * const RestaurantDish = await prisma.restaurantDish.delete({
     *   where: {
     *     // ... filter to delete one RestaurantDish
     *   }
     * })
     * 
     */
    delete<T extends RestaurantDishDeleteArgs>(args: SelectSubset<T, RestaurantDishDeleteArgs<ExtArgs>>): Prisma__RestaurantDishClient<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RestaurantDish.
     * @param {RestaurantDishUpdateArgs} args - Arguments to update one RestaurantDish.
     * @example
     * // Update one RestaurantDish
     * const restaurantDish = await prisma.restaurantDish.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantDishUpdateArgs>(args: SelectSubset<T, RestaurantDishUpdateArgs<ExtArgs>>): Prisma__RestaurantDishClient<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RestaurantDishes.
     * @param {RestaurantDishDeleteManyArgs} args - Arguments to filter RestaurantDishes to delete.
     * @example
     * // Delete a few RestaurantDishes
     * const { count } = await prisma.restaurantDish.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantDishDeleteManyArgs>(args?: SelectSubset<T, RestaurantDishDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantDishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantDishUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestaurantDishes
     * const restaurantDish = await prisma.restaurantDish.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantDishUpdateManyArgs>(args: SelectSubset<T, RestaurantDishUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantDishes and returns the data updated in the database.
     * @param {RestaurantDishUpdateManyAndReturnArgs} args - Arguments to update many RestaurantDishes.
     * @example
     * // Update many RestaurantDishes
     * const restaurantDish = await prisma.restaurantDish.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RestaurantDishes and only return the `id`
     * const restaurantDishWithIdOnly = await prisma.restaurantDish.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RestaurantDishUpdateManyAndReturnArgs>(args: SelectSubset<T, RestaurantDishUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RestaurantDish.
     * @param {RestaurantDishUpsertArgs} args - Arguments to update or create a RestaurantDish.
     * @example
     * // Update or create a RestaurantDish
     * const restaurantDish = await prisma.restaurantDish.upsert({
     *   create: {
     *     // ... data to create a RestaurantDish
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestaurantDish we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantDishUpsertArgs>(args: SelectSubset<T, RestaurantDishUpsertArgs<ExtArgs>>): Prisma__RestaurantDishClient<$Result.GetResult<Prisma.$RestaurantDishPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RestaurantDishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantDishCountArgs} args - Arguments to filter RestaurantDishes to count.
     * @example
     * // Count the number of RestaurantDishes
     * const count = await prisma.restaurantDish.count({
     *   where: {
     *     // ... the filter for the RestaurantDishes we want to count
     *   }
     * })
    **/
    count<T extends RestaurantDishCountArgs>(
      args?: Subset<T, RestaurantDishCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantDishCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RestaurantDish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantDishAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantDishAggregateArgs>(args: Subset<T, RestaurantDishAggregateArgs>): Prisma.PrismaPromise<GetRestaurantDishAggregateType<T>>

    /**
     * Group by RestaurantDish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantDishGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantDishGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantDishGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantDishGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantDishGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantDishGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RestaurantDish model
   */
  readonly fields: RestaurantDishFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestaurantDish.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantDishClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends RestaurantCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantCategoryDefaultArgs<ExtArgs>>): Prisma__RestaurantCategoryClient<$Result.GetResult<Prisma.$RestaurantCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RestaurantDish model
   */
  interface RestaurantDishFieldRefs {
    readonly id: FieldRef<"RestaurantDish", 'String'>
    readonly categoryId: FieldRef<"RestaurantDish", 'String'>
    readonly name: FieldRef<"RestaurantDish", 'String'>
    readonly description: FieldRef<"RestaurantDish", 'String'>
    readonly price: FieldRef<"RestaurantDish", 'Float'>
    readonly image: FieldRef<"RestaurantDish", 'String'>
    readonly isActive: FieldRef<"RestaurantDish", 'Boolean'>
    readonly order: FieldRef<"RestaurantDish", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RestaurantDish findUnique
   */
  export type RestaurantDishFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantDish to fetch.
     */
    where: RestaurantDishWhereUniqueInput
  }

  /**
   * RestaurantDish findUniqueOrThrow
   */
  export type RestaurantDishFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantDish to fetch.
     */
    where: RestaurantDishWhereUniqueInput
  }

  /**
   * RestaurantDish findFirst
   */
  export type RestaurantDishFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantDish to fetch.
     */
    where?: RestaurantDishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantDishes to fetch.
     */
    orderBy?: RestaurantDishOrderByWithRelationInput | RestaurantDishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantDishes.
     */
    cursor?: RestaurantDishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantDishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantDishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantDishes.
     */
    distinct?: RestaurantDishScalarFieldEnum | RestaurantDishScalarFieldEnum[]
  }

  /**
   * RestaurantDish findFirstOrThrow
   */
  export type RestaurantDishFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantDish to fetch.
     */
    where?: RestaurantDishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantDishes to fetch.
     */
    orderBy?: RestaurantDishOrderByWithRelationInput | RestaurantDishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantDishes.
     */
    cursor?: RestaurantDishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantDishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantDishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantDishes.
     */
    distinct?: RestaurantDishScalarFieldEnum | RestaurantDishScalarFieldEnum[]
  }

  /**
   * RestaurantDish findMany
   */
  export type RestaurantDishFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantDishes to fetch.
     */
    where?: RestaurantDishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantDishes to fetch.
     */
    orderBy?: RestaurantDishOrderByWithRelationInput | RestaurantDishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RestaurantDishes.
     */
    cursor?: RestaurantDishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantDishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantDishes.
     */
    skip?: number
    distinct?: RestaurantDishScalarFieldEnum | RestaurantDishScalarFieldEnum[]
  }

  /**
   * RestaurantDish create
   */
  export type RestaurantDishCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishInclude<ExtArgs> | null
    /**
     * The data needed to create a RestaurantDish.
     */
    data: XOR<RestaurantDishCreateInput, RestaurantDishUncheckedCreateInput>
  }

  /**
   * RestaurantDish createMany
   */
  export type RestaurantDishCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RestaurantDishes.
     */
    data: RestaurantDishCreateManyInput | RestaurantDishCreateManyInput[]
  }

  /**
   * RestaurantDish createManyAndReturn
   */
  export type RestaurantDishCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * The data used to create many RestaurantDishes.
     */
    data: RestaurantDishCreateManyInput | RestaurantDishCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantDish update
   */
  export type RestaurantDishUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishInclude<ExtArgs> | null
    /**
     * The data needed to update a RestaurantDish.
     */
    data: XOR<RestaurantDishUpdateInput, RestaurantDishUncheckedUpdateInput>
    /**
     * Choose, which RestaurantDish to update.
     */
    where: RestaurantDishWhereUniqueInput
  }

  /**
   * RestaurantDish updateMany
   */
  export type RestaurantDishUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RestaurantDishes.
     */
    data: XOR<RestaurantDishUpdateManyMutationInput, RestaurantDishUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantDishes to update
     */
    where?: RestaurantDishWhereInput
    /**
     * Limit how many RestaurantDishes to update.
     */
    limit?: number
  }

  /**
   * RestaurantDish updateManyAndReturn
   */
  export type RestaurantDishUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * The data used to update RestaurantDishes.
     */
    data: XOR<RestaurantDishUpdateManyMutationInput, RestaurantDishUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantDishes to update
     */
    where?: RestaurantDishWhereInput
    /**
     * Limit how many RestaurantDishes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantDish upsert
   */
  export type RestaurantDishUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishInclude<ExtArgs> | null
    /**
     * The filter to search for the RestaurantDish to update in case it exists.
     */
    where: RestaurantDishWhereUniqueInput
    /**
     * In case the RestaurantDish found by the `where` argument doesn't exist, create a new RestaurantDish with this data.
     */
    create: XOR<RestaurantDishCreateInput, RestaurantDishUncheckedCreateInput>
    /**
     * In case the RestaurantDish was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantDishUpdateInput, RestaurantDishUncheckedUpdateInput>
  }

  /**
   * RestaurantDish delete
   */
  export type RestaurantDishDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishInclude<ExtArgs> | null
    /**
     * Filter which RestaurantDish to delete.
     */
    where: RestaurantDishWhereUniqueInput
  }

  /**
   * RestaurantDish deleteMany
   */
  export type RestaurantDishDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantDishes to delete
     */
    where?: RestaurantDishWhereInput
    /**
     * Limit how many RestaurantDishes to delete.
     */
    limit?: number
  }

  /**
   * RestaurantDish without action
   */
  export type RestaurantDishDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantDish
     */
    select?: RestaurantDishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantDish
     */
    omit?: RestaurantDishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantDishInclude<ExtArgs> | null
  }


  /**
   * Model RestaurantTable
   */

  export type AggregateRestaurantTable = {
    _count: RestaurantTableCountAggregateOutputType | null
    _avg: RestaurantTableAvgAggregateOutputType | null
    _sum: RestaurantTableSumAggregateOutputType | null
    _min: RestaurantTableMinAggregateOutputType | null
    _max: RestaurantTableMaxAggregateOutputType | null
  }

  export type RestaurantTableAvgAggregateOutputType = {
    capacity: number | null
  }

  export type RestaurantTableSumAggregateOutputType = {
    capacity: number | null
  }

  export type RestaurantTableMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    number: string | null
    capacity: number | null
    isActive: boolean | null
    waiterId: string | null
  }

  export type RestaurantTableMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    number: string | null
    capacity: number | null
    isActive: boolean | null
    waiterId: string | null
  }

  export type RestaurantTableCountAggregateOutputType = {
    id: number
    tenantId: number
    number: number
    capacity: number
    isActive: number
    waiterId: number
    _all: number
  }


  export type RestaurantTableAvgAggregateInputType = {
    capacity?: true
  }

  export type RestaurantTableSumAggregateInputType = {
    capacity?: true
  }

  export type RestaurantTableMinAggregateInputType = {
    id?: true
    tenantId?: true
    number?: true
    capacity?: true
    isActive?: true
    waiterId?: true
  }

  export type RestaurantTableMaxAggregateInputType = {
    id?: true
    tenantId?: true
    number?: true
    capacity?: true
    isActive?: true
    waiterId?: true
  }

  export type RestaurantTableCountAggregateInputType = {
    id?: true
    tenantId?: true
    number?: true
    capacity?: true
    isActive?: true
    waiterId?: true
    _all?: true
  }

  export type RestaurantTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantTable to aggregate.
     */
    where?: RestaurantTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantTables to fetch.
     */
    orderBy?: RestaurantTableOrderByWithRelationInput | RestaurantTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RestaurantTables
    **/
    _count?: true | RestaurantTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestaurantTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestaurantTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantTableMaxAggregateInputType
  }

  export type GetRestaurantTableAggregateType<T extends RestaurantTableAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurantTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurantTable[P]>
      : GetScalarType<T[P], AggregateRestaurantTable[P]>
  }




  export type RestaurantTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantTableWhereInput
    orderBy?: RestaurantTableOrderByWithAggregationInput | RestaurantTableOrderByWithAggregationInput[]
    by: RestaurantTableScalarFieldEnum[] | RestaurantTableScalarFieldEnum
    having?: RestaurantTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantTableCountAggregateInputType | true
    _avg?: RestaurantTableAvgAggregateInputType
    _sum?: RestaurantTableSumAggregateInputType
    _min?: RestaurantTableMinAggregateInputType
    _max?: RestaurantTableMaxAggregateInputType
  }

  export type RestaurantTableGroupByOutputType = {
    id: string
    tenantId: string
    number: string
    capacity: number | null
    isActive: boolean
    waiterId: string | null
    _count: RestaurantTableCountAggregateOutputType | null
    _avg: RestaurantTableAvgAggregateOutputType | null
    _sum: RestaurantTableSumAggregateOutputType | null
    _min: RestaurantTableMinAggregateOutputType | null
    _max: RestaurantTableMaxAggregateOutputType | null
  }

  type GetRestaurantTableGroupByPayload<T extends RestaurantTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantTableGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantTableGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    number?: boolean
    capacity?: boolean
    isActive?: boolean
    waiterId?: boolean
    orders?: boolean | RestaurantTable$ordersArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    waiter?: boolean | RestaurantTable$waiterArgs<ExtArgs>
    _count?: boolean | RestaurantTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantTable"]>

  export type RestaurantTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    number?: boolean
    capacity?: boolean
    isActive?: boolean
    waiterId?: boolean
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    waiter?: boolean | RestaurantTable$waiterArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantTable"]>

  export type RestaurantTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    number?: boolean
    capacity?: boolean
    isActive?: boolean
    waiterId?: boolean
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    waiter?: boolean | RestaurantTable$waiterArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantTable"]>

  export type RestaurantTableSelectScalar = {
    id?: boolean
    tenantId?: boolean
    number?: boolean
    capacity?: boolean
    isActive?: boolean
    waiterId?: boolean
  }

  export type RestaurantTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "number" | "capacity" | "isActive" | "waiterId", ExtArgs["result"]["restaurantTable"]>
  export type RestaurantTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | RestaurantTable$ordersArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    waiter?: boolean | RestaurantTable$waiterArgs<ExtArgs>
    _count?: boolean | RestaurantTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RestaurantTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    waiter?: boolean | RestaurantTable$waiterArgs<ExtArgs>
  }
  export type RestaurantTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    waiter?: boolean | RestaurantTable$waiterArgs<ExtArgs>
  }

  export type $RestaurantTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RestaurantTable"
    objects: {
      orders: Prisma.$RestaurantOrderPayload<ExtArgs>[]
      tenant: Prisma.$TenantWebsitePayload<ExtArgs>
      waiter: Prisma.$RestaurantWaiterPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      number: string
      capacity: number | null
      isActive: boolean
      waiterId: string | null
    }, ExtArgs["result"]["restaurantTable"]>
    composites: {}
  }

  type RestaurantTableGetPayload<S extends boolean | null | undefined | RestaurantTableDefaultArgs> = $Result.GetResult<Prisma.$RestaurantTablePayload, S>

  type RestaurantTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestaurantTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RestaurantTableCountAggregateInputType | true
    }

  export interface RestaurantTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RestaurantTable'], meta: { name: 'RestaurantTable' } }
    /**
     * Find zero or one RestaurantTable that matches the filter.
     * @param {RestaurantTableFindUniqueArgs} args - Arguments to find a RestaurantTable
     * @example
     * // Get one RestaurantTable
     * const restaurantTable = await prisma.restaurantTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantTableFindUniqueArgs>(args: SelectSubset<T, RestaurantTableFindUniqueArgs<ExtArgs>>): Prisma__RestaurantTableClient<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RestaurantTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestaurantTableFindUniqueOrThrowArgs} args - Arguments to find a RestaurantTable
     * @example
     * // Get one RestaurantTable
     * const restaurantTable = await prisma.restaurantTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantTableFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantTableClient<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantTableFindFirstArgs} args - Arguments to find a RestaurantTable
     * @example
     * // Get one RestaurantTable
     * const restaurantTable = await prisma.restaurantTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantTableFindFirstArgs>(args?: SelectSubset<T, RestaurantTableFindFirstArgs<ExtArgs>>): Prisma__RestaurantTableClient<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantTableFindFirstOrThrowArgs} args - Arguments to find a RestaurantTable
     * @example
     * // Get one RestaurantTable
     * const restaurantTable = await prisma.restaurantTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantTableFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantTableClient<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RestaurantTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestaurantTables
     * const restaurantTables = await prisma.restaurantTable.findMany()
     * 
     * // Get first 10 RestaurantTables
     * const restaurantTables = await prisma.restaurantTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantTableWithIdOnly = await prisma.restaurantTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantTableFindManyArgs>(args?: SelectSubset<T, RestaurantTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RestaurantTable.
     * @param {RestaurantTableCreateArgs} args - Arguments to create a RestaurantTable.
     * @example
     * // Create one RestaurantTable
     * const RestaurantTable = await prisma.restaurantTable.create({
     *   data: {
     *     // ... data to create a RestaurantTable
     *   }
     * })
     * 
     */
    create<T extends RestaurantTableCreateArgs>(args: SelectSubset<T, RestaurantTableCreateArgs<ExtArgs>>): Prisma__RestaurantTableClient<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RestaurantTables.
     * @param {RestaurantTableCreateManyArgs} args - Arguments to create many RestaurantTables.
     * @example
     * // Create many RestaurantTables
     * const restaurantTable = await prisma.restaurantTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantTableCreateManyArgs>(args?: SelectSubset<T, RestaurantTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RestaurantTables and returns the data saved in the database.
     * @param {RestaurantTableCreateManyAndReturnArgs} args - Arguments to create many RestaurantTables.
     * @example
     * // Create many RestaurantTables
     * const restaurantTable = await prisma.restaurantTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RestaurantTables and only return the `id`
     * const restaurantTableWithIdOnly = await prisma.restaurantTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestaurantTableCreateManyAndReturnArgs>(args?: SelectSubset<T, RestaurantTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RestaurantTable.
     * @param {RestaurantTableDeleteArgs} args - Arguments to delete one RestaurantTable.
     * @example
     * // Delete one RestaurantTable
     * const RestaurantTable = await prisma.restaurantTable.delete({
     *   where: {
     *     // ... filter to delete one RestaurantTable
     *   }
     * })
     * 
     */
    delete<T extends RestaurantTableDeleteArgs>(args: SelectSubset<T, RestaurantTableDeleteArgs<ExtArgs>>): Prisma__RestaurantTableClient<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RestaurantTable.
     * @param {RestaurantTableUpdateArgs} args - Arguments to update one RestaurantTable.
     * @example
     * // Update one RestaurantTable
     * const restaurantTable = await prisma.restaurantTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantTableUpdateArgs>(args: SelectSubset<T, RestaurantTableUpdateArgs<ExtArgs>>): Prisma__RestaurantTableClient<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RestaurantTables.
     * @param {RestaurantTableDeleteManyArgs} args - Arguments to filter RestaurantTables to delete.
     * @example
     * // Delete a few RestaurantTables
     * const { count } = await prisma.restaurantTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantTableDeleteManyArgs>(args?: SelectSubset<T, RestaurantTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestaurantTables
     * const restaurantTable = await prisma.restaurantTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantTableUpdateManyArgs>(args: SelectSubset<T, RestaurantTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantTables and returns the data updated in the database.
     * @param {RestaurantTableUpdateManyAndReturnArgs} args - Arguments to update many RestaurantTables.
     * @example
     * // Update many RestaurantTables
     * const restaurantTable = await prisma.restaurantTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RestaurantTables and only return the `id`
     * const restaurantTableWithIdOnly = await prisma.restaurantTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RestaurantTableUpdateManyAndReturnArgs>(args: SelectSubset<T, RestaurantTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RestaurantTable.
     * @param {RestaurantTableUpsertArgs} args - Arguments to update or create a RestaurantTable.
     * @example
     * // Update or create a RestaurantTable
     * const restaurantTable = await prisma.restaurantTable.upsert({
     *   create: {
     *     // ... data to create a RestaurantTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestaurantTable we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantTableUpsertArgs>(args: SelectSubset<T, RestaurantTableUpsertArgs<ExtArgs>>): Prisma__RestaurantTableClient<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RestaurantTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantTableCountArgs} args - Arguments to filter RestaurantTables to count.
     * @example
     * // Count the number of RestaurantTables
     * const count = await prisma.restaurantTable.count({
     *   where: {
     *     // ... the filter for the RestaurantTables we want to count
     *   }
     * })
    **/
    count<T extends RestaurantTableCountArgs>(
      args?: Subset<T, RestaurantTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RestaurantTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantTableAggregateArgs>(args: Subset<T, RestaurantTableAggregateArgs>): Prisma.PrismaPromise<GetRestaurantTableAggregateType<T>>

    /**
     * Group by RestaurantTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantTableGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RestaurantTable model
   */
  readonly fields: RestaurantTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestaurantTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends RestaurantTable$ordersArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantTable$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantWebsiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsiteDefaultArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    waiter<T extends RestaurantTable$waiterArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantTable$waiterArgs<ExtArgs>>): Prisma__RestaurantWaiterClient<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RestaurantTable model
   */
  interface RestaurantTableFieldRefs {
    readonly id: FieldRef<"RestaurantTable", 'String'>
    readonly tenantId: FieldRef<"RestaurantTable", 'String'>
    readonly number: FieldRef<"RestaurantTable", 'String'>
    readonly capacity: FieldRef<"RestaurantTable", 'Int'>
    readonly isActive: FieldRef<"RestaurantTable", 'Boolean'>
    readonly waiterId: FieldRef<"RestaurantTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RestaurantTable findUnique
   */
  export type RestaurantTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantTable to fetch.
     */
    where: RestaurantTableWhereUniqueInput
  }

  /**
   * RestaurantTable findUniqueOrThrow
   */
  export type RestaurantTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantTable to fetch.
     */
    where: RestaurantTableWhereUniqueInput
  }

  /**
   * RestaurantTable findFirst
   */
  export type RestaurantTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantTable to fetch.
     */
    where?: RestaurantTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantTables to fetch.
     */
    orderBy?: RestaurantTableOrderByWithRelationInput | RestaurantTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantTables.
     */
    cursor?: RestaurantTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantTables.
     */
    distinct?: RestaurantTableScalarFieldEnum | RestaurantTableScalarFieldEnum[]
  }

  /**
   * RestaurantTable findFirstOrThrow
   */
  export type RestaurantTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantTable to fetch.
     */
    where?: RestaurantTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantTables to fetch.
     */
    orderBy?: RestaurantTableOrderByWithRelationInput | RestaurantTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantTables.
     */
    cursor?: RestaurantTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantTables.
     */
    distinct?: RestaurantTableScalarFieldEnum | RestaurantTableScalarFieldEnum[]
  }

  /**
   * RestaurantTable findMany
   */
  export type RestaurantTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantTables to fetch.
     */
    where?: RestaurantTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantTables to fetch.
     */
    orderBy?: RestaurantTableOrderByWithRelationInput | RestaurantTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RestaurantTables.
     */
    cursor?: RestaurantTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantTables.
     */
    skip?: number
    distinct?: RestaurantTableScalarFieldEnum | RestaurantTableScalarFieldEnum[]
  }

  /**
   * RestaurantTable create
   */
  export type RestaurantTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
    /**
     * The data needed to create a RestaurantTable.
     */
    data: XOR<RestaurantTableCreateInput, RestaurantTableUncheckedCreateInput>
  }

  /**
   * RestaurantTable createMany
   */
  export type RestaurantTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RestaurantTables.
     */
    data: RestaurantTableCreateManyInput | RestaurantTableCreateManyInput[]
  }

  /**
   * RestaurantTable createManyAndReturn
   */
  export type RestaurantTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * The data used to create many RestaurantTables.
     */
    data: RestaurantTableCreateManyInput | RestaurantTableCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantTable update
   */
  export type RestaurantTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
    /**
     * The data needed to update a RestaurantTable.
     */
    data: XOR<RestaurantTableUpdateInput, RestaurantTableUncheckedUpdateInput>
    /**
     * Choose, which RestaurantTable to update.
     */
    where: RestaurantTableWhereUniqueInput
  }

  /**
   * RestaurantTable updateMany
   */
  export type RestaurantTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RestaurantTables.
     */
    data: XOR<RestaurantTableUpdateManyMutationInput, RestaurantTableUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantTables to update
     */
    where?: RestaurantTableWhereInput
    /**
     * Limit how many RestaurantTables to update.
     */
    limit?: number
  }

  /**
   * RestaurantTable updateManyAndReturn
   */
  export type RestaurantTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * The data used to update RestaurantTables.
     */
    data: XOR<RestaurantTableUpdateManyMutationInput, RestaurantTableUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantTables to update
     */
    where?: RestaurantTableWhereInput
    /**
     * Limit how many RestaurantTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantTable upsert
   */
  export type RestaurantTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
    /**
     * The filter to search for the RestaurantTable to update in case it exists.
     */
    where: RestaurantTableWhereUniqueInput
    /**
     * In case the RestaurantTable found by the `where` argument doesn't exist, create a new RestaurantTable with this data.
     */
    create: XOR<RestaurantTableCreateInput, RestaurantTableUncheckedCreateInput>
    /**
     * In case the RestaurantTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantTableUpdateInput, RestaurantTableUncheckedUpdateInput>
  }

  /**
   * RestaurantTable delete
   */
  export type RestaurantTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
    /**
     * Filter which RestaurantTable to delete.
     */
    where: RestaurantTableWhereUniqueInput
  }

  /**
   * RestaurantTable deleteMany
   */
  export type RestaurantTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantTables to delete
     */
    where?: RestaurantTableWhereInput
    /**
     * Limit how many RestaurantTables to delete.
     */
    limit?: number
  }

  /**
   * RestaurantTable.orders
   */
  export type RestaurantTable$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderInclude<ExtArgs> | null
    where?: RestaurantOrderWhereInput
    orderBy?: RestaurantOrderOrderByWithRelationInput | RestaurantOrderOrderByWithRelationInput[]
    cursor?: RestaurantOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantOrderScalarFieldEnum | RestaurantOrderScalarFieldEnum[]
  }

  /**
   * RestaurantTable.waiter
   */
  export type RestaurantTable$waiterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
    where?: RestaurantWaiterWhereInput
  }

  /**
   * RestaurantTable without action
   */
  export type RestaurantTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
  }


  /**
   * Model RestaurantWaiter
   */

  export type AggregateRestaurantWaiter = {
    _count: RestaurantWaiterCountAggregateOutputType | null
    _min: RestaurantWaiterMinAggregateOutputType | null
    _max: RestaurantWaiterMaxAggregateOutputType | null
  }

  export type RestaurantWaiterMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    pin: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type RestaurantWaiterMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    pin: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type RestaurantWaiterCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    pin: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type RestaurantWaiterMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    pin?: true
    isActive?: true
    createdAt?: true
  }

  export type RestaurantWaiterMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    pin?: true
    isActive?: true
    createdAt?: true
  }

  export type RestaurantWaiterCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    pin?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type RestaurantWaiterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantWaiter to aggregate.
     */
    where?: RestaurantWaiterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantWaiters to fetch.
     */
    orderBy?: RestaurantWaiterOrderByWithRelationInput | RestaurantWaiterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantWaiterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantWaiters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantWaiters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RestaurantWaiters
    **/
    _count?: true | RestaurantWaiterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantWaiterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantWaiterMaxAggregateInputType
  }

  export type GetRestaurantWaiterAggregateType<T extends RestaurantWaiterAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurantWaiter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurantWaiter[P]>
      : GetScalarType<T[P], AggregateRestaurantWaiter[P]>
  }




  export type RestaurantWaiterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWaiterWhereInput
    orderBy?: RestaurantWaiterOrderByWithAggregationInput | RestaurantWaiterOrderByWithAggregationInput[]
    by: RestaurantWaiterScalarFieldEnum[] | RestaurantWaiterScalarFieldEnum
    having?: RestaurantWaiterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantWaiterCountAggregateInputType | true
    _min?: RestaurantWaiterMinAggregateInputType
    _max?: RestaurantWaiterMaxAggregateInputType
  }

  export type RestaurantWaiterGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    pin: string
    isActive: boolean
    createdAt: Date
    _count: RestaurantWaiterCountAggregateOutputType | null
    _min: RestaurantWaiterMinAggregateOutputType | null
    _max: RestaurantWaiterMaxAggregateOutputType | null
  }

  type GetRestaurantWaiterGroupByPayload<T extends RestaurantWaiterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantWaiterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantWaiterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantWaiterGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantWaiterGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantWaiterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    pin?: boolean
    isActive?: boolean
    createdAt?: boolean
    tables?: boolean | RestaurantWaiter$tablesArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    _count?: boolean | RestaurantWaiterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantWaiter"]>

  export type RestaurantWaiterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    pin?: boolean
    isActive?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantWaiter"]>

  export type RestaurantWaiterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    pin?: boolean
    isActive?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantWaiter"]>

  export type RestaurantWaiterSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    pin?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type RestaurantWaiterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "pin" | "isActive" | "createdAt", ExtArgs["result"]["restaurantWaiter"]>
  export type RestaurantWaiterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | RestaurantWaiter$tablesArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    _count?: boolean | RestaurantWaiterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RestaurantWaiterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type RestaurantWaiterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }

  export type $RestaurantWaiterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RestaurantWaiter"
    objects: {
      tables: Prisma.$RestaurantTablePayload<ExtArgs>[]
      tenant: Prisma.$TenantWebsitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      pin: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["restaurantWaiter"]>
    composites: {}
  }

  type RestaurantWaiterGetPayload<S extends boolean | null | undefined | RestaurantWaiterDefaultArgs> = $Result.GetResult<Prisma.$RestaurantWaiterPayload, S>

  type RestaurantWaiterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestaurantWaiterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RestaurantWaiterCountAggregateInputType | true
    }

  export interface RestaurantWaiterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RestaurantWaiter'], meta: { name: 'RestaurantWaiter' } }
    /**
     * Find zero or one RestaurantWaiter that matches the filter.
     * @param {RestaurantWaiterFindUniqueArgs} args - Arguments to find a RestaurantWaiter
     * @example
     * // Get one RestaurantWaiter
     * const restaurantWaiter = await prisma.restaurantWaiter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantWaiterFindUniqueArgs>(args: SelectSubset<T, RestaurantWaiterFindUniqueArgs<ExtArgs>>): Prisma__RestaurantWaiterClient<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RestaurantWaiter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestaurantWaiterFindUniqueOrThrowArgs} args - Arguments to find a RestaurantWaiter
     * @example
     * // Get one RestaurantWaiter
     * const restaurantWaiter = await prisma.restaurantWaiter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantWaiterFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantWaiterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantWaiterClient<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantWaiter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaiterFindFirstArgs} args - Arguments to find a RestaurantWaiter
     * @example
     * // Get one RestaurantWaiter
     * const restaurantWaiter = await prisma.restaurantWaiter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantWaiterFindFirstArgs>(args?: SelectSubset<T, RestaurantWaiterFindFirstArgs<ExtArgs>>): Prisma__RestaurantWaiterClient<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantWaiter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaiterFindFirstOrThrowArgs} args - Arguments to find a RestaurantWaiter
     * @example
     * // Get one RestaurantWaiter
     * const restaurantWaiter = await prisma.restaurantWaiter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantWaiterFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantWaiterFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantWaiterClient<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RestaurantWaiters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaiterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestaurantWaiters
     * const restaurantWaiters = await prisma.restaurantWaiter.findMany()
     * 
     * // Get first 10 RestaurantWaiters
     * const restaurantWaiters = await prisma.restaurantWaiter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantWaiterWithIdOnly = await prisma.restaurantWaiter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantWaiterFindManyArgs>(args?: SelectSubset<T, RestaurantWaiterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RestaurantWaiter.
     * @param {RestaurantWaiterCreateArgs} args - Arguments to create a RestaurantWaiter.
     * @example
     * // Create one RestaurantWaiter
     * const RestaurantWaiter = await prisma.restaurantWaiter.create({
     *   data: {
     *     // ... data to create a RestaurantWaiter
     *   }
     * })
     * 
     */
    create<T extends RestaurantWaiterCreateArgs>(args: SelectSubset<T, RestaurantWaiterCreateArgs<ExtArgs>>): Prisma__RestaurantWaiterClient<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RestaurantWaiters.
     * @param {RestaurantWaiterCreateManyArgs} args - Arguments to create many RestaurantWaiters.
     * @example
     * // Create many RestaurantWaiters
     * const restaurantWaiter = await prisma.restaurantWaiter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantWaiterCreateManyArgs>(args?: SelectSubset<T, RestaurantWaiterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RestaurantWaiters and returns the data saved in the database.
     * @param {RestaurantWaiterCreateManyAndReturnArgs} args - Arguments to create many RestaurantWaiters.
     * @example
     * // Create many RestaurantWaiters
     * const restaurantWaiter = await prisma.restaurantWaiter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RestaurantWaiters and only return the `id`
     * const restaurantWaiterWithIdOnly = await prisma.restaurantWaiter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestaurantWaiterCreateManyAndReturnArgs>(args?: SelectSubset<T, RestaurantWaiterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RestaurantWaiter.
     * @param {RestaurantWaiterDeleteArgs} args - Arguments to delete one RestaurantWaiter.
     * @example
     * // Delete one RestaurantWaiter
     * const RestaurantWaiter = await prisma.restaurantWaiter.delete({
     *   where: {
     *     // ... filter to delete one RestaurantWaiter
     *   }
     * })
     * 
     */
    delete<T extends RestaurantWaiterDeleteArgs>(args: SelectSubset<T, RestaurantWaiterDeleteArgs<ExtArgs>>): Prisma__RestaurantWaiterClient<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RestaurantWaiter.
     * @param {RestaurantWaiterUpdateArgs} args - Arguments to update one RestaurantWaiter.
     * @example
     * // Update one RestaurantWaiter
     * const restaurantWaiter = await prisma.restaurantWaiter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantWaiterUpdateArgs>(args: SelectSubset<T, RestaurantWaiterUpdateArgs<ExtArgs>>): Prisma__RestaurantWaiterClient<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RestaurantWaiters.
     * @param {RestaurantWaiterDeleteManyArgs} args - Arguments to filter RestaurantWaiters to delete.
     * @example
     * // Delete a few RestaurantWaiters
     * const { count } = await prisma.restaurantWaiter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantWaiterDeleteManyArgs>(args?: SelectSubset<T, RestaurantWaiterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantWaiters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaiterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestaurantWaiters
     * const restaurantWaiter = await prisma.restaurantWaiter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantWaiterUpdateManyArgs>(args: SelectSubset<T, RestaurantWaiterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantWaiters and returns the data updated in the database.
     * @param {RestaurantWaiterUpdateManyAndReturnArgs} args - Arguments to update many RestaurantWaiters.
     * @example
     * // Update many RestaurantWaiters
     * const restaurantWaiter = await prisma.restaurantWaiter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RestaurantWaiters and only return the `id`
     * const restaurantWaiterWithIdOnly = await prisma.restaurantWaiter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RestaurantWaiterUpdateManyAndReturnArgs>(args: SelectSubset<T, RestaurantWaiterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RestaurantWaiter.
     * @param {RestaurantWaiterUpsertArgs} args - Arguments to update or create a RestaurantWaiter.
     * @example
     * // Update or create a RestaurantWaiter
     * const restaurantWaiter = await prisma.restaurantWaiter.upsert({
     *   create: {
     *     // ... data to create a RestaurantWaiter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestaurantWaiter we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantWaiterUpsertArgs>(args: SelectSubset<T, RestaurantWaiterUpsertArgs<ExtArgs>>): Prisma__RestaurantWaiterClient<$Result.GetResult<Prisma.$RestaurantWaiterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RestaurantWaiters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaiterCountArgs} args - Arguments to filter RestaurantWaiters to count.
     * @example
     * // Count the number of RestaurantWaiters
     * const count = await prisma.restaurantWaiter.count({
     *   where: {
     *     // ... the filter for the RestaurantWaiters we want to count
     *   }
     * })
    **/
    count<T extends RestaurantWaiterCountArgs>(
      args?: Subset<T, RestaurantWaiterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantWaiterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RestaurantWaiter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaiterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantWaiterAggregateArgs>(args: Subset<T, RestaurantWaiterAggregateArgs>): Prisma.PrismaPromise<GetRestaurantWaiterAggregateType<T>>

    /**
     * Group by RestaurantWaiter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaiterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantWaiterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantWaiterGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantWaiterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantWaiterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantWaiterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RestaurantWaiter model
   */
  readonly fields: RestaurantWaiterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestaurantWaiter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantWaiterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tables<T extends RestaurantWaiter$tablesArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantWaiter$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantWebsiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsiteDefaultArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RestaurantWaiter model
   */
  interface RestaurantWaiterFieldRefs {
    readonly id: FieldRef<"RestaurantWaiter", 'String'>
    readonly tenantId: FieldRef<"RestaurantWaiter", 'String'>
    readonly name: FieldRef<"RestaurantWaiter", 'String'>
    readonly pin: FieldRef<"RestaurantWaiter", 'String'>
    readonly isActive: FieldRef<"RestaurantWaiter", 'Boolean'>
    readonly createdAt: FieldRef<"RestaurantWaiter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RestaurantWaiter findUnique
   */
  export type RestaurantWaiterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantWaiter to fetch.
     */
    where: RestaurantWaiterWhereUniqueInput
  }

  /**
   * RestaurantWaiter findUniqueOrThrow
   */
  export type RestaurantWaiterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantWaiter to fetch.
     */
    where: RestaurantWaiterWhereUniqueInput
  }

  /**
   * RestaurantWaiter findFirst
   */
  export type RestaurantWaiterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantWaiter to fetch.
     */
    where?: RestaurantWaiterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantWaiters to fetch.
     */
    orderBy?: RestaurantWaiterOrderByWithRelationInput | RestaurantWaiterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantWaiters.
     */
    cursor?: RestaurantWaiterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantWaiters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantWaiters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantWaiters.
     */
    distinct?: RestaurantWaiterScalarFieldEnum | RestaurantWaiterScalarFieldEnum[]
  }

  /**
   * RestaurantWaiter findFirstOrThrow
   */
  export type RestaurantWaiterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantWaiter to fetch.
     */
    where?: RestaurantWaiterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantWaiters to fetch.
     */
    orderBy?: RestaurantWaiterOrderByWithRelationInput | RestaurantWaiterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantWaiters.
     */
    cursor?: RestaurantWaiterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantWaiters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantWaiters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantWaiters.
     */
    distinct?: RestaurantWaiterScalarFieldEnum | RestaurantWaiterScalarFieldEnum[]
  }

  /**
   * RestaurantWaiter findMany
   */
  export type RestaurantWaiterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantWaiters to fetch.
     */
    where?: RestaurantWaiterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantWaiters to fetch.
     */
    orderBy?: RestaurantWaiterOrderByWithRelationInput | RestaurantWaiterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RestaurantWaiters.
     */
    cursor?: RestaurantWaiterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantWaiters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantWaiters.
     */
    skip?: number
    distinct?: RestaurantWaiterScalarFieldEnum | RestaurantWaiterScalarFieldEnum[]
  }

  /**
   * RestaurantWaiter create
   */
  export type RestaurantWaiterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
    /**
     * The data needed to create a RestaurantWaiter.
     */
    data: XOR<RestaurantWaiterCreateInput, RestaurantWaiterUncheckedCreateInput>
  }

  /**
   * RestaurantWaiter createMany
   */
  export type RestaurantWaiterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RestaurantWaiters.
     */
    data: RestaurantWaiterCreateManyInput | RestaurantWaiterCreateManyInput[]
  }

  /**
   * RestaurantWaiter createManyAndReturn
   */
  export type RestaurantWaiterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * The data used to create many RestaurantWaiters.
     */
    data: RestaurantWaiterCreateManyInput | RestaurantWaiterCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantWaiter update
   */
  export type RestaurantWaiterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
    /**
     * The data needed to update a RestaurantWaiter.
     */
    data: XOR<RestaurantWaiterUpdateInput, RestaurantWaiterUncheckedUpdateInput>
    /**
     * Choose, which RestaurantWaiter to update.
     */
    where: RestaurantWaiterWhereUniqueInput
  }

  /**
   * RestaurantWaiter updateMany
   */
  export type RestaurantWaiterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RestaurantWaiters.
     */
    data: XOR<RestaurantWaiterUpdateManyMutationInput, RestaurantWaiterUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantWaiters to update
     */
    where?: RestaurantWaiterWhereInput
    /**
     * Limit how many RestaurantWaiters to update.
     */
    limit?: number
  }

  /**
   * RestaurantWaiter updateManyAndReturn
   */
  export type RestaurantWaiterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * The data used to update RestaurantWaiters.
     */
    data: XOR<RestaurantWaiterUpdateManyMutationInput, RestaurantWaiterUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantWaiters to update
     */
    where?: RestaurantWaiterWhereInput
    /**
     * Limit how many RestaurantWaiters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantWaiter upsert
   */
  export type RestaurantWaiterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
    /**
     * The filter to search for the RestaurantWaiter to update in case it exists.
     */
    where: RestaurantWaiterWhereUniqueInput
    /**
     * In case the RestaurantWaiter found by the `where` argument doesn't exist, create a new RestaurantWaiter with this data.
     */
    create: XOR<RestaurantWaiterCreateInput, RestaurantWaiterUncheckedCreateInput>
    /**
     * In case the RestaurantWaiter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantWaiterUpdateInput, RestaurantWaiterUncheckedUpdateInput>
  }

  /**
   * RestaurantWaiter delete
   */
  export type RestaurantWaiterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
    /**
     * Filter which RestaurantWaiter to delete.
     */
    where: RestaurantWaiterWhereUniqueInput
  }

  /**
   * RestaurantWaiter deleteMany
   */
  export type RestaurantWaiterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantWaiters to delete
     */
    where?: RestaurantWaiterWhereInput
    /**
     * Limit how many RestaurantWaiters to delete.
     */
    limit?: number
  }

  /**
   * RestaurantWaiter.tables
   */
  export type RestaurantWaiter$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantTable
     */
    select?: RestaurantTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantTable
     */
    omit?: RestaurantTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantTableInclude<ExtArgs> | null
    where?: RestaurantTableWhereInput
    orderBy?: RestaurantTableOrderByWithRelationInput | RestaurantTableOrderByWithRelationInput[]
    cursor?: RestaurantTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantTableScalarFieldEnum | RestaurantTableScalarFieldEnum[]
  }

  /**
   * RestaurantWaiter without action
   */
  export type RestaurantWaiterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaiter
     */
    select?: RestaurantWaiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantWaiter
     */
    omit?: RestaurantWaiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaiterInclude<ExtArgs> | null
  }


  /**
   * Model RestaurantOrder
   */

  export type AggregateRestaurantOrder = {
    _count: RestaurantOrderCountAggregateOutputType | null
    _avg: RestaurantOrderAvgAggregateOutputType | null
    _sum: RestaurantOrderSumAggregateOutputType | null
    _min: RestaurantOrderMinAggregateOutputType | null
    _max: RestaurantOrderMaxAggregateOutputType | null
  }

  export type RestaurantOrderAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type RestaurantOrderSumAggregateOutputType = {
    totalAmount: number | null
  }

  export type RestaurantOrderMinAggregateOutputType = {
    id: string | null
    tableId: string | null
    status: string | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RestaurantOrderMaxAggregateOutputType = {
    id: string | null
    tableId: string | null
    status: string | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RestaurantOrderCountAggregateOutputType = {
    id: number
    tableId: number
    status: number
    totalAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RestaurantOrderAvgAggregateInputType = {
    totalAmount?: true
  }

  export type RestaurantOrderSumAggregateInputType = {
    totalAmount?: true
  }

  export type RestaurantOrderMinAggregateInputType = {
    id?: true
    tableId?: true
    status?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RestaurantOrderMaxAggregateInputType = {
    id?: true
    tableId?: true
    status?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RestaurantOrderCountAggregateInputType = {
    id?: true
    tableId?: true
    status?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RestaurantOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantOrder to aggregate.
     */
    where?: RestaurantOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantOrders to fetch.
     */
    orderBy?: RestaurantOrderOrderByWithRelationInput | RestaurantOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RestaurantOrders
    **/
    _count?: true | RestaurantOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestaurantOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestaurantOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantOrderMaxAggregateInputType
  }

  export type GetRestaurantOrderAggregateType<T extends RestaurantOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurantOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurantOrder[P]>
      : GetScalarType<T[P], AggregateRestaurantOrder[P]>
  }




  export type RestaurantOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantOrderWhereInput
    orderBy?: RestaurantOrderOrderByWithAggregationInput | RestaurantOrderOrderByWithAggregationInput[]
    by: RestaurantOrderScalarFieldEnum[] | RestaurantOrderScalarFieldEnum
    having?: RestaurantOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantOrderCountAggregateInputType | true
    _avg?: RestaurantOrderAvgAggregateInputType
    _sum?: RestaurantOrderSumAggregateInputType
    _min?: RestaurantOrderMinAggregateInputType
    _max?: RestaurantOrderMaxAggregateInputType
  }

  export type RestaurantOrderGroupByOutputType = {
    id: string
    tableId: string
    status: string
    totalAmount: number
    createdAt: Date
    updatedAt: Date
    _count: RestaurantOrderCountAggregateOutputType | null
    _avg: RestaurantOrderAvgAggregateOutputType | null
    _sum: RestaurantOrderSumAggregateOutputType | null
    _min: RestaurantOrderMinAggregateOutputType | null
    _max: RestaurantOrderMaxAggregateOutputType | null
  }

  type GetRestaurantOrderGroupByPayload<T extends RestaurantOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantOrderGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantOrderGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    status?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | RestaurantOrder$itemsArgs<ExtArgs>
    table?: boolean | RestaurantTableDefaultArgs<ExtArgs>
    _count?: boolean | RestaurantOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantOrder"]>

  export type RestaurantOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    status?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    table?: boolean | RestaurantTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantOrder"]>

  export type RestaurantOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    status?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    table?: boolean | RestaurantTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantOrder"]>

  export type RestaurantOrderSelectScalar = {
    id?: boolean
    tableId?: boolean
    status?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RestaurantOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableId" | "status" | "totalAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["restaurantOrder"]>
  export type RestaurantOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | RestaurantOrder$itemsArgs<ExtArgs>
    table?: boolean | RestaurantTableDefaultArgs<ExtArgs>
    _count?: boolean | RestaurantOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RestaurantOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | RestaurantTableDefaultArgs<ExtArgs>
  }
  export type RestaurantOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | RestaurantTableDefaultArgs<ExtArgs>
  }

  export type $RestaurantOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RestaurantOrder"
    objects: {
      items: Prisma.$RestaurantOrderItemPayload<ExtArgs>[]
      table: Prisma.$RestaurantTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableId: string
      status: string
      totalAmount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["restaurantOrder"]>
    composites: {}
  }

  type RestaurantOrderGetPayload<S extends boolean | null | undefined | RestaurantOrderDefaultArgs> = $Result.GetResult<Prisma.$RestaurantOrderPayload, S>

  type RestaurantOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestaurantOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RestaurantOrderCountAggregateInputType | true
    }

  export interface RestaurantOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RestaurantOrder'], meta: { name: 'RestaurantOrder' } }
    /**
     * Find zero or one RestaurantOrder that matches the filter.
     * @param {RestaurantOrderFindUniqueArgs} args - Arguments to find a RestaurantOrder
     * @example
     * // Get one RestaurantOrder
     * const restaurantOrder = await prisma.restaurantOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantOrderFindUniqueArgs>(args: SelectSubset<T, RestaurantOrderFindUniqueArgs<ExtArgs>>): Prisma__RestaurantOrderClient<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RestaurantOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestaurantOrderFindUniqueOrThrowArgs} args - Arguments to find a RestaurantOrder
     * @example
     * // Get one RestaurantOrder
     * const restaurantOrder = await prisma.restaurantOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantOrderClient<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderFindFirstArgs} args - Arguments to find a RestaurantOrder
     * @example
     * // Get one RestaurantOrder
     * const restaurantOrder = await prisma.restaurantOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantOrderFindFirstArgs>(args?: SelectSubset<T, RestaurantOrderFindFirstArgs<ExtArgs>>): Prisma__RestaurantOrderClient<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderFindFirstOrThrowArgs} args - Arguments to find a RestaurantOrder
     * @example
     * // Get one RestaurantOrder
     * const restaurantOrder = await prisma.restaurantOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantOrderClient<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RestaurantOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestaurantOrders
     * const restaurantOrders = await prisma.restaurantOrder.findMany()
     * 
     * // Get first 10 RestaurantOrders
     * const restaurantOrders = await prisma.restaurantOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantOrderWithIdOnly = await prisma.restaurantOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantOrderFindManyArgs>(args?: SelectSubset<T, RestaurantOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RestaurantOrder.
     * @param {RestaurantOrderCreateArgs} args - Arguments to create a RestaurantOrder.
     * @example
     * // Create one RestaurantOrder
     * const RestaurantOrder = await prisma.restaurantOrder.create({
     *   data: {
     *     // ... data to create a RestaurantOrder
     *   }
     * })
     * 
     */
    create<T extends RestaurantOrderCreateArgs>(args: SelectSubset<T, RestaurantOrderCreateArgs<ExtArgs>>): Prisma__RestaurantOrderClient<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RestaurantOrders.
     * @param {RestaurantOrderCreateManyArgs} args - Arguments to create many RestaurantOrders.
     * @example
     * // Create many RestaurantOrders
     * const restaurantOrder = await prisma.restaurantOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantOrderCreateManyArgs>(args?: SelectSubset<T, RestaurantOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RestaurantOrders and returns the data saved in the database.
     * @param {RestaurantOrderCreateManyAndReturnArgs} args - Arguments to create many RestaurantOrders.
     * @example
     * // Create many RestaurantOrders
     * const restaurantOrder = await prisma.restaurantOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RestaurantOrders and only return the `id`
     * const restaurantOrderWithIdOnly = await prisma.restaurantOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestaurantOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, RestaurantOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RestaurantOrder.
     * @param {RestaurantOrderDeleteArgs} args - Arguments to delete one RestaurantOrder.
     * @example
     * // Delete one RestaurantOrder
     * const RestaurantOrder = await prisma.restaurantOrder.delete({
     *   where: {
     *     // ... filter to delete one RestaurantOrder
     *   }
     * })
     * 
     */
    delete<T extends RestaurantOrderDeleteArgs>(args: SelectSubset<T, RestaurantOrderDeleteArgs<ExtArgs>>): Prisma__RestaurantOrderClient<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RestaurantOrder.
     * @param {RestaurantOrderUpdateArgs} args - Arguments to update one RestaurantOrder.
     * @example
     * // Update one RestaurantOrder
     * const restaurantOrder = await prisma.restaurantOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantOrderUpdateArgs>(args: SelectSubset<T, RestaurantOrderUpdateArgs<ExtArgs>>): Prisma__RestaurantOrderClient<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RestaurantOrders.
     * @param {RestaurantOrderDeleteManyArgs} args - Arguments to filter RestaurantOrders to delete.
     * @example
     * // Delete a few RestaurantOrders
     * const { count } = await prisma.restaurantOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantOrderDeleteManyArgs>(args?: SelectSubset<T, RestaurantOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestaurantOrders
     * const restaurantOrder = await prisma.restaurantOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantOrderUpdateManyArgs>(args: SelectSubset<T, RestaurantOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantOrders and returns the data updated in the database.
     * @param {RestaurantOrderUpdateManyAndReturnArgs} args - Arguments to update many RestaurantOrders.
     * @example
     * // Update many RestaurantOrders
     * const restaurantOrder = await prisma.restaurantOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RestaurantOrders and only return the `id`
     * const restaurantOrderWithIdOnly = await prisma.restaurantOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RestaurantOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, RestaurantOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RestaurantOrder.
     * @param {RestaurantOrderUpsertArgs} args - Arguments to update or create a RestaurantOrder.
     * @example
     * // Update or create a RestaurantOrder
     * const restaurantOrder = await prisma.restaurantOrder.upsert({
     *   create: {
     *     // ... data to create a RestaurantOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestaurantOrder we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantOrderUpsertArgs>(args: SelectSubset<T, RestaurantOrderUpsertArgs<ExtArgs>>): Prisma__RestaurantOrderClient<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RestaurantOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderCountArgs} args - Arguments to filter RestaurantOrders to count.
     * @example
     * // Count the number of RestaurantOrders
     * const count = await prisma.restaurantOrder.count({
     *   where: {
     *     // ... the filter for the RestaurantOrders we want to count
     *   }
     * })
    **/
    count<T extends RestaurantOrderCountArgs>(
      args?: Subset<T, RestaurantOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RestaurantOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantOrderAggregateArgs>(args: Subset<T, RestaurantOrderAggregateArgs>): Prisma.PrismaPromise<GetRestaurantOrderAggregateType<T>>

    /**
     * Group by RestaurantOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantOrderGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RestaurantOrder model
   */
  readonly fields: RestaurantOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestaurantOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends RestaurantOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    table<T extends RestaurantTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantTableDefaultArgs<ExtArgs>>): Prisma__RestaurantTableClient<$Result.GetResult<Prisma.$RestaurantTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RestaurantOrder model
   */
  interface RestaurantOrderFieldRefs {
    readonly id: FieldRef<"RestaurantOrder", 'String'>
    readonly tableId: FieldRef<"RestaurantOrder", 'String'>
    readonly status: FieldRef<"RestaurantOrder", 'String'>
    readonly totalAmount: FieldRef<"RestaurantOrder", 'Float'>
    readonly createdAt: FieldRef<"RestaurantOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"RestaurantOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RestaurantOrder findUnique
   */
  export type RestaurantOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantOrder to fetch.
     */
    where: RestaurantOrderWhereUniqueInput
  }

  /**
   * RestaurantOrder findUniqueOrThrow
   */
  export type RestaurantOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantOrder to fetch.
     */
    where: RestaurantOrderWhereUniqueInput
  }

  /**
   * RestaurantOrder findFirst
   */
  export type RestaurantOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantOrder to fetch.
     */
    where?: RestaurantOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantOrders to fetch.
     */
    orderBy?: RestaurantOrderOrderByWithRelationInput | RestaurantOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantOrders.
     */
    cursor?: RestaurantOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantOrders.
     */
    distinct?: RestaurantOrderScalarFieldEnum | RestaurantOrderScalarFieldEnum[]
  }

  /**
   * RestaurantOrder findFirstOrThrow
   */
  export type RestaurantOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantOrder to fetch.
     */
    where?: RestaurantOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantOrders to fetch.
     */
    orderBy?: RestaurantOrderOrderByWithRelationInput | RestaurantOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantOrders.
     */
    cursor?: RestaurantOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantOrders.
     */
    distinct?: RestaurantOrderScalarFieldEnum | RestaurantOrderScalarFieldEnum[]
  }

  /**
   * RestaurantOrder findMany
   */
  export type RestaurantOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantOrders to fetch.
     */
    where?: RestaurantOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantOrders to fetch.
     */
    orderBy?: RestaurantOrderOrderByWithRelationInput | RestaurantOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RestaurantOrders.
     */
    cursor?: RestaurantOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantOrders.
     */
    skip?: number
    distinct?: RestaurantOrderScalarFieldEnum | RestaurantOrderScalarFieldEnum[]
  }

  /**
   * RestaurantOrder create
   */
  export type RestaurantOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a RestaurantOrder.
     */
    data: XOR<RestaurantOrderCreateInput, RestaurantOrderUncheckedCreateInput>
  }

  /**
   * RestaurantOrder createMany
   */
  export type RestaurantOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RestaurantOrders.
     */
    data: RestaurantOrderCreateManyInput | RestaurantOrderCreateManyInput[]
  }

  /**
   * RestaurantOrder createManyAndReturn
   */
  export type RestaurantOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * The data used to create many RestaurantOrders.
     */
    data: RestaurantOrderCreateManyInput | RestaurantOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantOrder update
   */
  export type RestaurantOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a RestaurantOrder.
     */
    data: XOR<RestaurantOrderUpdateInput, RestaurantOrderUncheckedUpdateInput>
    /**
     * Choose, which RestaurantOrder to update.
     */
    where: RestaurantOrderWhereUniqueInput
  }

  /**
   * RestaurantOrder updateMany
   */
  export type RestaurantOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RestaurantOrders.
     */
    data: XOR<RestaurantOrderUpdateManyMutationInput, RestaurantOrderUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantOrders to update
     */
    where?: RestaurantOrderWhereInput
    /**
     * Limit how many RestaurantOrders to update.
     */
    limit?: number
  }

  /**
   * RestaurantOrder updateManyAndReturn
   */
  export type RestaurantOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * The data used to update RestaurantOrders.
     */
    data: XOR<RestaurantOrderUpdateManyMutationInput, RestaurantOrderUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantOrders to update
     */
    where?: RestaurantOrderWhereInput
    /**
     * Limit how many RestaurantOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantOrder upsert
   */
  export type RestaurantOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the RestaurantOrder to update in case it exists.
     */
    where: RestaurantOrderWhereUniqueInput
    /**
     * In case the RestaurantOrder found by the `where` argument doesn't exist, create a new RestaurantOrder with this data.
     */
    create: XOR<RestaurantOrderCreateInput, RestaurantOrderUncheckedCreateInput>
    /**
     * In case the RestaurantOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantOrderUpdateInput, RestaurantOrderUncheckedUpdateInput>
  }

  /**
   * RestaurantOrder delete
   */
  export type RestaurantOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderInclude<ExtArgs> | null
    /**
     * Filter which RestaurantOrder to delete.
     */
    where: RestaurantOrderWhereUniqueInput
  }

  /**
   * RestaurantOrder deleteMany
   */
  export type RestaurantOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantOrders to delete
     */
    where?: RestaurantOrderWhereInput
    /**
     * Limit how many RestaurantOrders to delete.
     */
    limit?: number
  }

  /**
   * RestaurantOrder.items
   */
  export type RestaurantOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemInclude<ExtArgs> | null
    where?: RestaurantOrderItemWhereInput
    orderBy?: RestaurantOrderItemOrderByWithRelationInput | RestaurantOrderItemOrderByWithRelationInput[]
    cursor?: RestaurantOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantOrderItemScalarFieldEnum | RestaurantOrderItemScalarFieldEnum[]
  }

  /**
   * RestaurantOrder without action
   */
  export type RestaurantOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrder
     */
    select?: RestaurantOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrder
     */
    omit?: RestaurantOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderInclude<ExtArgs> | null
  }


  /**
   * Model RestaurantOrderItem
   */

  export type AggregateRestaurantOrderItem = {
    _count: RestaurantOrderItemCountAggregateOutputType | null
    _avg: RestaurantOrderItemAvgAggregateOutputType | null
    _sum: RestaurantOrderItemSumAggregateOutputType | null
    _min: RestaurantOrderItemMinAggregateOutputType | null
    _max: RestaurantOrderItemMaxAggregateOutputType | null
  }

  export type RestaurantOrderItemAvgAggregateOutputType = {
    price: number | null
    quantity: number | null
  }

  export type RestaurantOrderItemSumAggregateOutputType = {
    price: number | null
    quantity: number | null
  }

  export type RestaurantOrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    dishId: string | null
    name: string | null
    price: number | null
    quantity: number | null
  }

  export type RestaurantOrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    dishId: string | null
    name: string | null
    price: number | null
    quantity: number | null
  }

  export type RestaurantOrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    dishId: number
    name: number
    price: number
    quantity: number
    _all: number
  }


  export type RestaurantOrderItemAvgAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type RestaurantOrderItemSumAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type RestaurantOrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    dishId?: true
    name?: true
    price?: true
    quantity?: true
  }

  export type RestaurantOrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    dishId?: true
    name?: true
    price?: true
    quantity?: true
  }

  export type RestaurantOrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    dishId?: true
    name?: true
    price?: true
    quantity?: true
    _all?: true
  }

  export type RestaurantOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantOrderItem to aggregate.
     */
    where?: RestaurantOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantOrderItems to fetch.
     */
    orderBy?: RestaurantOrderItemOrderByWithRelationInput | RestaurantOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RestaurantOrderItems
    **/
    _count?: true | RestaurantOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestaurantOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestaurantOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantOrderItemMaxAggregateInputType
  }

  export type GetRestaurantOrderItemAggregateType<T extends RestaurantOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurantOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurantOrderItem[P]>
      : GetScalarType<T[P], AggregateRestaurantOrderItem[P]>
  }




  export type RestaurantOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantOrderItemWhereInput
    orderBy?: RestaurantOrderItemOrderByWithAggregationInput | RestaurantOrderItemOrderByWithAggregationInput[]
    by: RestaurantOrderItemScalarFieldEnum[] | RestaurantOrderItemScalarFieldEnum
    having?: RestaurantOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantOrderItemCountAggregateInputType | true
    _avg?: RestaurantOrderItemAvgAggregateInputType
    _sum?: RestaurantOrderItemSumAggregateInputType
    _min?: RestaurantOrderItemMinAggregateInputType
    _max?: RestaurantOrderItemMaxAggregateInputType
  }

  export type RestaurantOrderItemGroupByOutputType = {
    id: string
    orderId: string
    dishId: string
    name: string
    price: number
    quantity: number
    _count: RestaurantOrderItemCountAggregateOutputType | null
    _avg: RestaurantOrderItemAvgAggregateOutputType | null
    _sum: RestaurantOrderItemSumAggregateOutputType | null
    _min: RestaurantOrderItemMinAggregateOutputType | null
    _max: RestaurantOrderItemMaxAggregateOutputType | null
  }

  type GetRestaurantOrderItemGroupByPayload<T extends RestaurantOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    dishId?: boolean
    name?: boolean
    price?: boolean
    quantity?: boolean
    order?: boolean | RestaurantOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantOrderItem"]>

  export type RestaurantOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    dishId?: boolean
    name?: boolean
    price?: boolean
    quantity?: boolean
    order?: boolean | RestaurantOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantOrderItem"]>

  export type RestaurantOrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    dishId?: boolean
    name?: boolean
    price?: boolean
    quantity?: boolean
    order?: boolean | RestaurantOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantOrderItem"]>

  export type RestaurantOrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    dishId?: boolean
    name?: boolean
    price?: boolean
    quantity?: boolean
  }

  export type RestaurantOrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "dishId" | "name" | "price" | "quantity", ExtArgs["result"]["restaurantOrderItem"]>
  export type RestaurantOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | RestaurantOrderDefaultArgs<ExtArgs>
  }
  export type RestaurantOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | RestaurantOrderDefaultArgs<ExtArgs>
  }
  export type RestaurantOrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | RestaurantOrderDefaultArgs<ExtArgs>
  }

  export type $RestaurantOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RestaurantOrderItem"
    objects: {
      order: Prisma.$RestaurantOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      dishId: string
      name: string
      price: number
      quantity: number
    }, ExtArgs["result"]["restaurantOrderItem"]>
    composites: {}
  }

  type RestaurantOrderItemGetPayload<S extends boolean | null | undefined | RestaurantOrderItemDefaultArgs> = $Result.GetResult<Prisma.$RestaurantOrderItemPayload, S>

  type RestaurantOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestaurantOrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RestaurantOrderItemCountAggregateInputType | true
    }

  export interface RestaurantOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RestaurantOrderItem'], meta: { name: 'RestaurantOrderItem' } }
    /**
     * Find zero or one RestaurantOrderItem that matches the filter.
     * @param {RestaurantOrderItemFindUniqueArgs} args - Arguments to find a RestaurantOrderItem
     * @example
     * // Get one RestaurantOrderItem
     * const restaurantOrderItem = await prisma.restaurantOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantOrderItemFindUniqueArgs>(args: SelectSubset<T, RestaurantOrderItemFindUniqueArgs<ExtArgs>>): Prisma__RestaurantOrderItemClient<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RestaurantOrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestaurantOrderItemFindUniqueOrThrowArgs} args - Arguments to find a RestaurantOrderItem
     * @example
     * // Get one RestaurantOrderItem
     * const restaurantOrderItem = await prisma.restaurantOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantOrderItemClient<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderItemFindFirstArgs} args - Arguments to find a RestaurantOrderItem
     * @example
     * // Get one RestaurantOrderItem
     * const restaurantOrderItem = await prisma.restaurantOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantOrderItemFindFirstArgs>(args?: SelectSubset<T, RestaurantOrderItemFindFirstArgs<ExtArgs>>): Prisma__RestaurantOrderItemClient<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderItemFindFirstOrThrowArgs} args - Arguments to find a RestaurantOrderItem
     * @example
     * // Get one RestaurantOrderItem
     * const restaurantOrderItem = await prisma.restaurantOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantOrderItemClient<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RestaurantOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestaurantOrderItems
     * const restaurantOrderItems = await prisma.restaurantOrderItem.findMany()
     * 
     * // Get first 10 RestaurantOrderItems
     * const restaurantOrderItems = await prisma.restaurantOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantOrderItemWithIdOnly = await prisma.restaurantOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantOrderItemFindManyArgs>(args?: SelectSubset<T, RestaurantOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RestaurantOrderItem.
     * @param {RestaurantOrderItemCreateArgs} args - Arguments to create a RestaurantOrderItem.
     * @example
     * // Create one RestaurantOrderItem
     * const RestaurantOrderItem = await prisma.restaurantOrderItem.create({
     *   data: {
     *     // ... data to create a RestaurantOrderItem
     *   }
     * })
     * 
     */
    create<T extends RestaurantOrderItemCreateArgs>(args: SelectSubset<T, RestaurantOrderItemCreateArgs<ExtArgs>>): Prisma__RestaurantOrderItemClient<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RestaurantOrderItems.
     * @param {RestaurantOrderItemCreateManyArgs} args - Arguments to create many RestaurantOrderItems.
     * @example
     * // Create many RestaurantOrderItems
     * const restaurantOrderItem = await prisma.restaurantOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantOrderItemCreateManyArgs>(args?: SelectSubset<T, RestaurantOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RestaurantOrderItems and returns the data saved in the database.
     * @param {RestaurantOrderItemCreateManyAndReturnArgs} args - Arguments to create many RestaurantOrderItems.
     * @example
     * // Create many RestaurantOrderItems
     * const restaurantOrderItem = await prisma.restaurantOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RestaurantOrderItems and only return the `id`
     * const restaurantOrderItemWithIdOnly = await prisma.restaurantOrderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestaurantOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, RestaurantOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RestaurantOrderItem.
     * @param {RestaurantOrderItemDeleteArgs} args - Arguments to delete one RestaurantOrderItem.
     * @example
     * // Delete one RestaurantOrderItem
     * const RestaurantOrderItem = await prisma.restaurantOrderItem.delete({
     *   where: {
     *     // ... filter to delete one RestaurantOrderItem
     *   }
     * })
     * 
     */
    delete<T extends RestaurantOrderItemDeleteArgs>(args: SelectSubset<T, RestaurantOrderItemDeleteArgs<ExtArgs>>): Prisma__RestaurantOrderItemClient<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RestaurantOrderItem.
     * @param {RestaurantOrderItemUpdateArgs} args - Arguments to update one RestaurantOrderItem.
     * @example
     * // Update one RestaurantOrderItem
     * const restaurantOrderItem = await prisma.restaurantOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantOrderItemUpdateArgs>(args: SelectSubset<T, RestaurantOrderItemUpdateArgs<ExtArgs>>): Prisma__RestaurantOrderItemClient<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RestaurantOrderItems.
     * @param {RestaurantOrderItemDeleteManyArgs} args - Arguments to filter RestaurantOrderItems to delete.
     * @example
     * // Delete a few RestaurantOrderItems
     * const { count } = await prisma.restaurantOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantOrderItemDeleteManyArgs>(args?: SelectSubset<T, RestaurantOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestaurantOrderItems
     * const restaurantOrderItem = await prisma.restaurantOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantOrderItemUpdateManyArgs>(args: SelectSubset<T, RestaurantOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantOrderItems and returns the data updated in the database.
     * @param {RestaurantOrderItemUpdateManyAndReturnArgs} args - Arguments to update many RestaurantOrderItems.
     * @example
     * // Update many RestaurantOrderItems
     * const restaurantOrderItem = await prisma.restaurantOrderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RestaurantOrderItems and only return the `id`
     * const restaurantOrderItemWithIdOnly = await prisma.restaurantOrderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RestaurantOrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, RestaurantOrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RestaurantOrderItem.
     * @param {RestaurantOrderItemUpsertArgs} args - Arguments to update or create a RestaurantOrderItem.
     * @example
     * // Update or create a RestaurantOrderItem
     * const restaurantOrderItem = await prisma.restaurantOrderItem.upsert({
     *   create: {
     *     // ... data to create a RestaurantOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestaurantOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantOrderItemUpsertArgs>(args: SelectSubset<T, RestaurantOrderItemUpsertArgs<ExtArgs>>): Prisma__RestaurantOrderItemClient<$Result.GetResult<Prisma.$RestaurantOrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RestaurantOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderItemCountArgs} args - Arguments to filter RestaurantOrderItems to count.
     * @example
     * // Count the number of RestaurantOrderItems
     * const count = await prisma.restaurantOrderItem.count({
     *   where: {
     *     // ... the filter for the RestaurantOrderItems we want to count
     *   }
     * })
    **/
    count<T extends RestaurantOrderItemCountArgs>(
      args?: Subset<T, RestaurantOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RestaurantOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantOrderItemAggregateArgs>(args: Subset<T, RestaurantOrderItemAggregateArgs>): Prisma.PrismaPromise<GetRestaurantOrderItemAggregateType<T>>

    /**
     * Group by RestaurantOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RestaurantOrderItem model
   */
  readonly fields: RestaurantOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestaurantOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends RestaurantOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantOrderDefaultArgs<ExtArgs>>): Prisma__RestaurantOrderClient<$Result.GetResult<Prisma.$RestaurantOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RestaurantOrderItem model
   */
  interface RestaurantOrderItemFieldRefs {
    readonly id: FieldRef<"RestaurantOrderItem", 'String'>
    readonly orderId: FieldRef<"RestaurantOrderItem", 'String'>
    readonly dishId: FieldRef<"RestaurantOrderItem", 'String'>
    readonly name: FieldRef<"RestaurantOrderItem", 'String'>
    readonly price: FieldRef<"RestaurantOrderItem", 'Float'>
    readonly quantity: FieldRef<"RestaurantOrderItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RestaurantOrderItem findUnique
   */
  export type RestaurantOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantOrderItem to fetch.
     */
    where: RestaurantOrderItemWhereUniqueInput
  }

  /**
   * RestaurantOrderItem findUniqueOrThrow
   */
  export type RestaurantOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantOrderItem to fetch.
     */
    where: RestaurantOrderItemWhereUniqueInput
  }

  /**
   * RestaurantOrderItem findFirst
   */
  export type RestaurantOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantOrderItem to fetch.
     */
    where?: RestaurantOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantOrderItems to fetch.
     */
    orderBy?: RestaurantOrderItemOrderByWithRelationInput | RestaurantOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantOrderItems.
     */
    cursor?: RestaurantOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantOrderItems.
     */
    distinct?: RestaurantOrderItemScalarFieldEnum | RestaurantOrderItemScalarFieldEnum[]
  }

  /**
   * RestaurantOrderItem findFirstOrThrow
   */
  export type RestaurantOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantOrderItem to fetch.
     */
    where?: RestaurantOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantOrderItems to fetch.
     */
    orderBy?: RestaurantOrderItemOrderByWithRelationInput | RestaurantOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantOrderItems.
     */
    cursor?: RestaurantOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantOrderItems.
     */
    distinct?: RestaurantOrderItemScalarFieldEnum | RestaurantOrderItemScalarFieldEnum[]
  }

  /**
   * RestaurantOrderItem findMany
   */
  export type RestaurantOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantOrderItems to fetch.
     */
    where?: RestaurantOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantOrderItems to fetch.
     */
    orderBy?: RestaurantOrderItemOrderByWithRelationInput | RestaurantOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RestaurantOrderItems.
     */
    cursor?: RestaurantOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantOrderItems.
     */
    skip?: number
    distinct?: RestaurantOrderItemScalarFieldEnum | RestaurantOrderItemScalarFieldEnum[]
  }

  /**
   * RestaurantOrderItem create
   */
  export type RestaurantOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RestaurantOrderItem.
     */
    data: XOR<RestaurantOrderItemCreateInput, RestaurantOrderItemUncheckedCreateInput>
  }

  /**
   * RestaurantOrderItem createMany
   */
  export type RestaurantOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RestaurantOrderItems.
     */
    data: RestaurantOrderItemCreateManyInput | RestaurantOrderItemCreateManyInput[]
  }

  /**
   * RestaurantOrderItem createManyAndReturn
   */
  export type RestaurantOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many RestaurantOrderItems.
     */
    data: RestaurantOrderItemCreateManyInput | RestaurantOrderItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantOrderItem update
   */
  export type RestaurantOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RestaurantOrderItem.
     */
    data: XOR<RestaurantOrderItemUpdateInput, RestaurantOrderItemUncheckedUpdateInput>
    /**
     * Choose, which RestaurantOrderItem to update.
     */
    where: RestaurantOrderItemWhereUniqueInput
  }

  /**
   * RestaurantOrderItem updateMany
   */
  export type RestaurantOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RestaurantOrderItems.
     */
    data: XOR<RestaurantOrderItemUpdateManyMutationInput, RestaurantOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantOrderItems to update
     */
    where?: RestaurantOrderItemWhereInput
    /**
     * Limit how many RestaurantOrderItems to update.
     */
    limit?: number
  }

  /**
   * RestaurantOrderItem updateManyAndReturn
   */
  export type RestaurantOrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * The data used to update RestaurantOrderItems.
     */
    data: XOR<RestaurantOrderItemUpdateManyMutationInput, RestaurantOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantOrderItems to update
     */
    where?: RestaurantOrderItemWhereInput
    /**
     * Limit how many RestaurantOrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantOrderItem upsert
   */
  export type RestaurantOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RestaurantOrderItem to update in case it exists.
     */
    where: RestaurantOrderItemWhereUniqueInput
    /**
     * In case the RestaurantOrderItem found by the `where` argument doesn't exist, create a new RestaurantOrderItem with this data.
     */
    create: XOR<RestaurantOrderItemCreateInput, RestaurantOrderItemUncheckedCreateInput>
    /**
     * In case the RestaurantOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantOrderItemUpdateInput, RestaurantOrderItemUncheckedUpdateInput>
  }

  /**
   * RestaurantOrderItem delete
   */
  export type RestaurantOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemInclude<ExtArgs> | null
    /**
     * Filter which RestaurantOrderItem to delete.
     */
    where: RestaurantOrderItemWhereUniqueInput
  }

  /**
   * RestaurantOrderItem deleteMany
   */
  export type RestaurantOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantOrderItems to delete
     */
    where?: RestaurantOrderItemWhereInput
    /**
     * Limit how many RestaurantOrderItems to delete.
     */
    limit?: number
  }

  /**
   * RestaurantOrderItem without action
   */
  export type RestaurantOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantOrderItem
     */
    select?: RestaurantOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantOrderItem
     */
    omit?: RestaurantOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model CabinetService
   */

  export type AggregateCabinetService = {
    _count: CabinetServiceCountAggregateOutputType | null
    _avg: CabinetServiceAvgAggregateOutputType | null
    _sum: CabinetServiceSumAggregateOutputType | null
    _min: CabinetServiceMinAggregateOutputType | null
    _max: CabinetServiceMaxAggregateOutputType | null
  }

  export type CabinetServiceAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type CabinetServiceSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type CabinetServiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    price: number | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type CabinetServiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    price: number | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type CabinetServiceCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    price: number
    duration: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type CabinetServiceAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type CabinetServiceSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type CabinetServiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    isActive?: true
    createdAt?: true
  }

  export type CabinetServiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    isActive?: true
    createdAt?: true
  }

  export type CabinetServiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type CabinetServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetService to aggregate.
     */
    where?: CabinetServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetServices to fetch.
     */
    orderBy?: CabinetServiceOrderByWithRelationInput | CabinetServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetServices
    **/
    _count?: true | CabinetServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CabinetServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CabinetServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetServiceMaxAggregateInputType
  }

  export type GetCabinetServiceAggregateType<T extends CabinetServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetService[P]>
      : GetScalarType<T[P], AggregateCabinetService[P]>
  }




  export type CabinetServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetServiceWhereInput
    orderBy?: CabinetServiceOrderByWithAggregationInput | CabinetServiceOrderByWithAggregationInput[]
    by: CabinetServiceScalarFieldEnum[] | CabinetServiceScalarFieldEnum
    having?: CabinetServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetServiceCountAggregateInputType | true
    _avg?: CabinetServiceAvgAggregateInputType
    _sum?: CabinetServiceSumAggregateInputType
    _min?: CabinetServiceMinAggregateInputType
    _max?: CabinetServiceMaxAggregateInputType
  }

  export type CabinetServiceGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    price: number
    duration: number
    isActive: boolean
    createdAt: Date
    _count: CabinetServiceCountAggregateOutputType | null
    _avg: CabinetServiceAvgAggregateOutputType | null
    _sum: CabinetServiceSumAggregateOutputType | null
    _min: CabinetServiceMinAggregateOutputType | null
    _max: CabinetServiceMaxAggregateOutputType | null
  }

  type GetCabinetServiceGroupByPayload<T extends CabinetServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetServiceGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetServiceGroupByOutputType[P]>
        }
      >
    >


  export type CabinetServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
    appointments?: boolean | CabinetService$appointmentsArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    _count?: boolean | CabinetServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetService"]>

  export type CabinetServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetService"]>

  export type CabinetServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetService"]>

  export type CabinetServiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type CabinetServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "price" | "duration" | "isActive" | "createdAt", ExtArgs["result"]["cabinetService"]>
  export type CabinetServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | CabinetService$appointmentsArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    _count?: boolean | CabinetServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CabinetServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type CabinetServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }

  export type $CabinetServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetService"
    objects: {
      appointments: Prisma.$CabinetAppointmentPayload<ExtArgs>[]
      tenant: Prisma.$TenantWebsitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      price: number
      duration: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["cabinetService"]>
    composites: {}
  }

  type CabinetServiceGetPayload<S extends boolean | null | undefined | CabinetServiceDefaultArgs> = $Result.GetResult<Prisma.$CabinetServicePayload, S>

  type CabinetServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetServiceCountAggregateInputType | true
    }

  export interface CabinetServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetService'], meta: { name: 'CabinetService' } }
    /**
     * Find zero or one CabinetService that matches the filter.
     * @param {CabinetServiceFindUniqueArgs} args - Arguments to find a CabinetService
     * @example
     * // Get one CabinetService
     * const cabinetService = await prisma.cabinetService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetServiceFindUniqueArgs>(args: SelectSubset<T, CabinetServiceFindUniqueArgs<ExtArgs>>): Prisma__CabinetServiceClient<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetServiceFindUniqueOrThrowArgs} args - Arguments to find a CabinetService
     * @example
     * // Get one CabinetService
     * const cabinetService = await prisma.cabinetService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetServiceClient<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetServiceFindFirstArgs} args - Arguments to find a CabinetService
     * @example
     * // Get one CabinetService
     * const cabinetService = await prisma.cabinetService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetServiceFindFirstArgs>(args?: SelectSubset<T, CabinetServiceFindFirstArgs<ExtArgs>>): Prisma__CabinetServiceClient<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetServiceFindFirstOrThrowArgs} args - Arguments to find a CabinetService
     * @example
     * // Get one CabinetService
     * const cabinetService = await prisma.cabinetService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetServiceClient<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetServices
     * const cabinetServices = await prisma.cabinetService.findMany()
     * 
     * // Get first 10 CabinetServices
     * const cabinetServices = await prisma.cabinetService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cabinetServiceWithIdOnly = await prisma.cabinetService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CabinetServiceFindManyArgs>(args?: SelectSubset<T, CabinetServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetService.
     * @param {CabinetServiceCreateArgs} args - Arguments to create a CabinetService.
     * @example
     * // Create one CabinetService
     * const CabinetService = await prisma.cabinetService.create({
     *   data: {
     *     // ... data to create a CabinetService
     *   }
     * })
     * 
     */
    create<T extends CabinetServiceCreateArgs>(args: SelectSubset<T, CabinetServiceCreateArgs<ExtArgs>>): Prisma__CabinetServiceClient<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetServices.
     * @param {CabinetServiceCreateManyArgs} args - Arguments to create many CabinetServices.
     * @example
     * // Create many CabinetServices
     * const cabinetService = await prisma.cabinetService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetServiceCreateManyArgs>(args?: SelectSubset<T, CabinetServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetServices and returns the data saved in the database.
     * @param {CabinetServiceCreateManyAndReturnArgs} args - Arguments to create many CabinetServices.
     * @example
     * // Create many CabinetServices
     * const cabinetService = await prisma.cabinetService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetServices and only return the `id`
     * const cabinetServiceWithIdOnly = await prisma.cabinetService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetService.
     * @param {CabinetServiceDeleteArgs} args - Arguments to delete one CabinetService.
     * @example
     * // Delete one CabinetService
     * const CabinetService = await prisma.cabinetService.delete({
     *   where: {
     *     // ... filter to delete one CabinetService
     *   }
     * })
     * 
     */
    delete<T extends CabinetServiceDeleteArgs>(args: SelectSubset<T, CabinetServiceDeleteArgs<ExtArgs>>): Prisma__CabinetServiceClient<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetService.
     * @param {CabinetServiceUpdateArgs} args - Arguments to update one CabinetService.
     * @example
     * // Update one CabinetService
     * const cabinetService = await prisma.cabinetService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetServiceUpdateArgs>(args: SelectSubset<T, CabinetServiceUpdateArgs<ExtArgs>>): Prisma__CabinetServiceClient<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetServices.
     * @param {CabinetServiceDeleteManyArgs} args - Arguments to filter CabinetServices to delete.
     * @example
     * // Delete a few CabinetServices
     * const { count } = await prisma.cabinetService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetServiceDeleteManyArgs>(args?: SelectSubset<T, CabinetServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetServices
     * const cabinetService = await prisma.cabinetService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetServiceUpdateManyArgs>(args: SelectSubset<T, CabinetServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetServices and returns the data updated in the database.
     * @param {CabinetServiceUpdateManyAndReturnArgs} args - Arguments to update many CabinetServices.
     * @example
     * // Update many CabinetServices
     * const cabinetService = await prisma.cabinetService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetServices and only return the `id`
     * const cabinetServiceWithIdOnly = await prisma.cabinetService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetService.
     * @param {CabinetServiceUpsertArgs} args - Arguments to update or create a CabinetService.
     * @example
     * // Update or create a CabinetService
     * const cabinetService = await prisma.cabinetService.upsert({
     *   create: {
     *     // ... data to create a CabinetService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetService we want to update
     *   }
     * })
     */
    upsert<T extends CabinetServiceUpsertArgs>(args: SelectSubset<T, CabinetServiceUpsertArgs<ExtArgs>>): Prisma__CabinetServiceClient<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetServiceCountArgs} args - Arguments to filter CabinetServices to count.
     * @example
     * // Count the number of CabinetServices
     * const count = await prisma.cabinetService.count({
     *   where: {
     *     // ... the filter for the CabinetServices we want to count
     *   }
     * })
    **/
    count<T extends CabinetServiceCountArgs>(
      args?: Subset<T, CabinetServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetServiceAggregateArgs>(args: Subset<T, CabinetServiceAggregateArgs>): Prisma.PrismaPromise<GetCabinetServiceAggregateType<T>>

    /**
     * Group by CabinetService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetServiceGroupByArgs['orderBy'] }
        : { orderBy?: CabinetServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetService model
   */
  readonly fields: CabinetServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends CabinetService$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, CabinetService$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantWebsiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsiteDefaultArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetService model
   */
  interface CabinetServiceFieldRefs {
    readonly id: FieldRef<"CabinetService", 'String'>
    readonly tenantId: FieldRef<"CabinetService", 'String'>
    readonly name: FieldRef<"CabinetService", 'String'>
    readonly description: FieldRef<"CabinetService", 'String'>
    readonly price: FieldRef<"CabinetService", 'Float'>
    readonly duration: FieldRef<"CabinetService", 'Int'>
    readonly isActive: FieldRef<"CabinetService", 'Boolean'>
    readonly createdAt: FieldRef<"CabinetService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CabinetService findUnique
   */
  export type CabinetServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceInclude<ExtArgs> | null
    /**
     * Filter, which CabinetService to fetch.
     */
    where: CabinetServiceWhereUniqueInput
  }

  /**
   * CabinetService findUniqueOrThrow
   */
  export type CabinetServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceInclude<ExtArgs> | null
    /**
     * Filter, which CabinetService to fetch.
     */
    where: CabinetServiceWhereUniqueInput
  }

  /**
   * CabinetService findFirst
   */
  export type CabinetServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceInclude<ExtArgs> | null
    /**
     * Filter, which CabinetService to fetch.
     */
    where?: CabinetServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetServices to fetch.
     */
    orderBy?: CabinetServiceOrderByWithRelationInput | CabinetServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetServices.
     */
    cursor?: CabinetServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetServices.
     */
    distinct?: CabinetServiceScalarFieldEnum | CabinetServiceScalarFieldEnum[]
  }

  /**
   * CabinetService findFirstOrThrow
   */
  export type CabinetServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceInclude<ExtArgs> | null
    /**
     * Filter, which CabinetService to fetch.
     */
    where?: CabinetServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetServices to fetch.
     */
    orderBy?: CabinetServiceOrderByWithRelationInput | CabinetServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetServices.
     */
    cursor?: CabinetServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetServices.
     */
    distinct?: CabinetServiceScalarFieldEnum | CabinetServiceScalarFieldEnum[]
  }

  /**
   * CabinetService findMany
   */
  export type CabinetServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceInclude<ExtArgs> | null
    /**
     * Filter, which CabinetServices to fetch.
     */
    where?: CabinetServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetServices to fetch.
     */
    orderBy?: CabinetServiceOrderByWithRelationInput | CabinetServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetServices.
     */
    cursor?: CabinetServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetServices.
     */
    skip?: number
    distinct?: CabinetServiceScalarFieldEnum | CabinetServiceScalarFieldEnum[]
  }

  /**
   * CabinetService create
   */
  export type CabinetServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetService.
     */
    data: XOR<CabinetServiceCreateInput, CabinetServiceUncheckedCreateInput>
  }

  /**
   * CabinetService createMany
   */
  export type CabinetServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetServices.
     */
    data: CabinetServiceCreateManyInput | CabinetServiceCreateManyInput[]
  }

  /**
   * CabinetService createManyAndReturn
   */
  export type CabinetServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetServices.
     */
    data: CabinetServiceCreateManyInput | CabinetServiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetService update
   */
  export type CabinetServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetService.
     */
    data: XOR<CabinetServiceUpdateInput, CabinetServiceUncheckedUpdateInput>
    /**
     * Choose, which CabinetService to update.
     */
    where: CabinetServiceWhereUniqueInput
  }

  /**
   * CabinetService updateMany
   */
  export type CabinetServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetServices.
     */
    data: XOR<CabinetServiceUpdateManyMutationInput, CabinetServiceUncheckedUpdateManyInput>
    /**
     * Filter which CabinetServices to update
     */
    where?: CabinetServiceWhereInput
    /**
     * Limit how many CabinetServices to update.
     */
    limit?: number
  }

  /**
   * CabinetService updateManyAndReturn
   */
  export type CabinetServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * The data used to update CabinetServices.
     */
    data: XOR<CabinetServiceUpdateManyMutationInput, CabinetServiceUncheckedUpdateManyInput>
    /**
     * Filter which CabinetServices to update
     */
    where?: CabinetServiceWhereInput
    /**
     * Limit how many CabinetServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetService upsert
   */
  export type CabinetServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetService to update in case it exists.
     */
    where: CabinetServiceWhereUniqueInput
    /**
     * In case the CabinetService found by the `where` argument doesn't exist, create a new CabinetService with this data.
     */
    create: XOR<CabinetServiceCreateInput, CabinetServiceUncheckedCreateInput>
    /**
     * In case the CabinetService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetServiceUpdateInput, CabinetServiceUncheckedUpdateInput>
  }

  /**
   * CabinetService delete
   */
  export type CabinetServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceInclude<ExtArgs> | null
    /**
     * Filter which CabinetService to delete.
     */
    where: CabinetServiceWhereUniqueInput
  }

  /**
   * CabinetService deleteMany
   */
  export type CabinetServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetServices to delete
     */
    where?: CabinetServiceWhereInput
    /**
     * Limit how many CabinetServices to delete.
     */
    limit?: number
  }

  /**
   * CabinetService.appointments
   */
  export type CabinetService$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    where?: CabinetAppointmentWhereInput
    orderBy?: CabinetAppointmentOrderByWithRelationInput | CabinetAppointmentOrderByWithRelationInput[]
    cursor?: CabinetAppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetAppointmentScalarFieldEnum | CabinetAppointmentScalarFieldEnum[]
  }

  /**
   * CabinetService without action
   */
  export type CabinetServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetService
     */
    select?: CabinetServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetService
     */
    omit?: CabinetServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetServiceInclude<ExtArgs> | null
  }


  /**
   * Model CabinetClient
   */

  export type AggregateCabinetClient = {
    _count: CabinetClientCountAggregateOutputType | null
    _min: CabinetClientMinAggregateOutputType | null
    _max: CabinetClientMaxAggregateOutputType | null
  }

  export type CabinetClientMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CabinetClientMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CabinetClientCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    email: number
    phone: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CabinetClientMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CabinetClientMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CabinetClientCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CabinetClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetClient to aggregate.
     */
    where?: CabinetClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetClients to fetch.
     */
    orderBy?: CabinetClientOrderByWithRelationInput | CabinetClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetClients
    **/
    _count?: true | CabinetClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetClientMaxAggregateInputType
  }

  export type GetCabinetClientAggregateType<T extends CabinetClientAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetClient[P]>
      : GetScalarType<T[P], AggregateCabinetClient[P]>
  }




  export type CabinetClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetClientWhereInput
    orderBy?: CabinetClientOrderByWithAggregationInput | CabinetClientOrderByWithAggregationInput[]
    by: CabinetClientScalarFieldEnum[] | CabinetClientScalarFieldEnum
    having?: CabinetClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetClientCountAggregateInputType | true
    _min?: CabinetClientMinAggregateInputType
    _max?: CabinetClientMaxAggregateInputType
  }

  export type CabinetClientGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    email: string | null
    phone: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CabinetClientCountAggregateOutputType | null
    _min: CabinetClientMinAggregateOutputType | null
    _max: CabinetClientMaxAggregateOutputType | null
  }

  type GetCabinetClientGroupByPayload<T extends CabinetClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetClientGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetClientGroupByOutputType[P]>
        }
      >
    >


  export type CabinetClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointments?: boolean | CabinetClient$appointmentsArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    _count?: boolean | CabinetClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetClient"]>

  export type CabinetClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetClient"]>

  export type CabinetClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetClient"]>

  export type CabinetClientSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CabinetClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "email" | "phone" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["cabinetClient"]>
  export type CabinetClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | CabinetClient$appointmentsArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
    _count?: boolean | CabinetClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CabinetClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type CabinetClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }

  export type $CabinetClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetClient"
    objects: {
      appointments: Prisma.$CabinetAppointmentPayload<ExtArgs>[]
      tenant: Prisma.$TenantWebsitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      email: string | null
      phone: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cabinetClient"]>
    composites: {}
  }

  type CabinetClientGetPayload<S extends boolean | null | undefined | CabinetClientDefaultArgs> = $Result.GetResult<Prisma.$CabinetClientPayload, S>

  type CabinetClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetClientCountAggregateInputType | true
    }

  export interface CabinetClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetClient'], meta: { name: 'CabinetClient' } }
    /**
     * Find zero or one CabinetClient that matches the filter.
     * @param {CabinetClientFindUniqueArgs} args - Arguments to find a CabinetClient
     * @example
     * // Get one CabinetClient
     * const cabinetClient = await prisma.cabinetClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetClientFindUniqueArgs>(args: SelectSubset<T, CabinetClientFindUniqueArgs<ExtArgs>>): Prisma__CabinetClientClient<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetClient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetClientFindUniqueOrThrowArgs} args - Arguments to find a CabinetClient
     * @example
     * // Get one CabinetClient
     * const cabinetClient = await prisma.cabinetClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetClientFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetClientClient<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetClientFindFirstArgs} args - Arguments to find a CabinetClient
     * @example
     * // Get one CabinetClient
     * const cabinetClient = await prisma.cabinetClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetClientFindFirstArgs>(args?: SelectSubset<T, CabinetClientFindFirstArgs<ExtArgs>>): Prisma__CabinetClientClient<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetClientFindFirstOrThrowArgs} args - Arguments to find a CabinetClient
     * @example
     * // Get one CabinetClient
     * const cabinetClient = await prisma.cabinetClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetClientFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetClientClient<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetClients
     * const cabinetClients = await prisma.cabinetClient.findMany()
     * 
     * // Get first 10 CabinetClients
     * const cabinetClients = await prisma.cabinetClient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cabinetClientWithIdOnly = await prisma.cabinetClient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CabinetClientFindManyArgs>(args?: SelectSubset<T, CabinetClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetClient.
     * @param {CabinetClientCreateArgs} args - Arguments to create a CabinetClient.
     * @example
     * // Create one CabinetClient
     * const CabinetClient = await prisma.cabinetClient.create({
     *   data: {
     *     // ... data to create a CabinetClient
     *   }
     * })
     * 
     */
    create<T extends CabinetClientCreateArgs>(args: SelectSubset<T, CabinetClientCreateArgs<ExtArgs>>): Prisma__CabinetClientClient<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetClients.
     * @param {CabinetClientCreateManyArgs} args - Arguments to create many CabinetClients.
     * @example
     * // Create many CabinetClients
     * const cabinetClient = await prisma.cabinetClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetClientCreateManyArgs>(args?: SelectSubset<T, CabinetClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetClients and returns the data saved in the database.
     * @param {CabinetClientCreateManyAndReturnArgs} args - Arguments to create many CabinetClients.
     * @example
     * // Create many CabinetClients
     * const cabinetClient = await prisma.cabinetClient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetClients and only return the `id`
     * const cabinetClientWithIdOnly = await prisma.cabinetClient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetClientCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetClient.
     * @param {CabinetClientDeleteArgs} args - Arguments to delete one CabinetClient.
     * @example
     * // Delete one CabinetClient
     * const CabinetClient = await prisma.cabinetClient.delete({
     *   where: {
     *     // ... filter to delete one CabinetClient
     *   }
     * })
     * 
     */
    delete<T extends CabinetClientDeleteArgs>(args: SelectSubset<T, CabinetClientDeleteArgs<ExtArgs>>): Prisma__CabinetClientClient<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetClient.
     * @param {CabinetClientUpdateArgs} args - Arguments to update one CabinetClient.
     * @example
     * // Update one CabinetClient
     * const cabinetClient = await prisma.cabinetClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetClientUpdateArgs>(args: SelectSubset<T, CabinetClientUpdateArgs<ExtArgs>>): Prisma__CabinetClientClient<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetClients.
     * @param {CabinetClientDeleteManyArgs} args - Arguments to filter CabinetClients to delete.
     * @example
     * // Delete a few CabinetClients
     * const { count } = await prisma.cabinetClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetClientDeleteManyArgs>(args?: SelectSubset<T, CabinetClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetClients
     * const cabinetClient = await prisma.cabinetClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetClientUpdateManyArgs>(args: SelectSubset<T, CabinetClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetClients and returns the data updated in the database.
     * @param {CabinetClientUpdateManyAndReturnArgs} args - Arguments to update many CabinetClients.
     * @example
     * // Update many CabinetClients
     * const cabinetClient = await prisma.cabinetClient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetClients and only return the `id`
     * const cabinetClientWithIdOnly = await prisma.cabinetClient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetClientUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetClient.
     * @param {CabinetClientUpsertArgs} args - Arguments to update or create a CabinetClient.
     * @example
     * // Update or create a CabinetClient
     * const cabinetClient = await prisma.cabinetClient.upsert({
     *   create: {
     *     // ... data to create a CabinetClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetClient we want to update
     *   }
     * })
     */
    upsert<T extends CabinetClientUpsertArgs>(args: SelectSubset<T, CabinetClientUpsertArgs<ExtArgs>>): Prisma__CabinetClientClient<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetClientCountArgs} args - Arguments to filter CabinetClients to count.
     * @example
     * // Count the number of CabinetClients
     * const count = await prisma.cabinetClient.count({
     *   where: {
     *     // ... the filter for the CabinetClients we want to count
     *   }
     * })
    **/
    count<T extends CabinetClientCountArgs>(
      args?: Subset<T, CabinetClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetClientAggregateArgs>(args: Subset<T, CabinetClientAggregateArgs>): Prisma.PrismaPromise<GetCabinetClientAggregateType<T>>

    /**
     * Group by CabinetClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetClientGroupByArgs['orderBy'] }
        : { orderBy?: CabinetClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetClient model
   */
  readonly fields: CabinetClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends CabinetClient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, CabinetClient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantWebsiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsiteDefaultArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetClient model
   */
  interface CabinetClientFieldRefs {
    readonly id: FieldRef<"CabinetClient", 'String'>
    readonly tenantId: FieldRef<"CabinetClient", 'String'>
    readonly name: FieldRef<"CabinetClient", 'String'>
    readonly email: FieldRef<"CabinetClient", 'String'>
    readonly phone: FieldRef<"CabinetClient", 'String'>
    readonly notes: FieldRef<"CabinetClient", 'String'>
    readonly createdAt: FieldRef<"CabinetClient", 'DateTime'>
    readonly updatedAt: FieldRef<"CabinetClient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CabinetClient findUnique
   */
  export type CabinetClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientInclude<ExtArgs> | null
    /**
     * Filter, which CabinetClient to fetch.
     */
    where: CabinetClientWhereUniqueInput
  }

  /**
   * CabinetClient findUniqueOrThrow
   */
  export type CabinetClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientInclude<ExtArgs> | null
    /**
     * Filter, which CabinetClient to fetch.
     */
    where: CabinetClientWhereUniqueInput
  }

  /**
   * CabinetClient findFirst
   */
  export type CabinetClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientInclude<ExtArgs> | null
    /**
     * Filter, which CabinetClient to fetch.
     */
    where?: CabinetClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetClients to fetch.
     */
    orderBy?: CabinetClientOrderByWithRelationInput | CabinetClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetClients.
     */
    cursor?: CabinetClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetClients.
     */
    distinct?: CabinetClientScalarFieldEnum | CabinetClientScalarFieldEnum[]
  }

  /**
   * CabinetClient findFirstOrThrow
   */
  export type CabinetClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientInclude<ExtArgs> | null
    /**
     * Filter, which CabinetClient to fetch.
     */
    where?: CabinetClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetClients to fetch.
     */
    orderBy?: CabinetClientOrderByWithRelationInput | CabinetClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetClients.
     */
    cursor?: CabinetClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetClients.
     */
    distinct?: CabinetClientScalarFieldEnum | CabinetClientScalarFieldEnum[]
  }

  /**
   * CabinetClient findMany
   */
  export type CabinetClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientInclude<ExtArgs> | null
    /**
     * Filter, which CabinetClients to fetch.
     */
    where?: CabinetClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetClients to fetch.
     */
    orderBy?: CabinetClientOrderByWithRelationInput | CabinetClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetClients.
     */
    cursor?: CabinetClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetClients.
     */
    skip?: number
    distinct?: CabinetClientScalarFieldEnum | CabinetClientScalarFieldEnum[]
  }

  /**
   * CabinetClient create
   */
  export type CabinetClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetClient.
     */
    data: XOR<CabinetClientCreateInput, CabinetClientUncheckedCreateInput>
  }

  /**
   * CabinetClient createMany
   */
  export type CabinetClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetClients.
     */
    data: CabinetClientCreateManyInput | CabinetClientCreateManyInput[]
  }

  /**
   * CabinetClient createManyAndReturn
   */
  export type CabinetClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetClients.
     */
    data: CabinetClientCreateManyInput | CabinetClientCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetClient update
   */
  export type CabinetClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetClient.
     */
    data: XOR<CabinetClientUpdateInput, CabinetClientUncheckedUpdateInput>
    /**
     * Choose, which CabinetClient to update.
     */
    where: CabinetClientWhereUniqueInput
  }

  /**
   * CabinetClient updateMany
   */
  export type CabinetClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetClients.
     */
    data: XOR<CabinetClientUpdateManyMutationInput, CabinetClientUncheckedUpdateManyInput>
    /**
     * Filter which CabinetClients to update
     */
    where?: CabinetClientWhereInput
    /**
     * Limit how many CabinetClients to update.
     */
    limit?: number
  }

  /**
   * CabinetClient updateManyAndReturn
   */
  export type CabinetClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * The data used to update CabinetClients.
     */
    data: XOR<CabinetClientUpdateManyMutationInput, CabinetClientUncheckedUpdateManyInput>
    /**
     * Filter which CabinetClients to update
     */
    where?: CabinetClientWhereInput
    /**
     * Limit how many CabinetClients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetClient upsert
   */
  export type CabinetClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetClient to update in case it exists.
     */
    where: CabinetClientWhereUniqueInput
    /**
     * In case the CabinetClient found by the `where` argument doesn't exist, create a new CabinetClient with this data.
     */
    create: XOR<CabinetClientCreateInput, CabinetClientUncheckedCreateInput>
    /**
     * In case the CabinetClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetClientUpdateInput, CabinetClientUncheckedUpdateInput>
  }

  /**
   * CabinetClient delete
   */
  export type CabinetClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientInclude<ExtArgs> | null
    /**
     * Filter which CabinetClient to delete.
     */
    where: CabinetClientWhereUniqueInput
  }

  /**
   * CabinetClient deleteMany
   */
  export type CabinetClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetClients to delete
     */
    where?: CabinetClientWhereInput
    /**
     * Limit how many CabinetClients to delete.
     */
    limit?: number
  }

  /**
   * CabinetClient.appointments
   */
  export type CabinetClient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    where?: CabinetAppointmentWhereInput
    orderBy?: CabinetAppointmentOrderByWithRelationInput | CabinetAppointmentOrderByWithRelationInput[]
    cursor?: CabinetAppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CabinetAppointmentScalarFieldEnum | CabinetAppointmentScalarFieldEnum[]
  }

  /**
   * CabinetClient without action
   */
  export type CabinetClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetClient
     */
    select?: CabinetClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetClient
     */
    omit?: CabinetClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetClientInclude<ExtArgs> | null
  }


  /**
   * Model CabinetAppointment
   */

  export type AggregateCabinetAppointment = {
    _count: CabinetAppointmentCountAggregateOutputType | null
    _min: CabinetAppointmentMinAggregateOutputType | null
    _max: CabinetAppointmentMaxAggregateOutputType | null
  }

  export type CabinetAppointmentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    serviceId: string | null
    clientId: string | null
    appointmentDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CabinetAppointmentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    serviceId: string | null
    clientId: string | null
    appointmentDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CabinetAppointmentCountAggregateOutputType = {
    id: number
    tenantId: number
    serviceId: number
    clientId: number
    appointmentDate: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CabinetAppointmentMinAggregateInputType = {
    id?: true
    tenantId?: true
    serviceId?: true
    clientId?: true
    appointmentDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CabinetAppointmentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    serviceId?: true
    clientId?: true
    appointmentDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CabinetAppointmentCountAggregateInputType = {
    id?: true
    tenantId?: true
    serviceId?: true
    clientId?: true
    appointmentDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CabinetAppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetAppointment to aggregate.
     */
    where?: CabinetAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetAppointments to fetch.
     */
    orderBy?: CabinetAppointmentOrderByWithRelationInput | CabinetAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CabinetAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CabinetAppointments
    **/
    _count?: true | CabinetAppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CabinetAppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CabinetAppointmentMaxAggregateInputType
  }

  export type GetCabinetAppointmentAggregateType<T extends CabinetAppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCabinetAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCabinetAppointment[P]>
      : GetScalarType<T[P], AggregateCabinetAppointment[P]>
  }




  export type CabinetAppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CabinetAppointmentWhereInput
    orderBy?: CabinetAppointmentOrderByWithAggregationInput | CabinetAppointmentOrderByWithAggregationInput[]
    by: CabinetAppointmentScalarFieldEnum[] | CabinetAppointmentScalarFieldEnum
    having?: CabinetAppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CabinetAppointmentCountAggregateInputType | true
    _min?: CabinetAppointmentMinAggregateInputType
    _max?: CabinetAppointmentMaxAggregateInputType
  }

  export type CabinetAppointmentGroupByOutputType = {
    id: string
    tenantId: string
    serviceId: string
    clientId: string
    appointmentDate: Date
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CabinetAppointmentCountAggregateOutputType | null
    _min: CabinetAppointmentMinAggregateOutputType | null
    _max: CabinetAppointmentMaxAggregateOutputType | null
  }

  type GetCabinetAppointmentGroupByPayload<T extends CabinetAppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CabinetAppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CabinetAppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CabinetAppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], CabinetAppointmentGroupByOutputType[P]>
        }
      >
    >


  export type CabinetAppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    serviceId?: boolean
    clientId?: boolean
    appointmentDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | CabinetServiceDefaultArgs<ExtArgs>
    client?: boolean | CabinetClientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetAppointment"]>

  export type CabinetAppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    serviceId?: boolean
    clientId?: boolean
    appointmentDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | CabinetServiceDefaultArgs<ExtArgs>
    client?: boolean | CabinetClientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetAppointment"]>

  export type CabinetAppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    serviceId?: boolean
    clientId?: boolean
    appointmentDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | CabinetServiceDefaultArgs<ExtArgs>
    client?: boolean | CabinetClientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cabinetAppointment"]>

  export type CabinetAppointmentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    serviceId?: boolean
    clientId?: boolean
    appointmentDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CabinetAppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "serviceId" | "clientId" | "appointmentDate" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["cabinetAppointment"]>
  export type CabinetAppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | CabinetServiceDefaultArgs<ExtArgs>
    client?: boolean | CabinetClientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type CabinetAppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | CabinetServiceDefaultArgs<ExtArgs>
    client?: boolean | CabinetClientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }
  export type CabinetAppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | CabinetServiceDefaultArgs<ExtArgs>
    client?: boolean | CabinetClientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantWebsiteDefaultArgs<ExtArgs>
  }

  export type $CabinetAppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CabinetAppointment"
    objects: {
      service: Prisma.$CabinetServicePayload<ExtArgs>
      client: Prisma.$CabinetClientPayload<ExtArgs>
      tenant: Prisma.$TenantWebsitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      serviceId: string
      clientId: string
      appointmentDate: Date
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cabinetAppointment"]>
    composites: {}
  }

  type CabinetAppointmentGetPayload<S extends boolean | null | undefined | CabinetAppointmentDefaultArgs> = $Result.GetResult<Prisma.$CabinetAppointmentPayload, S>

  type CabinetAppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CabinetAppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CabinetAppointmentCountAggregateInputType | true
    }

  export interface CabinetAppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CabinetAppointment'], meta: { name: 'CabinetAppointment' } }
    /**
     * Find zero or one CabinetAppointment that matches the filter.
     * @param {CabinetAppointmentFindUniqueArgs} args - Arguments to find a CabinetAppointment
     * @example
     * // Get one CabinetAppointment
     * const cabinetAppointment = await prisma.cabinetAppointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CabinetAppointmentFindUniqueArgs>(args: SelectSubset<T, CabinetAppointmentFindUniqueArgs<ExtArgs>>): Prisma__CabinetAppointmentClient<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CabinetAppointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CabinetAppointmentFindUniqueOrThrowArgs} args - Arguments to find a CabinetAppointment
     * @example
     * // Get one CabinetAppointment
     * const cabinetAppointment = await prisma.cabinetAppointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CabinetAppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CabinetAppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CabinetAppointmentClient<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetAppointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetAppointmentFindFirstArgs} args - Arguments to find a CabinetAppointment
     * @example
     * // Get one CabinetAppointment
     * const cabinetAppointment = await prisma.cabinetAppointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CabinetAppointmentFindFirstArgs>(args?: SelectSubset<T, CabinetAppointmentFindFirstArgs<ExtArgs>>): Prisma__CabinetAppointmentClient<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CabinetAppointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetAppointmentFindFirstOrThrowArgs} args - Arguments to find a CabinetAppointment
     * @example
     * // Get one CabinetAppointment
     * const cabinetAppointment = await prisma.cabinetAppointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CabinetAppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CabinetAppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CabinetAppointmentClient<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CabinetAppointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetAppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CabinetAppointments
     * const cabinetAppointments = await prisma.cabinetAppointment.findMany()
     * 
     * // Get first 10 CabinetAppointments
     * const cabinetAppointments = await prisma.cabinetAppointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cabinetAppointmentWithIdOnly = await prisma.cabinetAppointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CabinetAppointmentFindManyArgs>(args?: SelectSubset<T, CabinetAppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CabinetAppointment.
     * @param {CabinetAppointmentCreateArgs} args - Arguments to create a CabinetAppointment.
     * @example
     * // Create one CabinetAppointment
     * const CabinetAppointment = await prisma.cabinetAppointment.create({
     *   data: {
     *     // ... data to create a CabinetAppointment
     *   }
     * })
     * 
     */
    create<T extends CabinetAppointmentCreateArgs>(args: SelectSubset<T, CabinetAppointmentCreateArgs<ExtArgs>>): Prisma__CabinetAppointmentClient<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CabinetAppointments.
     * @param {CabinetAppointmentCreateManyArgs} args - Arguments to create many CabinetAppointments.
     * @example
     * // Create many CabinetAppointments
     * const cabinetAppointment = await prisma.cabinetAppointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CabinetAppointmentCreateManyArgs>(args?: SelectSubset<T, CabinetAppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CabinetAppointments and returns the data saved in the database.
     * @param {CabinetAppointmentCreateManyAndReturnArgs} args - Arguments to create many CabinetAppointments.
     * @example
     * // Create many CabinetAppointments
     * const cabinetAppointment = await prisma.cabinetAppointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CabinetAppointments and only return the `id`
     * const cabinetAppointmentWithIdOnly = await prisma.cabinetAppointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CabinetAppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CabinetAppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CabinetAppointment.
     * @param {CabinetAppointmentDeleteArgs} args - Arguments to delete one CabinetAppointment.
     * @example
     * // Delete one CabinetAppointment
     * const CabinetAppointment = await prisma.cabinetAppointment.delete({
     *   where: {
     *     // ... filter to delete one CabinetAppointment
     *   }
     * })
     * 
     */
    delete<T extends CabinetAppointmentDeleteArgs>(args: SelectSubset<T, CabinetAppointmentDeleteArgs<ExtArgs>>): Prisma__CabinetAppointmentClient<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CabinetAppointment.
     * @param {CabinetAppointmentUpdateArgs} args - Arguments to update one CabinetAppointment.
     * @example
     * // Update one CabinetAppointment
     * const cabinetAppointment = await prisma.cabinetAppointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CabinetAppointmentUpdateArgs>(args: SelectSubset<T, CabinetAppointmentUpdateArgs<ExtArgs>>): Prisma__CabinetAppointmentClient<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CabinetAppointments.
     * @param {CabinetAppointmentDeleteManyArgs} args - Arguments to filter CabinetAppointments to delete.
     * @example
     * // Delete a few CabinetAppointments
     * const { count } = await prisma.cabinetAppointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CabinetAppointmentDeleteManyArgs>(args?: SelectSubset<T, CabinetAppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetAppointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetAppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CabinetAppointments
     * const cabinetAppointment = await prisma.cabinetAppointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CabinetAppointmentUpdateManyArgs>(args: SelectSubset<T, CabinetAppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CabinetAppointments and returns the data updated in the database.
     * @param {CabinetAppointmentUpdateManyAndReturnArgs} args - Arguments to update many CabinetAppointments.
     * @example
     * // Update many CabinetAppointments
     * const cabinetAppointment = await prisma.cabinetAppointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CabinetAppointments and only return the `id`
     * const cabinetAppointmentWithIdOnly = await prisma.cabinetAppointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CabinetAppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, CabinetAppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CabinetAppointment.
     * @param {CabinetAppointmentUpsertArgs} args - Arguments to update or create a CabinetAppointment.
     * @example
     * // Update or create a CabinetAppointment
     * const cabinetAppointment = await prisma.cabinetAppointment.upsert({
     *   create: {
     *     // ... data to create a CabinetAppointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CabinetAppointment we want to update
     *   }
     * })
     */
    upsert<T extends CabinetAppointmentUpsertArgs>(args: SelectSubset<T, CabinetAppointmentUpsertArgs<ExtArgs>>): Prisma__CabinetAppointmentClient<$Result.GetResult<Prisma.$CabinetAppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CabinetAppointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetAppointmentCountArgs} args - Arguments to filter CabinetAppointments to count.
     * @example
     * // Count the number of CabinetAppointments
     * const count = await prisma.cabinetAppointment.count({
     *   where: {
     *     // ... the filter for the CabinetAppointments we want to count
     *   }
     * })
    **/
    count<T extends CabinetAppointmentCountArgs>(
      args?: Subset<T, CabinetAppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CabinetAppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CabinetAppointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetAppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CabinetAppointmentAggregateArgs>(args: Subset<T, CabinetAppointmentAggregateArgs>): Prisma.PrismaPromise<GetCabinetAppointmentAggregateType<T>>

    /**
     * Group by CabinetAppointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CabinetAppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CabinetAppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CabinetAppointmentGroupByArgs['orderBy'] }
        : { orderBy?: CabinetAppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CabinetAppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCabinetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CabinetAppointment model
   */
  readonly fields: CabinetAppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CabinetAppointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CabinetAppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends CabinetServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetServiceDefaultArgs<ExtArgs>>): Prisma__CabinetServiceClient<$Result.GetResult<Prisma.$CabinetServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends CabinetClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CabinetClientDefaultArgs<ExtArgs>>): Prisma__CabinetClientClient<$Result.GetResult<Prisma.$CabinetClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantWebsiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantWebsiteDefaultArgs<ExtArgs>>): Prisma__TenantWebsiteClient<$Result.GetResult<Prisma.$TenantWebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CabinetAppointment model
   */
  interface CabinetAppointmentFieldRefs {
    readonly id: FieldRef<"CabinetAppointment", 'String'>
    readonly tenantId: FieldRef<"CabinetAppointment", 'String'>
    readonly serviceId: FieldRef<"CabinetAppointment", 'String'>
    readonly clientId: FieldRef<"CabinetAppointment", 'String'>
    readonly appointmentDate: FieldRef<"CabinetAppointment", 'DateTime'>
    readonly status: FieldRef<"CabinetAppointment", 'String'>
    readonly notes: FieldRef<"CabinetAppointment", 'String'>
    readonly createdAt: FieldRef<"CabinetAppointment", 'DateTime'>
    readonly updatedAt: FieldRef<"CabinetAppointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CabinetAppointment findUnique
   */
  export type CabinetAppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which CabinetAppointment to fetch.
     */
    where: CabinetAppointmentWhereUniqueInput
  }

  /**
   * CabinetAppointment findUniqueOrThrow
   */
  export type CabinetAppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which CabinetAppointment to fetch.
     */
    where: CabinetAppointmentWhereUniqueInput
  }

  /**
   * CabinetAppointment findFirst
   */
  export type CabinetAppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which CabinetAppointment to fetch.
     */
    where?: CabinetAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetAppointments to fetch.
     */
    orderBy?: CabinetAppointmentOrderByWithRelationInput | CabinetAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetAppointments.
     */
    cursor?: CabinetAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetAppointments.
     */
    distinct?: CabinetAppointmentScalarFieldEnum | CabinetAppointmentScalarFieldEnum[]
  }

  /**
   * CabinetAppointment findFirstOrThrow
   */
  export type CabinetAppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which CabinetAppointment to fetch.
     */
    where?: CabinetAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetAppointments to fetch.
     */
    orderBy?: CabinetAppointmentOrderByWithRelationInput | CabinetAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CabinetAppointments.
     */
    cursor?: CabinetAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CabinetAppointments.
     */
    distinct?: CabinetAppointmentScalarFieldEnum | CabinetAppointmentScalarFieldEnum[]
  }

  /**
   * CabinetAppointment findMany
   */
  export type CabinetAppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which CabinetAppointments to fetch.
     */
    where?: CabinetAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CabinetAppointments to fetch.
     */
    orderBy?: CabinetAppointmentOrderByWithRelationInput | CabinetAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CabinetAppointments.
     */
    cursor?: CabinetAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CabinetAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CabinetAppointments.
     */
    skip?: number
    distinct?: CabinetAppointmentScalarFieldEnum | CabinetAppointmentScalarFieldEnum[]
  }

  /**
   * CabinetAppointment create
   */
  export type CabinetAppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CabinetAppointment.
     */
    data: XOR<CabinetAppointmentCreateInput, CabinetAppointmentUncheckedCreateInput>
  }

  /**
   * CabinetAppointment createMany
   */
  export type CabinetAppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CabinetAppointments.
     */
    data: CabinetAppointmentCreateManyInput | CabinetAppointmentCreateManyInput[]
  }

  /**
   * CabinetAppointment createManyAndReturn
   */
  export type CabinetAppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many CabinetAppointments.
     */
    data: CabinetAppointmentCreateManyInput | CabinetAppointmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetAppointment update
   */
  export type CabinetAppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CabinetAppointment.
     */
    data: XOR<CabinetAppointmentUpdateInput, CabinetAppointmentUncheckedUpdateInput>
    /**
     * Choose, which CabinetAppointment to update.
     */
    where: CabinetAppointmentWhereUniqueInput
  }

  /**
   * CabinetAppointment updateMany
   */
  export type CabinetAppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CabinetAppointments.
     */
    data: XOR<CabinetAppointmentUpdateManyMutationInput, CabinetAppointmentUncheckedUpdateManyInput>
    /**
     * Filter which CabinetAppointments to update
     */
    where?: CabinetAppointmentWhereInput
    /**
     * Limit how many CabinetAppointments to update.
     */
    limit?: number
  }

  /**
   * CabinetAppointment updateManyAndReturn
   */
  export type CabinetAppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * The data used to update CabinetAppointments.
     */
    data: XOR<CabinetAppointmentUpdateManyMutationInput, CabinetAppointmentUncheckedUpdateManyInput>
    /**
     * Filter which CabinetAppointments to update
     */
    where?: CabinetAppointmentWhereInput
    /**
     * Limit how many CabinetAppointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CabinetAppointment upsert
   */
  export type CabinetAppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CabinetAppointment to update in case it exists.
     */
    where: CabinetAppointmentWhereUniqueInput
    /**
     * In case the CabinetAppointment found by the `where` argument doesn't exist, create a new CabinetAppointment with this data.
     */
    create: XOR<CabinetAppointmentCreateInput, CabinetAppointmentUncheckedCreateInput>
    /**
     * In case the CabinetAppointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CabinetAppointmentUpdateInput, CabinetAppointmentUncheckedUpdateInput>
  }

  /**
   * CabinetAppointment delete
   */
  export type CabinetAppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
    /**
     * Filter which CabinetAppointment to delete.
     */
    where: CabinetAppointmentWhereUniqueInput
  }

  /**
   * CabinetAppointment deleteMany
   */
  export type CabinetAppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CabinetAppointments to delete
     */
    where?: CabinetAppointmentWhereInput
    /**
     * Limit how many CabinetAppointments to delete.
     */
    limit?: number
  }

  /**
   * CabinetAppointment without action
   */
  export type CabinetAppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CabinetAppointment
     */
    select?: CabinetAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CabinetAppointment
     */
    omit?: CabinetAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CabinetAppointmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    companyName: 'companyName',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ChatSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatSessionScalarFieldEnum = (typeof ChatSessionScalarFieldEnum)[keyof typeof ChatSessionScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    role: 'role',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    status: 'status',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const UserServiceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serviceId: 'serviceId',
    notify: 'notify',
    selectedAt: 'selectedAt'
  };

  export type UserServiceScalarFieldEnum = (typeof UserServiceScalarFieldEnum)[keyof typeof UserServiceScalarFieldEnum]


  export const PasswordResetScalarFieldEnum: {
    id: 'id',
    email: 'email',
    code: 'code',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


  export const TenantWebsiteScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    userId: 'userId',
    serviceId: 'serviceId',
    siteName: 'siteName',
    description: 'description',
    logo: 'logo',
    coverImage: 'coverImage',
    primaryColor: 'primaryColor',
    config: 'config',
    designTemplate: 'designTemplate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantWebsiteScalarFieldEnum = (typeof TenantWebsiteScalarFieldEnum)[keyof typeof TenantWebsiteScalarFieldEnum]


  export const RestaurantCategoryScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    order: 'order',
    isActive: 'isActive'
  };

  export type RestaurantCategoryScalarFieldEnum = (typeof RestaurantCategoryScalarFieldEnum)[keyof typeof RestaurantCategoryScalarFieldEnum]


  export const RestaurantDishScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    description: 'description',
    price: 'price',
    image: 'image',
    isActive: 'isActive',
    order: 'order'
  };

  export type RestaurantDishScalarFieldEnum = (typeof RestaurantDishScalarFieldEnum)[keyof typeof RestaurantDishScalarFieldEnum]


  export const RestaurantTableScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    number: 'number',
    capacity: 'capacity',
    isActive: 'isActive',
    waiterId: 'waiterId'
  };

  export type RestaurantTableScalarFieldEnum = (typeof RestaurantTableScalarFieldEnum)[keyof typeof RestaurantTableScalarFieldEnum]


  export const RestaurantWaiterScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    pin: 'pin',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type RestaurantWaiterScalarFieldEnum = (typeof RestaurantWaiterScalarFieldEnum)[keyof typeof RestaurantWaiterScalarFieldEnum]


  export const RestaurantOrderScalarFieldEnum: {
    id: 'id',
    tableId: 'tableId',
    status: 'status',
    totalAmount: 'totalAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RestaurantOrderScalarFieldEnum = (typeof RestaurantOrderScalarFieldEnum)[keyof typeof RestaurantOrderScalarFieldEnum]


  export const RestaurantOrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    dishId: 'dishId',
    name: 'name',
    price: 'price',
    quantity: 'quantity'
  };

  export type RestaurantOrderItemScalarFieldEnum = (typeof RestaurantOrderItemScalarFieldEnum)[keyof typeof RestaurantOrderItemScalarFieldEnum]


  export const CabinetServiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    price: 'price',
    duration: 'duration',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type CabinetServiceScalarFieldEnum = (typeof CabinetServiceScalarFieldEnum)[keyof typeof CabinetServiceScalarFieldEnum]


  export const CabinetClientScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CabinetClientScalarFieldEnum = (typeof CabinetClientScalarFieldEnum)[keyof typeof CabinetClientScalarFieldEnum]


  export const CabinetAppointmentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    serviceId: 'serviceId',
    clientId: 'clientId',
    appointmentDate: 'appointmentDate',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CabinetAppointmentScalarFieldEnum = (typeof CabinetAppointmentScalarFieldEnum)[keyof typeof CabinetAppointmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    companyName?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    services?: UserServiceListRelationFilter
    notifications?: NotificationListRelationFilter
    websites?: TenantWebsiteListRelationFilter
    chatSessions?: ChatSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    companyName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    services?: UserServiceOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    websites?: TenantWebsiteOrderByRelationAggregateInput
    chatSessions?: ChatSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    companyName?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    services?: UserServiceListRelationFilter
    notifications?: NotificationListRelationFilter
    websites?: TenantWebsiteListRelationFilter
    chatSessions?: ChatSessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    companyName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    companyName?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ChatSessionWhereInput = {
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    id?: StringFilter<"ChatSession"> | string
    userId?: StringFilter<"ChatSession"> | string
    title?: StringNullableFilter<"ChatSession"> | string | null
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    messages?: ChatMessageListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChatSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messages?: ChatMessageOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type ChatSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    userId?: StringFilter<"ChatSession"> | string
    title?: StringNullableFilter<"ChatSession"> | string | null
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    messages?: ChatMessageListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ChatSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatSessionCountOrderByAggregateInput
    _max?: ChatSessionMaxOrderByAggregateInput
    _min?: ChatSessionMinOrderByAggregateInput
  }

  export type ChatSessionScalarWhereWithAggregatesInput = {
    AND?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    OR?: ChatSessionScalarWhereWithAggregatesInput[]
    NOT?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatSession"> | string
    userId?: StringWithAggregatesFilter<"ChatSession"> | string
    title?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    sessionId?: StringFilter<"ChatMessage"> | string
    role?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    session?: XOR<ChatSessionScalarRelationFilter, ChatSessionWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    session?: ChatSessionOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    sessionId?: StringFilter<"ChatMessage"> | string
    role?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    session?: XOR<ChatSessionScalarRelationFilter, ChatSessionWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    sessionId?: StringWithAggregatesFilter<"ChatMessage"> | string
    role?: StringWithAggregatesFilter<"ChatMessage"> | string
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    status?: StringFilter<"Service"> | string
    category?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    users?: UserServiceListRelationFilter
    websites?: TenantWebsiteListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: UserServiceOrderByRelationAggregateInput
    websites?: TenantWebsiteOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    status?: StringFilter<"Service"> | string
    category?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    users?: UserServiceListRelationFilter
    websites?: TenantWebsiteListRelationFilter
  }, "id" | "slug">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    slug?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    status?: StringWithAggregatesFilter<"Service"> | string
    category?: StringNullableWithAggregatesFilter<"Service"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type UserServiceWhereInput = {
    AND?: UserServiceWhereInput | UserServiceWhereInput[]
    OR?: UserServiceWhereInput[]
    NOT?: UserServiceWhereInput | UserServiceWhereInput[]
    id?: StringFilter<"UserService"> | string
    userId?: StringFilter<"UserService"> | string
    serviceId?: StringFilter<"UserService"> | string
    notify?: BoolFilter<"UserService"> | boolean
    selectedAt?: DateTimeFilter<"UserService"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type UserServiceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    notify?: SortOrder
    selectedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type UserServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_serviceId?: UserServiceUserIdServiceIdCompoundUniqueInput
    AND?: UserServiceWhereInput | UserServiceWhereInput[]
    OR?: UserServiceWhereInput[]
    NOT?: UserServiceWhereInput | UserServiceWhereInput[]
    userId?: StringFilter<"UserService"> | string
    serviceId?: StringFilter<"UserService"> | string
    notify?: BoolFilter<"UserService"> | boolean
    selectedAt?: DateTimeFilter<"UserService"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id" | "userId_serviceId">

  export type UserServiceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    notify?: SortOrder
    selectedAt?: SortOrder
    _count?: UserServiceCountOrderByAggregateInput
    _max?: UserServiceMaxOrderByAggregateInput
    _min?: UserServiceMinOrderByAggregateInput
  }

  export type UserServiceScalarWhereWithAggregatesInput = {
    AND?: UserServiceScalarWhereWithAggregatesInput | UserServiceScalarWhereWithAggregatesInput[]
    OR?: UserServiceScalarWhereWithAggregatesInput[]
    NOT?: UserServiceScalarWhereWithAggregatesInput | UserServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserService"> | string
    userId?: StringWithAggregatesFilter<"UserService"> | string
    serviceId?: StringWithAggregatesFilter<"UserService"> | string
    notify?: BoolWithAggregatesFilter<"UserService"> | boolean
    selectedAt?: DateTimeWithAggregatesFilter<"UserService"> | Date | string
  }

  export type PasswordResetWhereInput = {
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    id?: StringFilter<"PasswordReset"> | string
    email?: StringFilter<"PasswordReset"> | string
    code?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
  }

  export type PasswordResetOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    email?: StringFilter<"PasswordReset"> | string
    code?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
  }, "id">

  export type PasswordResetOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetCountOrderByAggregateInput
    _max?: PasswordResetMaxOrderByAggregateInput
    _min?: PasswordResetMinOrderByAggregateInput
  }

  export type PasswordResetScalarWhereWithAggregatesInput = {
    AND?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    OR?: PasswordResetScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordReset"> | string
    email?: StringWithAggregatesFilter<"PasswordReset"> | string
    code?: StringWithAggregatesFilter<"PasswordReset"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
  }

  export type TenantWebsiteWhereInput = {
    AND?: TenantWebsiteWhereInput | TenantWebsiteWhereInput[]
    OR?: TenantWebsiteWhereInput[]
    NOT?: TenantWebsiteWhereInput | TenantWebsiteWhereInput[]
    id?: StringFilter<"TenantWebsite"> | string
    slug?: StringFilter<"TenantWebsite"> | string
    userId?: StringFilter<"TenantWebsite"> | string
    serviceId?: StringFilter<"TenantWebsite"> | string
    siteName?: StringFilter<"TenantWebsite"> | string
    description?: StringNullableFilter<"TenantWebsite"> | string | null
    logo?: StringNullableFilter<"TenantWebsite"> | string | null
    coverImage?: StringNullableFilter<"TenantWebsite"> | string | null
    primaryColor?: StringFilter<"TenantWebsite"> | string
    config?: StringFilter<"TenantWebsite"> | string
    designTemplate?: StringFilter<"TenantWebsite"> | string
    isActive?: BoolFilter<"TenantWebsite"> | boolean
    createdAt?: DateTimeFilter<"TenantWebsite"> | Date | string
    updatedAt?: DateTimeFilter<"TenantWebsite"> | Date | string
    categories?: RestaurantCategoryListRelationFilter
    tables?: RestaurantTableListRelationFilter
    waiters?: RestaurantWaiterListRelationFilter
    cabinetServices?: CabinetServiceListRelationFilter
    cabinetClients?: CabinetClientListRelationFilter
    cabinetAppointments?: CabinetAppointmentListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type TenantWebsiteOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    siteName?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    primaryColor?: SortOrder
    config?: SortOrder
    designTemplate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categories?: RestaurantCategoryOrderByRelationAggregateInput
    tables?: RestaurantTableOrderByRelationAggregateInput
    waiters?: RestaurantWaiterOrderByRelationAggregateInput
    cabinetServices?: CabinetServiceOrderByRelationAggregateInput
    cabinetClients?: CabinetClientOrderByRelationAggregateInput
    cabinetAppointments?: CabinetAppointmentOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type TenantWebsiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TenantWebsiteWhereInput | TenantWebsiteWhereInput[]
    OR?: TenantWebsiteWhereInput[]
    NOT?: TenantWebsiteWhereInput | TenantWebsiteWhereInput[]
    userId?: StringFilter<"TenantWebsite"> | string
    serviceId?: StringFilter<"TenantWebsite"> | string
    siteName?: StringFilter<"TenantWebsite"> | string
    description?: StringNullableFilter<"TenantWebsite"> | string | null
    logo?: StringNullableFilter<"TenantWebsite"> | string | null
    coverImage?: StringNullableFilter<"TenantWebsite"> | string | null
    primaryColor?: StringFilter<"TenantWebsite"> | string
    config?: StringFilter<"TenantWebsite"> | string
    designTemplate?: StringFilter<"TenantWebsite"> | string
    isActive?: BoolFilter<"TenantWebsite"> | boolean
    createdAt?: DateTimeFilter<"TenantWebsite"> | Date | string
    updatedAt?: DateTimeFilter<"TenantWebsite"> | Date | string
    categories?: RestaurantCategoryListRelationFilter
    tables?: RestaurantTableListRelationFilter
    waiters?: RestaurantWaiterListRelationFilter
    cabinetServices?: CabinetServiceListRelationFilter
    cabinetClients?: CabinetClientListRelationFilter
    cabinetAppointments?: CabinetAppointmentListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id" | "slug">

  export type TenantWebsiteOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    siteName?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    primaryColor?: SortOrder
    config?: SortOrder
    designTemplate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantWebsiteCountOrderByAggregateInput
    _max?: TenantWebsiteMaxOrderByAggregateInput
    _min?: TenantWebsiteMinOrderByAggregateInput
  }

  export type TenantWebsiteScalarWhereWithAggregatesInput = {
    AND?: TenantWebsiteScalarWhereWithAggregatesInput | TenantWebsiteScalarWhereWithAggregatesInput[]
    OR?: TenantWebsiteScalarWhereWithAggregatesInput[]
    NOT?: TenantWebsiteScalarWhereWithAggregatesInput | TenantWebsiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantWebsite"> | string
    slug?: StringWithAggregatesFilter<"TenantWebsite"> | string
    userId?: StringWithAggregatesFilter<"TenantWebsite"> | string
    serviceId?: StringWithAggregatesFilter<"TenantWebsite"> | string
    siteName?: StringWithAggregatesFilter<"TenantWebsite"> | string
    description?: StringNullableWithAggregatesFilter<"TenantWebsite"> | string | null
    logo?: StringNullableWithAggregatesFilter<"TenantWebsite"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"TenantWebsite"> | string | null
    primaryColor?: StringWithAggregatesFilter<"TenantWebsite"> | string
    config?: StringWithAggregatesFilter<"TenantWebsite"> | string
    designTemplate?: StringWithAggregatesFilter<"TenantWebsite"> | string
    isActive?: BoolWithAggregatesFilter<"TenantWebsite"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TenantWebsite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantWebsite"> | Date | string
  }

  export type RestaurantCategoryWhereInput = {
    AND?: RestaurantCategoryWhereInput | RestaurantCategoryWhereInput[]
    OR?: RestaurantCategoryWhereInput[]
    NOT?: RestaurantCategoryWhereInput | RestaurantCategoryWhereInput[]
    id?: StringFilter<"RestaurantCategory"> | string
    tenantId?: StringFilter<"RestaurantCategory"> | string
    name?: StringFilter<"RestaurantCategory"> | string
    order?: IntFilter<"RestaurantCategory"> | number
    isActive?: BoolFilter<"RestaurantCategory"> | boolean
    dishes?: RestaurantDishListRelationFilter
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }

  export type RestaurantCategoryOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    dishes?: RestaurantDishOrderByRelationAggregateInput
    tenant?: TenantWebsiteOrderByWithRelationInput
  }

  export type RestaurantCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestaurantCategoryWhereInput | RestaurantCategoryWhereInput[]
    OR?: RestaurantCategoryWhereInput[]
    NOT?: RestaurantCategoryWhereInput | RestaurantCategoryWhereInput[]
    tenantId?: StringFilter<"RestaurantCategory"> | string
    name?: StringFilter<"RestaurantCategory"> | string
    order?: IntFilter<"RestaurantCategory"> | number
    isActive?: BoolFilter<"RestaurantCategory"> | boolean
    dishes?: RestaurantDishListRelationFilter
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }, "id">

  export type RestaurantCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    _count?: RestaurantCategoryCountOrderByAggregateInput
    _avg?: RestaurantCategoryAvgOrderByAggregateInput
    _max?: RestaurantCategoryMaxOrderByAggregateInput
    _min?: RestaurantCategoryMinOrderByAggregateInput
    _sum?: RestaurantCategorySumOrderByAggregateInput
  }

  export type RestaurantCategoryScalarWhereWithAggregatesInput = {
    AND?: RestaurantCategoryScalarWhereWithAggregatesInput | RestaurantCategoryScalarWhereWithAggregatesInput[]
    OR?: RestaurantCategoryScalarWhereWithAggregatesInput[]
    NOT?: RestaurantCategoryScalarWhereWithAggregatesInput | RestaurantCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RestaurantCategory"> | string
    tenantId?: StringWithAggregatesFilter<"RestaurantCategory"> | string
    name?: StringWithAggregatesFilter<"RestaurantCategory"> | string
    order?: IntWithAggregatesFilter<"RestaurantCategory"> | number
    isActive?: BoolWithAggregatesFilter<"RestaurantCategory"> | boolean
  }

  export type RestaurantDishWhereInput = {
    AND?: RestaurantDishWhereInput | RestaurantDishWhereInput[]
    OR?: RestaurantDishWhereInput[]
    NOT?: RestaurantDishWhereInput | RestaurantDishWhereInput[]
    id?: StringFilter<"RestaurantDish"> | string
    categoryId?: StringFilter<"RestaurantDish"> | string
    name?: StringFilter<"RestaurantDish"> | string
    description?: StringNullableFilter<"RestaurantDish"> | string | null
    price?: FloatFilter<"RestaurantDish"> | number
    image?: StringNullableFilter<"RestaurantDish"> | string | null
    isActive?: BoolFilter<"RestaurantDish"> | boolean
    order?: IntFilter<"RestaurantDish"> | number
    category?: XOR<RestaurantCategoryScalarRelationFilter, RestaurantCategoryWhereInput>
  }

  export type RestaurantDishOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    image?: SortOrderInput | SortOrder
    isActive?: SortOrder
    order?: SortOrder
    category?: RestaurantCategoryOrderByWithRelationInput
  }

  export type RestaurantDishWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestaurantDishWhereInput | RestaurantDishWhereInput[]
    OR?: RestaurantDishWhereInput[]
    NOT?: RestaurantDishWhereInput | RestaurantDishWhereInput[]
    categoryId?: StringFilter<"RestaurantDish"> | string
    name?: StringFilter<"RestaurantDish"> | string
    description?: StringNullableFilter<"RestaurantDish"> | string | null
    price?: FloatFilter<"RestaurantDish"> | number
    image?: StringNullableFilter<"RestaurantDish"> | string | null
    isActive?: BoolFilter<"RestaurantDish"> | boolean
    order?: IntFilter<"RestaurantDish"> | number
    category?: XOR<RestaurantCategoryScalarRelationFilter, RestaurantCategoryWhereInput>
  }, "id">

  export type RestaurantDishOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    image?: SortOrderInput | SortOrder
    isActive?: SortOrder
    order?: SortOrder
    _count?: RestaurantDishCountOrderByAggregateInput
    _avg?: RestaurantDishAvgOrderByAggregateInput
    _max?: RestaurantDishMaxOrderByAggregateInput
    _min?: RestaurantDishMinOrderByAggregateInput
    _sum?: RestaurantDishSumOrderByAggregateInput
  }

  export type RestaurantDishScalarWhereWithAggregatesInput = {
    AND?: RestaurantDishScalarWhereWithAggregatesInput | RestaurantDishScalarWhereWithAggregatesInput[]
    OR?: RestaurantDishScalarWhereWithAggregatesInput[]
    NOT?: RestaurantDishScalarWhereWithAggregatesInput | RestaurantDishScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RestaurantDish"> | string
    categoryId?: StringWithAggregatesFilter<"RestaurantDish"> | string
    name?: StringWithAggregatesFilter<"RestaurantDish"> | string
    description?: StringNullableWithAggregatesFilter<"RestaurantDish"> | string | null
    price?: FloatWithAggregatesFilter<"RestaurantDish"> | number
    image?: StringNullableWithAggregatesFilter<"RestaurantDish"> | string | null
    isActive?: BoolWithAggregatesFilter<"RestaurantDish"> | boolean
    order?: IntWithAggregatesFilter<"RestaurantDish"> | number
  }

  export type RestaurantTableWhereInput = {
    AND?: RestaurantTableWhereInput | RestaurantTableWhereInput[]
    OR?: RestaurantTableWhereInput[]
    NOT?: RestaurantTableWhereInput | RestaurantTableWhereInput[]
    id?: StringFilter<"RestaurantTable"> | string
    tenantId?: StringFilter<"RestaurantTable"> | string
    number?: StringFilter<"RestaurantTable"> | string
    capacity?: IntNullableFilter<"RestaurantTable"> | number | null
    isActive?: BoolFilter<"RestaurantTable"> | boolean
    waiterId?: StringNullableFilter<"RestaurantTable"> | string | null
    orders?: RestaurantOrderListRelationFilter
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
    waiter?: XOR<RestaurantWaiterNullableScalarRelationFilter, RestaurantWaiterWhereInput> | null
  }

  export type RestaurantTableOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    number?: SortOrder
    capacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    waiterId?: SortOrderInput | SortOrder
    orders?: RestaurantOrderOrderByRelationAggregateInput
    tenant?: TenantWebsiteOrderByWithRelationInput
    waiter?: RestaurantWaiterOrderByWithRelationInput
  }

  export type RestaurantTableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_number?: RestaurantTableTenantIdNumberCompoundUniqueInput
    AND?: RestaurantTableWhereInput | RestaurantTableWhereInput[]
    OR?: RestaurantTableWhereInput[]
    NOT?: RestaurantTableWhereInput | RestaurantTableWhereInput[]
    tenantId?: StringFilter<"RestaurantTable"> | string
    number?: StringFilter<"RestaurantTable"> | string
    capacity?: IntNullableFilter<"RestaurantTable"> | number | null
    isActive?: BoolFilter<"RestaurantTable"> | boolean
    waiterId?: StringNullableFilter<"RestaurantTable"> | string | null
    orders?: RestaurantOrderListRelationFilter
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
    waiter?: XOR<RestaurantWaiterNullableScalarRelationFilter, RestaurantWaiterWhereInput> | null
  }, "id" | "tenantId_number">

  export type RestaurantTableOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    number?: SortOrder
    capacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    waiterId?: SortOrderInput | SortOrder
    _count?: RestaurantTableCountOrderByAggregateInput
    _avg?: RestaurantTableAvgOrderByAggregateInput
    _max?: RestaurantTableMaxOrderByAggregateInput
    _min?: RestaurantTableMinOrderByAggregateInput
    _sum?: RestaurantTableSumOrderByAggregateInput
  }

  export type RestaurantTableScalarWhereWithAggregatesInput = {
    AND?: RestaurantTableScalarWhereWithAggregatesInput | RestaurantTableScalarWhereWithAggregatesInput[]
    OR?: RestaurantTableScalarWhereWithAggregatesInput[]
    NOT?: RestaurantTableScalarWhereWithAggregatesInput | RestaurantTableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RestaurantTable"> | string
    tenantId?: StringWithAggregatesFilter<"RestaurantTable"> | string
    number?: StringWithAggregatesFilter<"RestaurantTable"> | string
    capacity?: IntNullableWithAggregatesFilter<"RestaurantTable"> | number | null
    isActive?: BoolWithAggregatesFilter<"RestaurantTable"> | boolean
    waiterId?: StringNullableWithAggregatesFilter<"RestaurantTable"> | string | null
  }

  export type RestaurantWaiterWhereInput = {
    AND?: RestaurantWaiterWhereInput | RestaurantWaiterWhereInput[]
    OR?: RestaurantWaiterWhereInput[]
    NOT?: RestaurantWaiterWhereInput | RestaurantWaiterWhereInput[]
    id?: StringFilter<"RestaurantWaiter"> | string
    tenantId?: StringFilter<"RestaurantWaiter"> | string
    name?: StringFilter<"RestaurantWaiter"> | string
    pin?: StringFilter<"RestaurantWaiter"> | string
    isActive?: BoolFilter<"RestaurantWaiter"> | boolean
    createdAt?: DateTimeFilter<"RestaurantWaiter"> | Date | string
    tables?: RestaurantTableListRelationFilter
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }

  export type RestaurantWaiterOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    pin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    tables?: RestaurantTableOrderByRelationAggregateInput
    tenant?: TenantWebsiteOrderByWithRelationInput
  }

  export type RestaurantWaiterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestaurantWaiterWhereInput | RestaurantWaiterWhereInput[]
    OR?: RestaurantWaiterWhereInput[]
    NOT?: RestaurantWaiterWhereInput | RestaurantWaiterWhereInput[]
    tenantId?: StringFilter<"RestaurantWaiter"> | string
    name?: StringFilter<"RestaurantWaiter"> | string
    pin?: StringFilter<"RestaurantWaiter"> | string
    isActive?: BoolFilter<"RestaurantWaiter"> | boolean
    createdAt?: DateTimeFilter<"RestaurantWaiter"> | Date | string
    tables?: RestaurantTableListRelationFilter
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }, "id">

  export type RestaurantWaiterOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    pin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: RestaurantWaiterCountOrderByAggregateInput
    _max?: RestaurantWaiterMaxOrderByAggregateInput
    _min?: RestaurantWaiterMinOrderByAggregateInput
  }

  export type RestaurantWaiterScalarWhereWithAggregatesInput = {
    AND?: RestaurantWaiterScalarWhereWithAggregatesInput | RestaurantWaiterScalarWhereWithAggregatesInput[]
    OR?: RestaurantWaiterScalarWhereWithAggregatesInput[]
    NOT?: RestaurantWaiterScalarWhereWithAggregatesInput | RestaurantWaiterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RestaurantWaiter"> | string
    tenantId?: StringWithAggregatesFilter<"RestaurantWaiter"> | string
    name?: StringWithAggregatesFilter<"RestaurantWaiter"> | string
    pin?: StringWithAggregatesFilter<"RestaurantWaiter"> | string
    isActive?: BoolWithAggregatesFilter<"RestaurantWaiter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RestaurantWaiter"> | Date | string
  }

  export type RestaurantOrderWhereInput = {
    AND?: RestaurantOrderWhereInput | RestaurantOrderWhereInput[]
    OR?: RestaurantOrderWhereInput[]
    NOT?: RestaurantOrderWhereInput | RestaurantOrderWhereInput[]
    id?: StringFilter<"RestaurantOrder"> | string
    tableId?: StringFilter<"RestaurantOrder"> | string
    status?: StringFilter<"RestaurantOrder"> | string
    totalAmount?: FloatFilter<"RestaurantOrder"> | number
    createdAt?: DateTimeFilter<"RestaurantOrder"> | Date | string
    updatedAt?: DateTimeFilter<"RestaurantOrder"> | Date | string
    items?: RestaurantOrderItemListRelationFilter
    table?: XOR<RestaurantTableScalarRelationFilter, RestaurantTableWhereInput>
  }

  export type RestaurantOrderOrderByWithRelationInput = {
    id?: SortOrder
    tableId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: RestaurantOrderItemOrderByRelationAggregateInput
    table?: RestaurantTableOrderByWithRelationInput
  }

  export type RestaurantOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestaurantOrderWhereInput | RestaurantOrderWhereInput[]
    OR?: RestaurantOrderWhereInput[]
    NOT?: RestaurantOrderWhereInput | RestaurantOrderWhereInput[]
    tableId?: StringFilter<"RestaurantOrder"> | string
    status?: StringFilter<"RestaurantOrder"> | string
    totalAmount?: FloatFilter<"RestaurantOrder"> | number
    createdAt?: DateTimeFilter<"RestaurantOrder"> | Date | string
    updatedAt?: DateTimeFilter<"RestaurantOrder"> | Date | string
    items?: RestaurantOrderItemListRelationFilter
    table?: XOR<RestaurantTableScalarRelationFilter, RestaurantTableWhereInput>
  }, "id">

  export type RestaurantOrderOrderByWithAggregationInput = {
    id?: SortOrder
    tableId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RestaurantOrderCountOrderByAggregateInput
    _avg?: RestaurantOrderAvgOrderByAggregateInput
    _max?: RestaurantOrderMaxOrderByAggregateInput
    _min?: RestaurantOrderMinOrderByAggregateInput
    _sum?: RestaurantOrderSumOrderByAggregateInput
  }

  export type RestaurantOrderScalarWhereWithAggregatesInput = {
    AND?: RestaurantOrderScalarWhereWithAggregatesInput | RestaurantOrderScalarWhereWithAggregatesInput[]
    OR?: RestaurantOrderScalarWhereWithAggregatesInput[]
    NOT?: RestaurantOrderScalarWhereWithAggregatesInput | RestaurantOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RestaurantOrder"> | string
    tableId?: StringWithAggregatesFilter<"RestaurantOrder"> | string
    status?: StringWithAggregatesFilter<"RestaurantOrder"> | string
    totalAmount?: FloatWithAggregatesFilter<"RestaurantOrder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RestaurantOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RestaurantOrder"> | Date | string
  }

  export type RestaurantOrderItemWhereInput = {
    AND?: RestaurantOrderItemWhereInput | RestaurantOrderItemWhereInput[]
    OR?: RestaurantOrderItemWhereInput[]
    NOT?: RestaurantOrderItemWhereInput | RestaurantOrderItemWhereInput[]
    id?: StringFilter<"RestaurantOrderItem"> | string
    orderId?: StringFilter<"RestaurantOrderItem"> | string
    dishId?: StringFilter<"RestaurantOrderItem"> | string
    name?: StringFilter<"RestaurantOrderItem"> | string
    price?: FloatFilter<"RestaurantOrderItem"> | number
    quantity?: IntFilter<"RestaurantOrderItem"> | number
    order?: XOR<RestaurantOrderScalarRelationFilter, RestaurantOrderWhereInput>
  }

  export type RestaurantOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    dishId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    order?: RestaurantOrderOrderByWithRelationInput
  }

  export type RestaurantOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestaurantOrderItemWhereInput | RestaurantOrderItemWhereInput[]
    OR?: RestaurantOrderItemWhereInput[]
    NOT?: RestaurantOrderItemWhereInput | RestaurantOrderItemWhereInput[]
    orderId?: StringFilter<"RestaurantOrderItem"> | string
    dishId?: StringFilter<"RestaurantOrderItem"> | string
    name?: StringFilter<"RestaurantOrderItem"> | string
    price?: FloatFilter<"RestaurantOrderItem"> | number
    quantity?: IntFilter<"RestaurantOrderItem"> | number
    order?: XOR<RestaurantOrderScalarRelationFilter, RestaurantOrderWhereInput>
  }, "id">

  export type RestaurantOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    dishId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    _count?: RestaurantOrderItemCountOrderByAggregateInput
    _avg?: RestaurantOrderItemAvgOrderByAggregateInput
    _max?: RestaurantOrderItemMaxOrderByAggregateInput
    _min?: RestaurantOrderItemMinOrderByAggregateInput
    _sum?: RestaurantOrderItemSumOrderByAggregateInput
  }

  export type RestaurantOrderItemScalarWhereWithAggregatesInput = {
    AND?: RestaurantOrderItemScalarWhereWithAggregatesInput | RestaurantOrderItemScalarWhereWithAggregatesInput[]
    OR?: RestaurantOrderItemScalarWhereWithAggregatesInput[]
    NOT?: RestaurantOrderItemScalarWhereWithAggregatesInput | RestaurantOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RestaurantOrderItem"> | string
    orderId?: StringWithAggregatesFilter<"RestaurantOrderItem"> | string
    dishId?: StringWithAggregatesFilter<"RestaurantOrderItem"> | string
    name?: StringWithAggregatesFilter<"RestaurantOrderItem"> | string
    price?: FloatWithAggregatesFilter<"RestaurantOrderItem"> | number
    quantity?: IntWithAggregatesFilter<"RestaurantOrderItem"> | number
  }

  export type CabinetServiceWhereInput = {
    AND?: CabinetServiceWhereInput | CabinetServiceWhereInput[]
    OR?: CabinetServiceWhereInput[]
    NOT?: CabinetServiceWhereInput | CabinetServiceWhereInput[]
    id?: StringFilter<"CabinetService"> | string
    tenantId?: StringFilter<"CabinetService"> | string
    name?: StringFilter<"CabinetService"> | string
    description?: StringNullableFilter<"CabinetService"> | string | null
    price?: FloatFilter<"CabinetService"> | number
    duration?: IntFilter<"CabinetService"> | number
    isActive?: BoolFilter<"CabinetService"> | boolean
    createdAt?: DateTimeFilter<"CabinetService"> | Date | string
    appointments?: CabinetAppointmentListRelationFilter
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }

  export type CabinetServiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    appointments?: CabinetAppointmentOrderByRelationAggregateInput
    tenant?: TenantWebsiteOrderByWithRelationInput
  }

  export type CabinetServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CabinetServiceWhereInput | CabinetServiceWhereInput[]
    OR?: CabinetServiceWhereInput[]
    NOT?: CabinetServiceWhereInput | CabinetServiceWhereInput[]
    tenantId?: StringFilter<"CabinetService"> | string
    name?: StringFilter<"CabinetService"> | string
    description?: StringNullableFilter<"CabinetService"> | string | null
    price?: FloatFilter<"CabinetService"> | number
    duration?: IntFilter<"CabinetService"> | number
    isActive?: BoolFilter<"CabinetService"> | boolean
    createdAt?: DateTimeFilter<"CabinetService"> | Date | string
    appointments?: CabinetAppointmentListRelationFilter
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }, "id">

  export type CabinetServiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: CabinetServiceCountOrderByAggregateInput
    _avg?: CabinetServiceAvgOrderByAggregateInput
    _max?: CabinetServiceMaxOrderByAggregateInput
    _min?: CabinetServiceMinOrderByAggregateInput
    _sum?: CabinetServiceSumOrderByAggregateInput
  }

  export type CabinetServiceScalarWhereWithAggregatesInput = {
    AND?: CabinetServiceScalarWhereWithAggregatesInput | CabinetServiceScalarWhereWithAggregatesInput[]
    OR?: CabinetServiceScalarWhereWithAggregatesInput[]
    NOT?: CabinetServiceScalarWhereWithAggregatesInput | CabinetServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CabinetService"> | string
    tenantId?: StringWithAggregatesFilter<"CabinetService"> | string
    name?: StringWithAggregatesFilter<"CabinetService"> | string
    description?: StringNullableWithAggregatesFilter<"CabinetService"> | string | null
    price?: FloatWithAggregatesFilter<"CabinetService"> | number
    duration?: IntWithAggregatesFilter<"CabinetService"> | number
    isActive?: BoolWithAggregatesFilter<"CabinetService"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CabinetService"> | Date | string
  }

  export type CabinetClientWhereInput = {
    AND?: CabinetClientWhereInput | CabinetClientWhereInput[]
    OR?: CabinetClientWhereInput[]
    NOT?: CabinetClientWhereInput | CabinetClientWhereInput[]
    id?: StringFilter<"CabinetClient"> | string
    tenantId?: StringFilter<"CabinetClient"> | string
    name?: StringFilter<"CabinetClient"> | string
    email?: StringNullableFilter<"CabinetClient"> | string | null
    phone?: StringNullableFilter<"CabinetClient"> | string | null
    notes?: StringNullableFilter<"CabinetClient"> | string | null
    createdAt?: DateTimeFilter<"CabinetClient"> | Date | string
    updatedAt?: DateTimeFilter<"CabinetClient"> | Date | string
    appointments?: CabinetAppointmentListRelationFilter
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }

  export type CabinetClientOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appointments?: CabinetAppointmentOrderByRelationAggregateInput
    tenant?: TenantWebsiteOrderByWithRelationInput
  }

  export type CabinetClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CabinetClientWhereInput | CabinetClientWhereInput[]
    OR?: CabinetClientWhereInput[]
    NOT?: CabinetClientWhereInput | CabinetClientWhereInput[]
    tenantId?: StringFilter<"CabinetClient"> | string
    name?: StringFilter<"CabinetClient"> | string
    email?: StringNullableFilter<"CabinetClient"> | string | null
    phone?: StringNullableFilter<"CabinetClient"> | string | null
    notes?: StringNullableFilter<"CabinetClient"> | string | null
    createdAt?: DateTimeFilter<"CabinetClient"> | Date | string
    updatedAt?: DateTimeFilter<"CabinetClient"> | Date | string
    appointments?: CabinetAppointmentListRelationFilter
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }, "id">

  export type CabinetClientOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CabinetClientCountOrderByAggregateInput
    _max?: CabinetClientMaxOrderByAggregateInput
    _min?: CabinetClientMinOrderByAggregateInput
  }

  export type CabinetClientScalarWhereWithAggregatesInput = {
    AND?: CabinetClientScalarWhereWithAggregatesInput | CabinetClientScalarWhereWithAggregatesInput[]
    OR?: CabinetClientScalarWhereWithAggregatesInput[]
    NOT?: CabinetClientScalarWhereWithAggregatesInput | CabinetClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CabinetClient"> | string
    tenantId?: StringWithAggregatesFilter<"CabinetClient"> | string
    name?: StringWithAggregatesFilter<"CabinetClient"> | string
    email?: StringNullableWithAggregatesFilter<"CabinetClient"> | string | null
    phone?: StringNullableWithAggregatesFilter<"CabinetClient"> | string | null
    notes?: StringNullableWithAggregatesFilter<"CabinetClient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CabinetClient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CabinetClient"> | Date | string
  }

  export type CabinetAppointmentWhereInput = {
    AND?: CabinetAppointmentWhereInput | CabinetAppointmentWhereInput[]
    OR?: CabinetAppointmentWhereInput[]
    NOT?: CabinetAppointmentWhereInput | CabinetAppointmentWhereInput[]
    id?: StringFilter<"CabinetAppointment"> | string
    tenantId?: StringFilter<"CabinetAppointment"> | string
    serviceId?: StringFilter<"CabinetAppointment"> | string
    clientId?: StringFilter<"CabinetAppointment"> | string
    appointmentDate?: DateTimeFilter<"CabinetAppointment"> | Date | string
    status?: StringFilter<"CabinetAppointment"> | string
    notes?: StringNullableFilter<"CabinetAppointment"> | string | null
    createdAt?: DateTimeFilter<"CabinetAppointment"> | Date | string
    updatedAt?: DateTimeFilter<"CabinetAppointment"> | Date | string
    service?: XOR<CabinetServiceScalarRelationFilter, CabinetServiceWhereInput>
    client?: XOR<CabinetClientScalarRelationFilter, CabinetClientWhereInput>
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }

  export type CabinetAppointmentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    clientId?: SortOrder
    appointmentDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    service?: CabinetServiceOrderByWithRelationInput
    client?: CabinetClientOrderByWithRelationInput
    tenant?: TenantWebsiteOrderByWithRelationInput
  }

  export type CabinetAppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CabinetAppointmentWhereInput | CabinetAppointmentWhereInput[]
    OR?: CabinetAppointmentWhereInput[]
    NOT?: CabinetAppointmentWhereInput | CabinetAppointmentWhereInput[]
    tenantId?: StringFilter<"CabinetAppointment"> | string
    serviceId?: StringFilter<"CabinetAppointment"> | string
    clientId?: StringFilter<"CabinetAppointment"> | string
    appointmentDate?: DateTimeFilter<"CabinetAppointment"> | Date | string
    status?: StringFilter<"CabinetAppointment"> | string
    notes?: StringNullableFilter<"CabinetAppointment"> | string | null
    createdAt?: DateTimeFilter<"CabinetAppointment"> | Date | string
    updatedAt?: DateTimeFilter<"CabinetAppointment"> | Date | string
    service?: XOR<CabinetServiceScalarRelationFilter, CabinetServiceWhereInput>
    client?: XOR<CabinetClientScalarRelationFilter, CabinetClientWhereInput>
    tenant?: XOR<TenantWebsiteScalarRelationFilter, TenantWebsiteWhereInput>
  }, "id">

  export type CabinetAppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    clientId?: SortOrder
    appointmentDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CabinetAppointmentCountOrderByAggregateInput
    _max?: CabinetAppointmentMaxOrderByAggregateInput
    _min?: CabinetAppointmentMinOrderByAggregateInput
  }

  export type CabinetAppointmentScalarWhereWithAggregatesInput = {
    AND?: CabinetAppointmentScalarWhereWithAggregatesInput | CabinetAppointmentScalarWhereWithAggregatesInput[]
    OR?: CabinetAppointmentScalarWhereWithAggregatesInput[]
    NOT?: CabinetAppointmentScalarWhereWithAggregatesInput | CabinetAppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CabinetAppointment"> | string
    tenantId?: StringWithAggregatesFilter<"CabinetAppointment"> | string
    serviceId?: StringWithAggregatesFilter<"CabinetAppointment"> | string
    clientId?: StringWithAggregatesFilter<"CabinetAppointment"> | string
    appointmentDate?: DateTimeWithAggregatesFilter<"CabinetAppointment"> | Date | string
    status?: StringWithAggregatesFilter<"CabinetAppointment"> | string
    notes?: StringNullableWithAggregatesFilter<"CabinetAppointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CabinetAppointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CabinetAppointment"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    companyName: string
    role?: string
    createdAt?: Date | string
    services?: UserServiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    websites?: TenantWebsiteCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    companyName: string
    role?: string
    createdAt?: Date | string
    services?: UserServiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: UserServiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    websites?: TenantWebsiteUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: UserServiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    companyName: string
    role?: string
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionCreateInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageCreateNestedManyWithoutSessionInput
    user: UserCreateNestedOneWithoutChatSessionsInput
  }

  export type ChatSessionUncheckedCreateInput = {
    id?: string
    userId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUpdateManyWithoutSessionNestedInput
    user?: UserUpdateOneRequiredWithoutChatSessionsNestedInput
  }

  export type ChatSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionCreateManyInput = {
    id?: string
    userId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
    session: ChatSessionCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    sessionId: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: ChatSessionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    sessionId: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    category?: string | null
    createdAt?: Date | string
    users?: UserServiceCreateNestedManyWithoutServiceInput
    websites?: TenantWebsiteCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    category?: string | null
    createdAt?: Date | string
    users?: UserServiceUncheckedCreateNestedManyWithoutServiceInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserServiceUpdateManyWithoutServiceNestedInput
    websites?: TenantWebsiteUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserServiceUncheckedUpdateManyWithoutServiceNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    category?: string | null
    createdAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserServiceCreateInput = {
    id?: string
    notify?: boolean
    selectedAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutUsersInput
  }

  export type UserServiceUncheckedCreateInput = {
    id?: string
    userId: string
    serviceId: string
    notify?: boolean
    selectedAt?: Date | string
  }

  export type UserServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notify?: BoolFieldUpdateOperationsInput | boolean
    selectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    notify?: BoolFieldUpdateOperationsInput | boolean
    selectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserServiceCreateManyInput = {
    id?: string
    userId: string
    serviceId: string
    notify?: boolean
    selectedAt?: Date | string
  }

  export type UserServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notify?: BoolFieldUpdateOperationsInput | boolean
    selectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    notify?: BoolFieldUpdateOperationsInput | boolean
    selectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateInput = {
    id?: string
    email: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetUncheckedCreateInput = {
    id?: string
    email: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateManyInput = {
    id?: string
    email: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantWebsiteCreateInput = {
    id?: string
    slug: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentCreateNestedManyWithoutTenantInput
    user: UserCreateNestedOneWithoutWebsitesInput
    service: ServiceCreateNestedOneWithoutWebsitesInput
  }

  export type TenantWebsiteUncheckedCreateInput = {
    id?: string
    slug: string
    userId: string
    serviceId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryUncheckedCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableUncheckedCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterUncheckedCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceUncheckedCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientUncheckedCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantWebsiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUpdateManyWithoutTenantNestedInput
    user?: UserUpdateOneRequiredWithoutWebsitesNestedInput
    service?: ServiceUpdateOneRequiredWithoutWebsitesNestedInput
  }

  export type TenantWebsiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUncheckedUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUncheckedUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUncheckedUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUncheckedUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUncheckedUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantWebsiteCreateManyInput = {
    id?: string
    slug: string
    userId: string
    serviceId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantWebsiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantWebsiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantCategoryCreateInput = {
    id?: string
    name: string
    order?: number
    isActive?: boolean
    dishes?: RestaurantDishCreateNestedManyWithoutCategoryInput
    tenant: TenantWebsiteCreateNestedOneWithoutCategoriesInput
  }

  export type RestaurantCategoryUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    order?: number
    isActive?: boolean
    dishes?: RestaurantDishUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type RestaurantCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dishes?: RestaurantDishUpdateManyWithoutCategoryNestedInput
    tenant?: TenantWebsiteUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type RestaurantCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dishes?: RestaurantDishUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type RestaurantCategoryCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    order?: number
    isActive?: boolean
  }

  export type RestaurantCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestaurantCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestaurantDishCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    image?: string | null
    isActive?: boolean
    order?: number
    category: RestaurantCategoryCreateNestedOneWithoutDishesInput
  }

  export type RestaurantDishUncheckedCreateInput = {
    id?: string
    categoryId: string
    name: string
    description?: string | null
    price: number
    image?: string | null
    isActive?: boolean
    order?: number
  }

  export type RestaurantDishUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    category?: RestaurantCategoryUpdateOneRequiredWithoutDishesNestedInput
  }

  export type RestaurantDishUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantDishCreateManyInput = {
    id?: string
    categoryId: string
    name: string
    description?: string | null
    price: number
    image?: string | null
    isActive?: boolean
    order?: number
  }

  export type RestaurantDishUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantDishUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantTableCreateInput = {
    id?: string
    number: string
    capacity?: number | null
    isActive?: boolean
    orders?: RestaurantOrderCreateNestedManyWithoutTableInput
    tenant: TenantWebsiteCreateNestedOneWithoutTablesInput
    waiter?: RestaurantWaiterCreateNestedOneWithoutTablesInput
  }

  export type RestaurantTableUncheckedCreateInput = {
    id?: string
    tenantId: string
    number: string
    capacity?: number | null
    isActive?: boolean
    waiterId?: string | null
    orders?: RestaurantOrderUncheckedCreateNestedManyWithoutTableInput
  }

  export type RestaurantTableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    orders?: RestaurantOrderUpdateManyWithoutTableNestedInput
    tenant?: TenantWebsiteUpdateOneRequiredWithoutTablesNestedInput
    waiter?: RestaurantWaiterUpdateOneWithoutTablesNestedInput
  }

  export type RestaurantTableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiterId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: RestaurantOrderUncheckedUpdateManyWithoutTableNestedInput
  }

  export type RestaurantTableCreateManyInput = {
    id?: string
    tenantId: string
    number: string
    capacity?: number | null
    isActive?: boolean
    waiterId?: string | null
  }

  export type RestaurantTableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestaurantTableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestaurantWaiterCreateInput = {
    id?: string
    name: string
    pin: string
    isActive?: boolean
    createdAt?: Date | string
    tables?: RestaurantTableCreateNestedManyWithoutWaiterInput
    tenant: TenantWebsiteCreateNestedOneWithoutWaitersInput
  }

  export type RestaurantWaiterUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    pin: string
    isActive?: boolean
    createdAt?: Date | string
    tables?: RestaurantTableUncheckedCreateNestedManyWithoutWaiterInput
  }

  export type RestaurantWaiterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: RestaurantTableUpdateManyWithoutWaiterNestedInput
    tenant?: TenantWebsiteUpdateOneRequiredWithoutWaitersNestedInput
  }

  export type RestaurantWaiterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: RestaurantTableUncheckedUpdateManyWithoutWaiterNestedInput
  }

  export type RestaurantWaiterCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    pin: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type RestaurantWaiterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantWaiterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantOrderCreateInput = {
    id?: string
    status?: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: RestaurantOrderItemCreateNestedManyWithoutOrderInput
    table: RestaurantTableCreateNestedOneWithoutOrdersInput
  }

  export type RestaurantOrderUncheckedCreateInput = {
    id?: string
    tableId: string
    status?: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: RestaurantOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type RestaurantOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: RestaurantOrderItemUpdateManyWithoutOrderNestedInput
    table?: RestaurantTableUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type RestaurantOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: RestaurantOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type RestaurantOrderCreateManyInput = {
    id?: string
    tableId: string
    status?: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RestaurantOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantOrderItemCreateInput = {
    id?: string
    dishId: string
    name: string
    price: number
    quantity: number
    order: RestaurantOrderCreateNestedOneWithoutItemsInput
  }

  export type RestaurantOrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    dishId: string
    name: string
    price: number
    quantity: number
  }

  export type RestaurantOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    order?: RestaurantOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type RestaurantOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantOrderItemCreateManyInput = {
    id?: string
    orderId: string
    dishId: string
    name: string
    price: number
    quantity: number
  }

  export type RestaurantOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CabinetServiceCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    appointments?: CabinetAppointmentCreateNestedManyWithoutServiceInput
    tenant: TenantWebsiteCreateNestedOneWithoutCabinetServicesInput
  }

  export type CabinetServiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    appointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutServiceInput
  }

  export type CabinetServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: CabinetAppointmentUpdateManyWithoutServiceNestedInput
    tenant?: TenantWebsiteUpdateOneRequiredWithoutCabinetServicesNestedInput
  }

  export type CabinetServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: CabinetAppointmentUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type CabinetServiceCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type CabinetServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetClientCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: CabinetAppointmentCreateNestedManyWithoutClientInput
    tenant: TenantWebsiteCreateNestedOneWithoutCabinetClientsInput
  }

  export type CabinetClientUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutClientInput
  }

  export type CabinetClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: CabinetAppointmentUpdateManyWithoutClientNestedInput
    tenant?: TenantWebsiteUpdateOneRequiredWithoutCabinetClientsNestedInput
  }

  export type CabinetClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: CabinetAppointmentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CabinetClientCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetAppointmentCreateInput = {
    id?: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: CabinetServiceCreateNestedOneWithoutAppointmentsInput
    client: CabinetClientCreateNestedOneWithoutAppointmentsInput
    tenant: TenantWebsiteCreateNestedOneWithoutCabinetAppointmentsInput
  }

  export type CabinetAppointmentUncheckedCreateInput = {
    id?: string
    tenantId: string
    serviceId: string
    clientId: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetAppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: CabinetServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    client?: CabinetClientUpdateOneRequiredWithoutAppointmentsNestedInput
    tenant?: TenantWebsiteUpdateOneRequiredWithoutCabinetAppointmentsNestedInput
  }

  export type CabinetAppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetAppointmentCreateManyInput = {
    id?: string
    tenantId: string
    serviceId: string
    clientId: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetAppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetAppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserServiceListRelationFilter = {
    every?: UserServiceWhereInput
    some?: UserServiceWhereInput
    none?: UserServiceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type TenantWebsiteListRelationFilter = {
    every?: TenantWebsiteWhereInput
    some?: TenantWebsiteWhereInput
    none?: TenantWebsiteWhereInput
  }

  export type ChatSessionListRelationFilter = {
    every?: ChatSessionWhereInput
    some?: ChatSessionWhereInput
    none?: ChatSessionWhereInput
  }

  export type UserServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantWebsiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    companyName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    companyName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    companyName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ChatSessionScalarRelationFilter = {
    is?: ChatSessionWhereInput
    isNot?: ChatSessionWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    status?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    status?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    status?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type UserServiceUserIdServiceIdCompoundUniqueInput = {
    userId: string
    serviceId: string
  }

  export type UserServiceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    notify?: SortOrder
    selectedAt?: SortOrder
  }

  export type UserServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    notify?: SortOrder
    selectedAt?: SortOrder
  }

  export type UserServiceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    notify?: SortOrder
    selectedAt?: SortOrder
  }

  export type PasswordResetCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RestaurantCategoryListRelationFilter = {
    every?: RestaurantCategoryWhereInput
    some?: RestaurantCategoryWhereInput
    none?: RestaurantCategoryWhereInput
  }

  export type RestaurantTableListRelationFilter = {
    every?: RestaurantTableWhereInput
    some?: RestaurantTableWhereInput
    none?: RestaurantTableWhereInput
  }

  export type RestaurantWaiterListRelationFilter = {
    every?: RestaurantWaiterWhereInput
    some?: RestaurantWaiterWhereInput
    none?: RestaurantWaiterWhereInput
  }

  export type CabinetServiceListRelationFilter = {
    every?: CabinetServiceWhereInput
    some?: CabinetServiceWhereInput
    none?: CabinetServiceWhereInput
  }

  export type CabinetClientListRelationFilter = {
    every?: CabinetClientWhereInput
    some?: CabinetClientWhereInput
    none?: CabinetClientWhereInput
  }

  export type CabinetAppointmentListRelationFilter = {
    every?: CabinetAppointmentWhereInput
    some?: CabinetAppointmentWhereInput
    none?: CabinetAppointmentWhereInput
  }

  export type RestaurantCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantWaiterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CabinetServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CabinetClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CabinetAppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantWebsiteCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    siteName?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    primaryColor?: SortOrder
    config?: SortOrder
    designTemplate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantWebsiteMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    siteName?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    primaryColor?: SortOrder
    config?: SortOrder
    designTemplate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantWebsiteMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    siteName?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    primaryColor?: SortOrder
    config?: SortOrder
    designTemplate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RestaurantDishListRelationFilter = {
    every?: RestaurantDishWhereInput
    some?: RestaurantDishWhereInput
    none?: RestaurantDishWhereInput
  }

  export type TenantWebsiteScalarRelationFilter = {
    is?: TenantWebsiteWhereInput
    isNot?: TenantWebsiteWhereInput
  }

  export type RestaurantDishOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
  }

  export type RestaurantCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type RestaurantCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
  }

  export type RestaurantCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
  }

  export type RestaurantCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RestaurantCategoryScalarRelationFilter = {
    is?: RestaurantCategoryWhereInput
    isNot?: RestaurantCategoryWhereInput
  }

  export type RestaurantDishCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    image?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
  }

  export type RestaurantDishAvgOrderByAggregateInput = {
    price?: SortOrder
    order?: SortOrder
  }

  export type RestaurantDishMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    image?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
  }

  export type RestaurantDishMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    image?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
  }

  export type RestaurantDishSumOrderByAggregateInput = {
    price?: SortOrder
    order?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RestaurantOrderListRelationFilter = {
    every?: RestaurantOrderWhereInput
    some?: RestaurantOrderWhereInput
    none?: RestaurantOrderWhereInput
  }

  export type RestaurantWaiterNullableScalarRelationFilter = {
    is?: RestaurantWaiterWhereInput | null
    isNot?: RestaurantWaiterWhereInput | null
  }

  export type RestaurantOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantTableTenantIdNumberCompoundUniqueInput = {
    tenantId: string
    number: string
  }

  export type RestaurantTableCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    number?: SortOrder
    capacity?: SortOrder
    isActive?: SortOrder
    waiterId?: SortOrder
  }

  export type RestaurantTableAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type RestaurantTableMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    number?: SortOrder
    capacity?: SortOrder
    isActive?: SortOrder
    waiterId?: SortOrder
  }

  export type RestaurantTableMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    number?: SortOrder
    capacity?: SortOrder
    isActive?: SortOrder
    waiterId?: SortOrder
  }

  export type RestaurantTableSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type RestaurantWaiterCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    pin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type RestaurantWaiterMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    pin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type RestaurantWaiterMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    pin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type RestaurantOrderItemListRelationFilter = {
    every?: RestaurantOrderItemWhereInput
    some?: RestaurantOrderItemWhereInput
    none?: RestaurantOrderItemWhereInput
  }

  export type RestaurantTableScalarRelationFilter = {
    is?: RestaurantTableWhereInput
    isNot?: RestaurantTableWhereInput
  }

  export type RestaurantOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantOrderCountOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RestaurantOrderAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type RestaurantOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RestaurantOrderMinOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RestaurantOrderSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type RestaurantOrderScalarRelationFilter = {
    is?: RestaurantOrderWhereInput
    isNot?: RestaurantOrderWhereInput
  }

  export type RestaurantOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    dishId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
  }

  export type RestaurantOrderItemAvgOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type RestaurantOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    dishId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
  }

  export type RestaurantOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    dishId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
  }

  export type RestaurantOrderItemSumOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type CabinetServiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type CabinetServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type CabinetServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type CabinetServiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type CabinetServiceSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type CabinetClientCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CabinetClientMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CabinetClientMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CabinetServiceScalarRelationFilter = {
    is?: CabinetServiceWhereInput
    isNot?: CabinetServiceWhereInput
  }

  export type CabinetClientScalarRelationFilter = {
    is?: CabinetClientWhereInput
    isNot?: CabinetClientWhereInput
  }

  export type CabinetAppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    clientId?: SortOrder
    appointmentDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CabinetAppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    clientId?: SortOrder
    appointmentDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CabinetAppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    clientId?: SortOrder
    appointmentDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserServiceCreateNestedManyWithoutUserInput = {
    create?: XOR<UserServiceCreateWithoutUserInput, UserServiceUncheckedCreateWithoutUserInput> | UserServiceCreateWithoutUserInput[] | UserServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserServiceCreateOrConnectWithoutUserInput | UserServiceCreateOrConnectWithoutUserInput[]
    createMany?: UserServiceCreateManyUserInputEnvelope
    connect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TenantWebsiteCreateNestedManyWithoutUserInput = {
    create?: XOR<TenantWebsiteCreateWithoutUserInput, TenantWebsiteUncheckedCreateWithoutUserInput> | TenantWebsiteCreateWithoutUserInput[] | TenantWebsiteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutUserInput | TenantWebsiteCreateOrConnectWithoutUserInput[]
    createMany?: TenantWebsiteCreateManyUserInputEnvelope
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
  }

  export type ChatSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type UserServiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserServiceCreateWithoutUserInput, UserServiceUncheckedCreateWithoutUserInput> | UserServiceCreateWithoutUserInput[] | UserServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserServiceCreateOrConnectWithoutUserInput | UserServiceCreateOrConnectWithoutUserInput[]
    createMany?: UserServiceCreateManyUserInputEnvelope
    connect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TenantWebsiteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TenantWebsiteCreateWithoutUserInput, TenantWebsiteUncheckedCreateWithoutUserInput> | TenantWebsiteCreateWithoutUserInput[] | TenantWebsiteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutUserInput | TenantWebsiteCreateOrConnectWithoutUserInput[]
    createMany?: TenantWebsiteCreateManyUserInputEnvelope
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
  }

  export type ChatSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserServiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserServiceCreateWithoutUserInput, UserServiceUncheckedCreateWithoutUserInput> | UserServiceCreateWithoutUserInput[] | UserServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserServiceCreateOrConnectWithoutUserInput | UserServiceCreateOrConnectWithoutUserInput[]
    upsert?: UserServiceUpsertWithWhereUniqueWithoutUserInput | UserServiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserServiceCreateManyUserInputEnvelope
    set?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    disconnect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    delete?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    connect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    update?: UserServiceUpdateWithWhereUniqueWithoutUserInput | UserServiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserServiceUpdateManyWithWhereWithoutUserInput | UserServiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserServiceScalarWhereInput | UserServiceScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TenantWebsiteUpdateManyWithoutUserNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutUserInput, TenantWebsiteUncheckedCreateWithoutUserInput> | TenantWebsiteCreateWithoutUserInput[] | TenantWebsiteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutUserInput | TenantWebsiteCreateOrConnectWithoutUserInput[]
    upsert?: TenantWebsiteUpsertWithWhereUniqueWithoutUserInput | TenantWebsiteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TenantWebsiteCreateManyUserInputEnvelope
    set?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    disconnect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    delete?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    update?: TenantWebsiteUpdateWithWhereUniqueWithoutUserInput | TenantWebsiteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TenantWebsiteUpdateManyWithWhereWithoutUserInput | TenantWebsiteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TenantWebsiteScalarWhereInput | TenantWebsiteScalarWhereInput[]
  }

  export type ChatSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutUserInput | ChatSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutUserInput | ChatSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutUserInput | ChatSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type UserServiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserServiceCreateWithoutUserInput, UserServiceUncheckedCreateWithoutUserInput> | UserServiceCreateWithoutUserInput[] | UserServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserServiceCreateOrConnectWithoutUserInput | UserServiceCreateOrConnectWithoutUserInput[]
    upsert?: UserServiceUpsertWithWhereUniqueWithoutUserInput | UserServiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserServiceCreateManyUserInputEnvelope
    set?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    disconnect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    delete?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    connect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    update?: UserServiceUpdateWithWhereUniqueWithoutUserInput | UserServiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserServiceUpdateManyWithWhereWithoutUserInput | UserServiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserServiceScalarWhereInput | UserServiceScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TenantWebsiteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutUserInput, TenantWebsiteUncheckedCreateWithoutUserInput> | TenantWebsiteCreateWithoutUserInput[] | TenantWebsiteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutUserInput | TenantWebsiteCreateOrConnectWithoutUserInput[]
    upsert?: TenantWebsiteUpsertWithWhereUniqueWithoutUserInput | TenantWebsiteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TenantWebsiteCreateManyUserInputEnvelope
    set?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    disconnect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    delete?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    update?: TenantWebsiteUpdateWithWhereUniqueWithoutUserInput | TenantWebsiteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TenantWebsiteUpdateManyWithWhereWithoutUserInput | TenantWebsiteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TenantWebsiteScalarWhereInput | TenantWebsiteScalarWhereInput[]
  }

  export type ChatSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutUserInput | ChatSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutUserInput | ChatSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutUserInput | ChatSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type ChatMessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutChatSessionsInput = {
    create?: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ChatMessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSessionInput | ChatMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSessionInput | ChatMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSessionInput | ChatMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutChatSessionsNestedInput = {
    create?: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatSessionsInput
    upsert?: UserUpsertWithoutChatSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatSessionsInput, UserUpdateWithoutChatSessionsInput>, UserUncheckedUpdateWithoutChatSessionsInput>
  }

  export type ChatMessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSessionInput | ChatMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSessionInput | ChatMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSessionInput | ChatMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatSessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutMessagesInput
    connect?: ChatSessionWhereUniqueInput
  }

  export type ChatSessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutMessagesInput
    upsert?: ChatSessionUpsertWithoutMessagesInput
    connect?: ChatSessionWhereUniqueInput
    update?: XOR<XOR<ChatSessionUpdateToOneWithWhereWithoutMessagesInput, ChatSessionUpdateWithoutMessagesInput>, ChatSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserServiceCreateWithoutServiceInput, UserServiceUncheckedCreateWithoutServiceInput> | UserServiceCreateWithoutServiceInput[] | UserServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserServiceCreateOrConnectWithoutServiceInput | UserServiceCreateOrConnectWithoutServiceInput[]
    createMany?: UserServiceCreateManyServiceInputEnvelope
    connect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
  }

  export type TenantWebsiteCreateNestedManyWithoutServiceInput = {
    create?: XOR<TenantWebsiteCreateWithoutServiceInput, TenantWebsiteUncheckedCreateWithoutServiceInput> | TenantWebsiteCreateWithoutServiceInput[] | TenantWebsiteUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutServiceInput | TenantWebsiteCreateOrConnectWithoutServiceInput[]
    createMany?: TenantWebsiteCreateManyServiceInputEnvelope
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
  }

  export type UserServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserServiceCreateWithoutServiceInput, UserServiceUncheckedCreateWithoutServiceInput> | UserServiceCreateWithoutServiceInput[] | UserServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserServiceCreateOrConnectWithoutServiceInput | UserServiceCreateOrConnectWithoutServiceInput[]
    createMany?: UserServiceCreateManyServiceInputEnvelope
    connect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
  }

  export type TenantWebsiteUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<TenantWebsiteCreateWithoutServiceInput, TenantWebsiteUncheckedCreateWithoutServiceInput> | TenantWebsiteCreateWithoutServiceInput[] | TenantWebsiteUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutServiceInput | TenantWebsiteCreateOrConnectWithoutServiceInput[]
    createMany?: TenantWebsiteCreateManyServiceInputEnvelope
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
  }

  export type UserServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserServiceCreateWithoutServiceInput, UserServiceUncheckedCreateWithoutServiceInput> | UserServiceCreateWithoutServiceInput[] | UserServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserServiceCreateOrConnectWithoutServiceInput | UserServiceCreateOrConnectWithoutServiceInput[]
    upsert?: UserServiceUpsertWithWhereUniqueWithoutServiceInput | UserServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserServiceCreateManyServiceInputEnvelope
    set?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    disconnect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    delete?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    connect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    update?: UserServiceUpdateWithWhereUniqueWithoutServiceInput | UserServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserServiceUpdateManyWithWhereWithoutServiceInput | UserServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserServiceScalarWhereInput | UserServiceScalarWhereInput[]
  }

  export type TenantWebsiteUpdateManyWithoutServiceNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutServiceInput, TenantWebsiteUncheckedCreateWithoutServiceInput> | TenantWebsiteCreateWithoutServiceInput[] | TenantWebsiteUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutServiceInput | TenantWebsiteCreateOrConnectWithoutServiceInput[]
    upsert?: TenantWebsiteUpsertWithWhereUniqueWithoutServiceInput | TenantWebsiteUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: TenantWebsiteCreateManyServiceInputEnvelope
    set?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    disconnect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    delete?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    update?: TenantWebsiteUpdateWithWhereUniqueWithoutServiceInput | TenantWebsiteUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: TenantWebsiteUpdateManyWithWhereWithoutServiceInput | TenantWebsiteUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: TenantWebsiteScalarWhereInput | TenantWebsiteScalarWhereInput[]
  }

  export type UserServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserServiceCreateWithoutServiceInput, UserServiceUncheckedCreateWithoutServiceInput> | UserServiceCreateWithoutServiceInput[] | UserServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserServiceCreateOrConnectWithoutServiceInput | UserServiceCreateOrConnectWithoutServiceInput[]
    upsert?: UserServiceUpsertWithWhereUniqueWithoutServiceInput | UserServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserServiceCreateManyServiceInputEnvelope
    set?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    disconnect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    delete?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    connect?: UserServiceWhereUniqueInput | UserServiceWhereUniqueInput[]
    update?: UserServiceUpdateWithWhereUniqueWithoutServiceInput | UserServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserServiceUpdateManyWithWhereWithoutServiceInput | UserServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserServiceScalarWhereInput | UserServiceScalarWhereInput[]
  }

  export type TenantWebsiteUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutServiceInput, TenantWebsiteUncheckedCreateWithoutServiceInput> | TenantWebsiteCreateWithoutServiceInput[] | TenantWebsiteUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutServiceInput | TenantWebsiteCreateOrConnectWithoutServiceInput[]
    upsert?: TenantWebsiteUpsertWithWhereUniqueWithoutServiceInput | TenantWebsiteUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: TenantWebsiteCreateManyServiceInputEnvelope
    set?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    disconnect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    delete?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    connect?: TenantWebsiteWhereUniqueInput | TenantWebsiteWhereUniqueInput[]
    update?: TenantWebsiteUpdateWithWhereUniqueWithoutServiceInput | TenantWebsiteUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: TenantWebsiteUpdateManyWithWhereWithoutServiceInput | TenantWebsiteUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: TenantWebsiteScalarWhereInput | TenantWebsiteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutServicesInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutUsersInput = {
    create?: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutUsersInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    upsert?: UserUpsertWithoutServicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServicesInput, UserUpdateWithoutServicesInput>, UserUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutUsersInput
    upsert?: ServiceUpsertWithoutUsersInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutUsersInput, ServiceUpdateWithoutUsersInput>, ServiceUncheckedUpdateWithoutUsersInput>
  }

  export type RestaurantCategoryCreateNestedManyWithoutTenantInput = {
    create?: XOR<RestaurantCategoryCreateWithoutTenantInput, RestaurantCategoryUncheckedCreateWithoutTenantInput> | RestaurantCategoryCreateWithoutTenantInput[] | RestaurantCategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantCategoryCreateOrConnectWithoutTenantInput | RestaurantCategoryCreateOrConnectWithoutTenantInput[]
    createMany?: RestaurantCategoryCreateManyTenantInputEnvelope
    connect?: RestaurantCategoryWhereUniqueInput | RestaurantCategoryWhereUniqueInput[]
  }

  export type RestaurantTableCreateNestedManyWithoutTenantInput = {
    create?: XOR<RestaurantTableCreateWithoutTenantInput, RestaurantTableUncheckedCreateWithoutTenantInput> | RestaurantTableCreateWithoutTenantInput[] | RestaurantTableUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantTableCreateOrConnectWithoutTenantInput | RestaurantTableCreateOrConnectWithoutTenantInput[]
    createMany?: RestaurantTableCreateManyTenantInputEnvelope
    connect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
  }

  export type RestaurantWaiterCreateNestedManyWithoutTenantInput = {
    create?: XOR<RestaurantWaiterCreateWithoutTenantInput, RestaurantWaiterUncheckedCreateWithoutTenantInput> | RestaurantWaiterCreateWithoutTenantInput[] | RestaurantWaiterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantWaiterCreateOrConnectWithoutTenantInput | RestaurantWaiterCreateOrConnectWithoutTenantInput[]
    createMany?: RestaurantWaiterCreateManyTenantInputEnvelope
    connect?: RestaurantWaiterWhereUniqueInput | RestaurantWaiterWhereUniqueInput[]
  }

  export type CabinetServiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<CabinetServiceCreateWithoutTenantInput, CabinetServiceUncheckedCreateWithoutTenantInput> | CabinetServiceCreateWithoutTenantInput[] | CabinetServiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetServiceCreateOrConnectWithoutTenantInput | CabinetServiceCreateOrConnectWithoutTenantInput[]
    createMany?: CabinetServiceCreateManyTenantInputEnvelope
    connect?: CabinetServiceWhereUniqueInput | CabinetServiceWhereUniqueInput[]
  }

  export type CabinetClientCreateNestedManyWithoutTenantInput = {
    create?: XOR<CabinetClientCreateWithoutTenantInput, CabinetClientUncheckedCreateWithoutTenantInput> | CabinetClientCreateWithoutTenantInput[] | CabinetClientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetClientCreateOrConnectWithoutTenantInput | CabinetClientCreateOrConnectWithoutTenantInput[]
    createMany?: CabinetClientCreateManyTenantInputEnvelope
    connect?: CabinetClientWhereUniqueInput | CabinetClientWhereUniqueInput[]
  }

  export type CabinetAppointmentCreateNestedManyWithoutTenantInput = {
    create?: XOR<CabinetAppointmentCreateWithoutTenantInput, CabinetAppointmentUncheckedCreateWithoutTenantInput> | CabinetAppointmentCreateWithoutTenantInput[] | CabinetAppointmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutTenantInput | CabinetAppointmentCreateOrConnectWithoutTenantInput[]
    createMany?: CabinetAppointmentCreateManyTenantInputEnvelope
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutWebsitesInput = {
    create?: XOR<UserCreateWithoutWebsitesInput, UserUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWebsitesInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutWebsitesInput = {
    create?: XOR<ServiceCreateWithoutWebsitesInput, ServiceUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutWebsitesInput
    connect?: ServiceWhereUniqueInput
  }

  export type RestaurantCategoryUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RestaurantCategoryCreateWithoutTenantInput, RestaurantCategoryUncheckedCreateWithoutTenantInput> | RestaurantCategoryCreateWithoutTenantInput[] | RestaurantCategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantCategoryCreateOrConnectWithoutTenantInput | RestaurantCategoryCreateOrConnectWithoutTenantInput[]
    createMany?: RestaurantCategoryCreateManyTenantInputEnvelope
    connect?: RestaurantCategoryWhereUniqueInput | RestaurantCategoryWhereUniqueInput[]
  }

  export type RestaurantTableUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RestaurantTableCreateWithoutTenantInput, RestaurantTableUncheckedCreateWithoutTenantInput> | RestaurantTableCreateWithoutTenantInput[] | RestaurantTableUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantTableCreateOrConnectWithoutTenantInput | RestaurantTableCreateOrConnectWithoutTenantInput[]
    createMany?: RestaurantTableCreateManyTenantInputEnvelope
    connect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
  }

  export type RestaurantWaiterUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RestaurantWaiterCreateWithoutTenantInput, RestaurantWaiterUncheckedCreateWithoutTenantInput> | RestaurantWaiterCreateWithoutTenantInput[] | RestaurantWaiterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantWaiterCreateOrConnectWithoutTenantInput | RestaurantWaiterCreateOrConnectWithoutTenantInput[]
    createMany?: RestaurantWaiterCreateManyTenantInputEnvelope
    connect?: RestaurantWaiterWhereUniqueInput | RestaurantWaiterWhereUniqueInput[]
  }

  export type CabinetServiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CabinetServiceCreateWithoutTenantInput, CabinetServiceUncheckedCreateWithoutTenantInput> | CabinetServiceCreateWithoutTenantInput[] | CabinetServiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetServiceCreateOrConnectWithoutTenantInput | CabinetServiceCreateOrConnectWithoutTenantInput[]
    createMany?: CabinetServiceCreateManyTenantInputEnvelope
    connect?: CabinetServiceWhereUniqueInput | CabinetServiceWhereUniqueInput[]
  }

  export type CabinetClientUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CabinetClientCreateWithoutTenantInput, CabinetClientUncheckedCreateWithoutTenantInput> | CabinetClientCreateWithoutTenantInput[] | CabinetClientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetClientCreateOrConnectWithoutTenantInput | CabinetClientCreateOrConnectWithoutTenantInput[]
    createMany?: CabinetClientCreateManyTenantInputEnvelope
    connect?: CabinetClientWhereUniqueInput | CabinetClientWhereUniqueInput[]
  }

  export type CabinetAppointmentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CabinetAppointmentCreateWithoutTenantInput, CabinetAppointmentUncheckedCreateWithoutTenantInput> | CabinetAppointmentCreateWithoutTenantInput[] | CabinetAppointmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutTenantInput | CabinetAppointmentCreateOrConnectWithoutTenantInput[]
    createMany?: CabinetAppointmentCreateManyTenantInputEnvelope
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
  }

  export type RestaurantCategoryUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RestaurantCategoryCreateWithoutTenantInput, RestaurantCategoryUncheckedCreateWithoutTenantInput> | RestaurantCategoryCreateWithoutTenantInput[] | RestaurantCategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantCategoryCreateOrConnectWithoutTenantInput | RestaurantCategoryCreateOrConnectWithoutTenantInput[]
    upsert?: RestaurantCategoryUpsertWithWhereUniqueWithoutTenantInput | RestaurantCategoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RestaurantCategoryCreateManyTenantInputEnvelope
    set?: RestaurantCategoryWhereUniqueInput | RestaurantCategoryWhereUniqueInput[]
    disconnect?: RestaurantCategoryWhereUniqueInput | RestaurantCategoryWhereUniqueInput[]
    delete?: RestaurantCategoryWhereUniqueInput | RestaurantCategoryWhereUniqueInput[]
    connect?: RestaurantCategoryWhereUniqueInput | RestaurantCategoryWhereUniqueInput[]
    update?: RestaurantCategoryUpdateWithWhereUniqueWithoutTenantInput | RestaurantCategoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RestaurantCategoryUpdateManyWithWhereWithoutTenantInput | RestaurantCategoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RestaurantCategoryScalarWhereInput | RestaurantCategoryScalarWhereInput[]
  }

  export type RestaurantTableUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RestaurantTableCreateWithoutTenantInput, RestaurantTableUncheckedCreateWithoutTenantInput> | RestaurantTableCreateWithoutTenantInput[] | RestaurantTableUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantTableCreateOrConnectWithoutTenantInput | RestaurantTableCreateOrConnectWithoutTenantInput[]
    upsert?: RestaurantTableUpsertWithWhereUniqueWithoutTenantInput | RestaurantTableUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RestaurantTableCreateManyTenantInputEnvelope
    set?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    disconnect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    delete?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    connect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    update?: RestaurantTableUpdateWithWhereUniqueWithoutTenantInput | RestaurantTableUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RestaurantTableUpdateManyWithWhereWithoutTenantInput | RestaurantTableUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RestaurantTableScalarWhereInput | RestaurantTableScalarWhereInput[]
  }

  export type RestaurantWaiterUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RestaurantWaiterCreateWithoutTenantInput, RestaurantWaiterUncheckedCreateWithoutTenantInput> | RestaurantWaiterCreateWithoutTenantInput[] | RestaurantWaiterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantWaiterCreateOrConnectWithoutTenantInput | RestaurantWaiterCreateOrConnectWithoutTenantInput[]
    upsert?: RestaurantWaiterUpsertWithWhereUniqueWithoutTenantInput | RestaurantWaiterUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RestaurantWaiterCreateManyTenantInputEnvelope
    set?: RestaurantWaiterWhereUniqueInput | RestaurantWaiterWhereUniqueInput[]
    disconnect?: RestaurantWaiterWhereUniqueInput | RestaurantWaiterWhereUniqueInput[]
    delete?: RestaurantWaiterWhereUniqueInput | RestaurantWaiterWhereUniqueInput[]
    connect?: RestaurantWaiterWhereUniqueInput | RestaurantWaiterWhereUniqueInput[]
    update?: RestaurantWaiterUpdateWithWhereUniqueWithoutTenantInput | RestaurantWaiterUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RestaurantWaiterUpdateManyWithWhereWithoutTenantInput | RestaurantWaiterUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RestaurantWaiterScalarWhereInput | RestaurantWaiterScalarWhereInput[]
  }

  export type CabinetServiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CabinetServiceCreateWithoutTenantInput, CabinetServiceUncheckedCreateWithoutTenantInput> | CabinetServiceCreateWithoutTenantInput[] | CabinetServiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetServiceCreateOrConnectWithoutTenantInput | CabinetServiceCreateOrConnectWithoutTenantInput[]
    upsert?: CabinetServiceUpsertWithWhereUniqueWithoutTenantInput | CabinetServiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CabinetServiceCreateManyTenantInputEnvelope
    set?: CabinetServiceWhereUniqueInput | CabinetServiceWhereUniqueInput[]
    disconnect?: CabinetServiceWhereUniqueInput | CabinetServiceWhereUniqueInput[]
    delete?: CabinetServiceWhereUniqueInput | CabinetServiceWhereUniqueInput[]
    connect?: CabinetServiceWhereUniqueInput | CabinetServiceWhereUniqueInput[]
    update?: CabinetServiceUpdateWithWhereUniqueWithoutTenantInput | CabinetServiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CabinetServiceUpdateManyWithWhereWithoutTenantInput | CabinetServiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CabinetServiceScalarWhereInput | CabinetServiceScalarWhereInput[]
  }

  export type CabinetClientUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CabinetClientCreateWithoutTenantInput, CabinetClientUncheckedCreateWithoutTenantInput> | CabinetClientCreateWithoutTenantInput[] | CabinetClientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetClientCreateOrConnectWithoutTenantInput | CabinetClientCreateOrConnectWithoutTenantInput[]
    upsert?: CabinetClientUpsertWithWhereUniqueWithoutTenantInput | CabinetClientUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CabinetClientCreateManyTenantInputEnvelope
    set?: CabinetClientWhereUniqueInput | CabinetClientWhereUniqueInput[]
    disconnect?: CabinetClientWhereUniqueInput | CabinetClientWhereUniqueInput[]
    delete?: CabinetClientWhereUniqueInput | CabinetClientWhereUniqueInput[]
    connect?: CabinetClientWhereUniqueInput | CabinetClientWhereUniqueInput[]
    update?: CabinetClientUpdateWithWhereUniqueWithoutTenantInput | CabinetClientUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CabinetClientUpdateManyWithWhereWithoutTenantInput | CabinetClientUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CabinetClientScalarWhereInput | CabinetClientScalarWhereInput[]
  }

  export type CabinetAppointmentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CabinetAppointmentCreateWithoutTenantInput, CabinetAppointmentUncheckedCreateWithoutTenantInput> | CabinetAppointmentCreateWithoutTenantInput[] | CabinetAppointmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutTenantInput | CabinetAppointmentCreateOrConnectWithoutTenantInput[]
    upsert?: CabinetAppointmentUpsertWithWhereUniqueWithoutTenantInput | CabinetAppointmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CabinetAppointmentCreateManyTenantInputEnvelope
    set?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    disconnect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    delete?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    update?: CabinetAppointmentUpdateWithWhereUniqueWithoutTenantInput | CabinetAppointmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CabinetAppointmentUpdateManyWithWhereWithoutTenantInput | CabinetAppointmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CabinetAppointmentScalarWhereInput | CabinetAppointmentScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutWebsitesNestedInput = {
    create?: XOR<UserCreateWithoutWebsitesInput, UserUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWebsitesInput
    upsert?: UserUpsertWithoutWebsitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWebsitesInput, UserUpdateWithoutWebsitesInput>, UserUncheckedUpdateWithoutWebsitesInput>
  }

  export type ServiceUpdateOneRequiredWithoutWebsitesNestedInput = {
    create?: XOR<ServiceCreateWithoutWebsitesInput, ServiceUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutWebsitesInput
    upsert?: ServiceUpsertWithoutWebsitesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutWebsitesInput, ServiceUpdateWithoutWebsitesInput>, ServiceUncheckedUpdateWithoutWebsitesInput>
  }

  export type RestaurantCategoryUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RestaurantCategoryCreateWithoutTenantInput, RestaurantCategoryUncheckedCreateWithoutTenantInput> | RestaurantCategoryCreateWithoutTenantInput[] | RestaurantCategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantCategoryCreateOrConnectWithoutTenantInput | RestaurantCategoryCreateOrConnectWithoutTenantInput[]
    upsert?: RestaurantCategoryUpsertWithWhereUniqueWithoutTenantInput | RestaurantCategoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RestaurantCategoryCreateManyTenantInputEnvelope
    set?: RestaurantCategoryWhereUniqueInput | RestaurantCategoryWhereUniqueInput[]
    disconnect?: RestaurantCategoryWhereUniqueInput | RestaurantCategoryWhereUniqueInput[]
    delete?: RestaurantCategoryWhereUniqueInput | RestaurantCategoryWhereUniqueInput[]
    connect?: RestaurantCategoryWhereUniqueInput | RestaurantCategoryWhereUniqueInput[]
    update?: RestaurantCategoryUpdateWithWhereUniqueWithoutTenantInput | RestaurantCategoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RestaurantCategoryUpdateManyWithWhereWithoutTenantInput | RestaurantCategoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RestaurantCategoryScalarWhereInput | RestaurantCategoryScalarWhereInput[]
  }

  export type RestaurantTableUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RestaurantTableCreateWithoutTenantInput, RestaurantTableUncheckedCreateWithoutTenantInput> | RestaurantTableCreateWithoutTenantInput[] | RestaurantTableUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantTableCreateOrConnectWithoutTenantInput | RestaurantTableCreateOrConnectWithoutTenantInput[]
    upsert?: RestaurantTableUpsertWithWhereUniqueWithoutTenantInput | RestaurantTableUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RestaurantTableCreateManyTenantInputEnvelope
    set?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    disconnect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    delete?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    connect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    update?: RestaurantTableUpdateWithWhereUniqueWithoutTenantInput | RestaurantTableUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RestaurantTableUpdateManyWithWhereWithoutTenantInput | RestaurantTableUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RestaurantTableScalarWhereInput | RestaurantTableScalarWhereInput[]
  }

  export type RestaurantWaiterUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RestaurantWaiterCreateWithoutTenantInput, RestaurantWaiterUncheckedCreateWithoutTenantInput> | RestaurantWaiterCreateWithoutTenantInput[] | RestaurantWaiterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RestaurantWaiterCreateOrConnectWithoutTenantInput | RestaurantWaiterCreateOrConnectWithoutTenantInput[]
    upsert?: RestaurantWaiterUpsertWithWhereUniqueWithoutTenantInput | RestaurantWaiterUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RestaurantWaiterCreateManyTenantInputEnvelope
    set?: RestaurantWaiterWhereUniqueInput | RestaurantWaiterWhereUniqueInput[]
    disconnect?: RestaurantWaiterWhereUniqueInput | RestaurantWaiterWhereUniqueInput[]
    delete?: RestaurantWaiterWhereUniqueInput | RestaurantWaiterWhereUniqueInput[]
    connect?: RestaurantWaiterWhereUniqueInput | RestaurantWaiterWhereUniqueInput[]
    update?: RestaurantWaiterUpdateWithWhereUniqueWithoutTenantInput | RestaurantWaiterUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RestaurantWaiterUpdateManyWithWhereWithoutTenantInput | RestaurantWaiterUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RestaurantWaiterScalarWhereInput | RestaurantWaiterScalarWhereInput[]
  }

  export type CabinetServiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CabinetServiceCreateWithoutTenantInput, CabinetServiceUncheckedCreateWithoutTenantInput> | CabinetServiceCreateWithoutTenantInput[] | CabinetServiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetServiceCreateOrConnectWithoutTenantInput | CabinetServiceCreateOrConnectWithoutTenantInput[]
    upsert?: CabinetServiceUpsertWithWhereUniqueWithoutTenantInput | CabinetServiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CabinetServiceCreateManyTenantInputEnvelope
    set?: CabinetServiceWhereUniqueInput | CabinetServiceWhereUniqueInput[]
    disconnect?: CabinetServiceWhereUniqueInput | CabinetServiceWhereUniqueInput[]
    delete?: CabinetServiceWhereUniqueInput | CabinetServiceWhereUniqueInput[]
    connect?: CabinetServiceWhereUniqueInput | CabinetServiceWhereUniqueInput[]
    update?: CabinetServiceUpdateWithWhereUniqueWithoutTenantInput | CabinetServiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CabinetServiceUpdateManyWithWhereWithoutTenantInput | CabinetServiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CabinetServiceScalarWhereInput | CabinetServiceScalarWhereInput[]
  }

  export type CabinetClientUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CabinetClientCreateWithoutTenantInput, CabinetClientUncheckedCreateWithoutTenantInput> | CabinetClientCreateWithoutTenantInput[] | CabinetClientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetClientCreateOrConnectWithoutTenantInput | CabinetClientCreateOrConnectWithoutTenantInput[]
    upsert?: CabinetClientUpsertWithWhereUniqueWithoutTenantInput | CabinetClientUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CabinetClientCreateManyTenantInputEnvelope
    set?: CabinetClientWhereUniqueInput | CabinetClientWhereUniqueInput[]
    disconnect?: CabinetClientWhereUniqueInput | CabinetClientWhereUniqueInput[]
    delete?: CabinetClientWhereUniqueInput | CabinetClientWhereUniqueInput[]
    connect?: CabinetClientWhereUniqueInput | CabinetClientWhereUniqueInput[]
    update?: CabinetClientUpdateWithWhereUniqueWithoutTenantInput | CabinetClientUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CabinetClientUpdateManyWithWhereWithoutTenantInput | CabinetClientUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CabinetClientScalarWhereInput | CabinetClientScalarWhereInput[]
  }

  export type CabinetAppointmentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CabinetAppointmentCreateWithoutTenantInput, CabinetAppointmentUncheckedCreateWithoutTenantInput> | CabinetAppointmentCreateWithoutTenantInput[] | CabinetAppointmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutTenantInput | CabinetAppointmentCreateOrConnectWithoutTenantInput[]
    upsert?: CabinetAppointmentUpsertWithWhereUniqueWithoutTenantInput | CabinetAppointmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CabinetAppointmentCreateManyTenantInputEnvelope
    set?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    disconnect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    delete?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    update?: CabinetAppointmentUpdateWithWhereUniqueWithoutTenantInput | CabinetAppointmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CabinetAppointmentUpdateManyWithWhereWithoutTenantInput | CabinetAppointmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CabinetAppointmentScalarWhereInput | CabinetAppointmentScalarWhereInput[]
  }

  export type RestaurantDishCreateNestedManyWithoutCategoryInput = {
    create?: XOR<RestaurantDishCreateWithoutCategoryInput, RestaurantDishUncheckedCreateWithoutCategoryInput> | RestaurantDishCreateWithoutCategoryInput[] | RestaurantDishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RestaurantDishCreateOrConnectWithoutCategoryInput | RestaurantDishCreateOrConnectWithoutCategoryInput[]
    createMany?: RestaurantDishCreateManyCategoryInputEnvelope
    connect?: RestaurantDishWhereUniqueInput | RestaurantDishWhereUniqueInput[]
  }

  export type TenantWebsiteCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<TenantWebsiteCreateWithoutCategoriesInput, TenantWebsiteUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutCategoriesInput
    connect?: TenantWebsiteWhereUniqueInput
  }

  export type RestaurantDishUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<RestaurantDishCreateWithoutCategoryInput, RestaurantDishUncheckedCreateWithoutCategoryInput> | RestaurantDishCreateWithoutCategoryInput[] | RestaurantDishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RestaurantDishCreateOrConnectWithoutCategoryInput | RestaurantDishCreateOrConnectWithoutCategoryInput[]
    createMany?: RestaurantDishCreateManyCategoryInputEnvelope
    connect?: RestaurantDishWhereUniqueInput | RestaurantDishWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RestaurantDishUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<RestaurantDishCreateWithoutCategoryInput, RestaurantDishUncheckedCreateWithoutCategoryInput> | RestaurantDishCreateWithoutCategoryInput[] | RestaurantDishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RestaurantDishCreateOrConnectWithoutCategoryInput | RestaurantDishCreateOrConnectWithoutCategoryInput[]
    upsert?: RestaurantDishUpsertWithWhereUniqueWithoutCategoryInput | RestaurantDishUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: RestaurantDishCreateManyCategoryInputEnvelope
    set?: RestaurantDishWhereUniqueInput | RestaurantDishWhereUniqueInput[]
    disconnect?: RestaurantDishWhereUniqueInput | RestaurantDishWhereUniqueInput[]
    delete?: RestaurantDishWhereUniqueInput | RestaurantDishWhereUniqueInput[]
    connect?: RestaurantDishWhereUniqueInput | RestaurantDishWhereUniqueInput[]
    update?: RestaurantDishUpdateWithWhereUniqueWithoutCategoryInput | RestaurantDishUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: RestaurantDishUpdateManyWithWhereWithoutCategoryInput | RestaurantDishUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: RestaurantDishScalarWhereInput | RestaurantDishScalarWhereInput[]
  }

  export type TenantWebsiteUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutCategoriesInput, TenantWebsiteUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutCategoriesInput
    upsert?: TenantWebsiteUpsertWithoutCategoriesInput
    connect?: TenantWebsiteWhereUniqueInput
    update?: XOR<XOR<TenantWebsiteUpdateToOneWithWhereWithoutCategoriesInput, TenantWebsiteUpdateWithoutCategoriesInput>, TenantWebsiteUncheckedUpdateWithoutCategoriesInput>
  }

  export type RestaurantDishUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<RestaurantDishCreateWithoutCategoryInput, RestaurantDishUncheckedCreateWithoutCategoryInput> | RestaurantDishCreateWithoutCategoryInput[] | RestaurantDishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RestaurantDishCreateOrConnectWithoutCategoryInput | RestaurantDishCreateOrConnectWithoutCategoryInput[]
    upsert?: RestaurantDishUpsertWithWhereUniqueWithoutCategoryInput | RestaurantDishUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: RestaurantDishCreateManyCategoryInputEnvelope
    set?: RestaurantDishWhereUniqueInput | RestaurantDishWhereUniqueInput[]
    disconnect?: RestaurantDishWhereUniqueInput | RestaurantDishWhereUniqueInput[]
    delete?: RestaurantDishWhereUniqueInput | RestaurantDishWhereUniqueInput[]
    connect?: RestaurantDishWhereUniqueInput | RestaurantDishWhereUniqueInput[]
    update?: RestaurantDishUpdateWithWhereUniqueWithoutCategoryInput | RestaurantDishUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: RestaurantDishUpdateManyWithWhereWithoutCategoryInput | RestaurantDishUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: RestaurantDishScalarWhereInput | RestaurantDishScalarWhereInput[]
  }

  export type RestaurantCategoryCreateNestedOneWithoutDishesInput = {
    create?: XOR<RestaurantCategoryCreateWithoutDishesInput, RestaurantCategoryUncheckedCreateWithoutDishesInput>
    connectOrCreate?: RestaurantCategoryCreateOrConnectWithoutDishesInput
    connect?: RestaurantCategoryWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RestaurantCategoryUpdateOneRequiredWithoutDishesNestedInput = {
    create?: XOR<RestaurantCategoryCreateWithoutDishesInput, RestaurantCategoryUncheckedCreateWithoutDishesInput>
    connectOrCreate?: RestaurantCategoryCreateOrConnectWithoutDishesInput
    upsert?: RestaurantCategoryUpsertWithoutDishesInput
    connect?: RestaurantCategoryWhereUniqueInput
    update?: XOR<XOR<RestaurantCategoryUpdateToOneWithWhereWithoutDishesInput, RestaurantCategoryUpdateWithoutDishesInput>, RestaurantCategoryUncheckedUpdateWithoutDishesInput>
  }

  export type RestaurantOrderCreateNestedManyWithoutTableInput = {
    create?: XOR<RestaurantOrderCreateWithoutTableInput, RestaurantOrderUncheckedCreateWithoutTableInput> | RestaurantOrderCreateWithoutTableInput[] | RestaurantOrderUncheckedCreateWithoutTableInput[]
    connectOrCreate?: RestaurantOrderCreateOrConnectWithoutTableInput | RestaurantOrderCreateOrConnectWithoutTableInput[]
    createMany?: RestaurantOrderCreateManyTableInputEnvelope
    connect?: RestaurantOrderWhereUniqueInput | RestaurantOrderWhereUniqueInput[]
  }

  export type TenantWebsiteCreateNestedOneWithoutTablesInput = {
    create?: XOR<TenantWebsiteCreateWithoutTablesInput, TenantWebsiteUncheckedCreateWithoutTablesInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutTablesInput
    connect?: TenantWebsiteWhereUniqueInput
  }

  export type RestaurantWaiterCreateNestedOneWithoutTablesInput = {
    create?: XOR<RestaurantWaiterCreateWithoutTablesInput, RestaurantWaiterUncheckedCreateWithoutTablesInput>
    connectOrCreate?: RestaurantWaiterCreateOrConnectWithoutTablesInput
    connect?: RestaurantWaiterWhereUniqueInput
  }

  export type RestaurantOrderUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<RestaurantOrderCreateWithoutTableInput, RestaurantOrderUncheckedCreateWithoutTableInput> | RestaurantOrderCreateWithoutTableInput[] | RestaurantOrderUncheckedCreateWithoutTableInput[]
    connectOrCreate?: RestaurantOrderCreateOrConnectWithoutTableInput | RestaurantOrderCreateOrConnectWithoutTableInput[]
    createMany?: RestaurantOrderCreateManyTableInputEnvelope
    connect?: RestaurantOrderWhereUniqueInput | RestaurantOrderWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RestaurantOrderUpdateManyWithoutTableNestedInput = {
    create?: XOR<RestaurantOrderCreateWithoutTableInput, RestaurantOrderUncheckedCreateWithoutTableInput> | RestaurantOrderCreateWithoutTableInput[] | RestaurantOrderUncheckedCreateWithoutTableInput[]
    connectOrCreate?: RestaurantOrderCreateOrConnectWithoutTableInput | RestaurantOrderCreateOrConnectWithoutTableInput[]
    upsert?: RestaurantOrderUpsertWithWhereUniqueWithoutTableInput | RestaurantOrderUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: RestaurantOrderCreateManyTableInputEnvelope
    set?: RestaurantOrderWhereUniqueInput | RestaurantOrderWhereUniqueInput[]
    disconnect?: RestaurantOrderWhereUniqueInput | RestaurantOrderWhereUniqueInput[]
    delete?: RestaurantOrderWhereUniqueInput | RestaurantOrderWhereUniqueInput[]
    connect?: RestaurantOrderWhereUniqueInput | RestaurantOrderWhereUniqueInput[]
    update?: RestaurantOrderUpdateWithWhereUniqueWithoutTableInput | RestaurantOrderUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: RestaurantOrderUpdateManyWithWhereWithoutTableInput | RestaurantOrderUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: RestaurantOrderScalarWhereInput | RestaurantOrderScalarWhereInput[]
  }

  export type TenantWebsiteUpdateOneRequiredWithoutTablesNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutTablesInput, TenantWebsiteUncheckedCreateWithoutTablesInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutTablesInput
    upsert?: TenantWebsiteUpsertWithoutTablesInput
    connect?: TenantWebsiteWhereUniqueInput
    update?: XOR<XOR<TenantWebsiteUpdateToOneWithWhereWithoutTablesInput, TenantWebsiteUpdateWithoutTablesInput>, TenantWebsiteUncheckedUpdateWithoutTablesInput>
  }

  export type RestaurantWaiterUpdateOneWithoutTablesNestedInput = {
    create?: XOR<RestaurantWaiterCreateWithoutTablesInput, RestaurantWaiterUncheckedCreateWithoutTablesInput>
    connectOrCreate?: RestaurantWaiterCreateOrConnectWithoutTablesInput
    upsert?: RestaurantWaiterUpsertWithoutTablesInput
    disconnect?: RestaurantWaiterWhereInput | boolean
    delete?: RestaurantWaiterWhereInput | boolean
    connect?: RestaurantWaiterWhereUniqueInput
    update?: XOR<XOR<RestaurantWaiterUpdateToOneWithWhereWithoutTablesInput, RestaurantWaiterUpdateWithoutTablesInput>, RestaurantWaiterUncheckedUpdateWithoutTablesInput>
  }

  export type RestaurantOrderUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<RestaurantOrderCreateWithoutTableInput, RestaurantOrderUncheckedCreateWithoutTableInput> | RestaurantOrderCreateWithoutTableInput[] | RestaurantOrderUncheckedCreateWithoutTableInput[]
    connectOrCreate?: RestaurantOrderCreateOrConnectWithoutTableInput | RestaurantOrderCreateOrConnectWithoutTableInput[]
    upsert?: RestaurantOrderUpsertWithWhereUniqueWithoutTableInput | RestaurantOrderUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: RestaurantOrderCreateManyTableInputEnvelope
    set?: RestaurantOrderWhereUniqueInput | RestaurantOrderWhereUniqueInput[]
    disconnect?: RestaurantOrderWhereUniqueInput | RestaurantOrderWhereUniqueInput[]
    delete?: RestaurantOrderWhereUniqueInput | RestaurantOrderWhereUniqueInput[]
    connect?: RestaurantOrderWhereUniqueInput | RestaurantOrderWhereUniqueInput[]
    update?: RestaurantOrderUpdateWithWhereUniqueWithoutTableInput | RestaurantOrderUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: RestaurantOrderUpdateManyWithWhereWithoutTableInput | RestaurantOrderUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: RestaurantOrderScalarWhereInput | RestaurantOrderScalarWhereInput[]
  }

  export type RestaurantTableCreateNestedManyWithoutWaiterInput = {
    create?: XOR<RestaurantTableCreateWithoutWaiterInput, RestaurantTableUncheckedCreateWithoutWaiterInput> | RestaurantTableCreateWithoutWaiterInput[] | RestaurantTableUncheckedCreateWithoutWaiterInput[]
    connectOrCreate?: RestaurantTableCreateOrConnectWithoutWaiterInput | RestaurantTableCreateOrConnectWithoutWaiterInput[]
    createMany?: RestaurantTableCreateManyWaiterInputEnvelope
    connect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
  }

  export type TenantWebsiteCreateNestedOneWithoutWaitersInput = {
    create?: XOR<TenantWebsiteCreateWithoutWaitersInput, TenantWebsiteUncheckedCreateWithoutWaitersInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutWaitersInput
    connect?: TenantWebsiteWhereUniqueInput
  }

  export type RestaurantTableUncheckedCreateNestedManyWithoutWaiterInput = {
    create?: XOR<RestaurantTableCreateWithoutWaiterInput, RestaurantTableUncheckedCreateWithoutWaiterInput> | RestaurantTableCreateWithoutWaiterInput[] | RestaurantTableUncheckedCreateWithoutWaiterInput[]
    connectOrCreate?: RestaurantTableCreateOrConnectWithoutWaiterInput | RestaurantTableCreateOrConnectWithoutWaiterInput[]
    createMany?: RestaurantTableCreateManyWaiterInputEnvelope
    connect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
  }

  export type RestaurantTableUpdateManyWithoutWaiterNestedInput = {
    create?: XOR<RestaurantTableCreateWithoutWaiterInput, RestaurantTableUncheckedCreateWithoutWaiterInput> | RestaurantTableCreateWithoutWaiterInput[] | RestaurantTableUncheckedCreateWithoutWaiterInput[]
    connectOrCreate?: RestaurantTableCreateOrConnectWithoutWaiterInput | RestaurantTableCreateOrConnectWithoutWaiterInput[]
    upsert?: RestaurantTableUpsertWithWhereUniqueWithoutWaiterInput | RestaurantTableUpsertWithWhereUniqueWithoutWaiterInput[]
    createMany?: RestaurantTableCreateManyWaiterInputEnvelope
    set?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    disconnect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    delete?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    connect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    update?: RestaurantTableUpdateWithWhereUniqueWithoutWaiterInput | RestaurantTableUpdateWithWhereUniqueWithoutWaiterInput[]
    updateMany?: RestaurantTableUpdateManyWithWhereWithoutWaiterInput | RestaurantTableUpdateManyWithWhereWithoutWaiterInput[]
    deleteMany?: RestaurantTableScalarWhereInput | RestaurantTableScalarWhereInput[]
  }

  export type TenantWebsiteUpdateOneRequiredWithoutWaitersNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutWaitersInput, TenantWebsiteUncheckedCreateWithoutWaitersInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutWaitersInput
    upsert?: TenantWebsiteUpsertWithoutWaitersInput
    connect?: TenantWebsiteWhereUniqueInput
    update?: XOR<XOR<TenantWebsiteUpdateToOneWithWhereWithoutWaitersInput, TenantWebsiteUpdateWithoutWaitersInput>, TenantWebsiteUncheckedUpdateWithoutWaitersInput>
  }

  export type RestaurantTableUncheckedUpdateManyWithoutWaiterNestedInput = {
    create?: XOR<RestaurantTableCreateWithoutWaiterInput, RestaurantTableUncheckedCreateWithoutWaiterInput> | RestaurantTableCreateWithoutWaiterInput[] | RestaurantTableUncheckedCreateWithoutWaiterInput[]
    connectOrCreate?: RestaurantTableCreateOrConnectWithoutWaiterInput | RestaurantTableCreateOrConnectWithoutWaiterInput[]
    upsert?: RestaurantTableUpsertWithWhereUniqueWithoutWaiterInput | RestaurantTableUpsertWithWhereUniqueWithoutWaiterInput[]
    createMany?: RestaurantTableCreateManyWaiterInputEnvelope
    set?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    disconnect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    delete?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    connect?: RestaurantTableWhereUniqueInput | RestaurantTableWhereUniqueInput[]
    update?: RestaurantTableUpdateWithWhereUniqueWithoutWaiterInput | RestaurantTableUpdateWithWhereUniqueWithoutWaiterInput[]
    updateMany?: RestaurantTableUpdateManyWithWhereWithoutWaiterInput | RestaurantTableUpdateManyWithWhereWithoutWaiterInput[]
    deleteMany?: RestaurantTableScalarWhereInput | RestaurantTableScalarWhereInput[]
  }

  export type RestaurantOrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<RestaurantOrderItemCreateWithoutOrderInput, RestaurantOrderItemUncheckedCreateWithoutOrderInput> | RestaurantOrderItemCreateWithoutOrderInput[] | RestaurantOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RestaurantOrderItemCreateOrConnectWithoutOrderInput | RestaurantOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: RestaurantOrderItemCreateManyOrderInputEnvelope
    connect?: RestaurantOrderItemWhereUniqueInput | RestaurantOrderItemWhereUniqueInput[]
  }

  export type RestaurantTableCreateNestedOneWithoutOrdersInput = {
    create?: XOR<RestaurantTableCreateWithoutOrdersInput, RestaurantTableUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: RestaurantTableCreateOrConnectWithoutOrdersInput
    connect?: RestaurantTableWhereUniqueInput
  }

  export type RestaurantOrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<RestaurantOrderItemCreateWithoutOrderInput, RestaurantOrderItemUncheckedCreateWithoutOrderInput> | RestaurantOrderItemCreateWithoutOrderInput[] | RestaurantOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RestaurantOrderItemCreateOrConnectWithoutOrderInput | RestaurantOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: RestaurantOrderItemCreateManyOrderInputEnvelope
    connect?: RestaurantOrderItemWhereUniqueInput | RestaurantOrderItemWhereUniqueInput[]
  }

  export type RestaurantOrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RestaurantOrderItemCreateWithoutOrderInput, RestaurantOrderItemUncheckedCreateWithoutOrderInput> | RestaurantOrderItemCreateWithoutOrderInput[] | RestaurantOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RestaurantOrderItemCreateOrConnectWithoutOrderInput | RestaurantOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: RestaurantOrderItemUpsertWithWhereUniqueWithoutOrderInput | RestaurantOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RestaurantOrderItemCreateManyOrderInputEnvelope
    set?: RestaurantOrderItemWhereUniqueInput | RestaurantOrderItemWhereUniqueInput[]
    disconnect?: RestaurantOrderItemWhereUniqueInput | RestaurantOrderItemWhereUniqueInput[]
    delete?: RestaurantOrderItemWhereUniqueInput | RestaurantOrderItemWhereUniqueInput[]
    connect?: RestaurantOrderItemWhereUniqueInput | RestaurantOrderItemWhereUniqueInput[]
    update?: RestaurantOrderItemUpdateWithWhereUniqueWithoutOrderInput | RestaurantOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RestaurantOrderItemUpdateManyWithWhereWithoutOrderInput | RestaurantOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RestaurantOrderItemScalarWhereInput | RestaurantOrderItemScalarWhereInput[]
  }

  export type RestaurantTableUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<RestaurantTableCreateWithoutOrdersInput, RestaurantTableUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: RestaurantTableCreateOrConnectWithoutOrdersInput
    upsert?: RestaurantTableUpsertWithoutOrdersInput
    connect?: RestaurantTableWhereUniqueInput
    update?: XOR<XOR<RestaurantTableUpdateToOneWithWhereWithoutOrdersInput, RestaurantTableUpdateWithoutOrdersInput>, RestaurantTableUncheckedUpdateWithoutOrdersInput>
  }

  export type RestaurantOrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RestaurantOrderItemCreateWithoutOrderInput, RestaurantOrderItemUncheckedCreateWithoutOrderInput> | RestaurantOrderItemCreateWithoutOrderInput[] | RestaurantOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RestaurantOrderItemCreateOrConnectWithoutOrderInput | RestaurantOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: RestaurantOrderItemUpsertWithWhereUniqueWithoutOrderInput | RestaurantOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RestaurantOrderItemCreateManyOrderInputEnvelope
    set?: RestaurantOrderItemWhereUniqueInput | RestaurantOrderItemWhereUniqueInput[]
    disconnect?: RestaurantOrderItemWhereUniqueInput | RestaurantOrderItemWhereUniqueInput[]
    delete?: RestaurantOrderItemWhereUniqueInput | RestaurantOrderItemWhereUniqueInput[]
    connect?: RestaurantOrderItemWhereUniqueInput | RestaurantOrderItemWhereUniqueInput[]
    update?: RestaurantOrderItemUpdateWithWhereUniqueWithoutOrderInput | RestaurantOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RestaurantOrderItemUpdateManyWithWhereWithoutOrderInput | RestaurantOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RestaurantOrderItemScalarWhereInput | RestaurantOrderItemScalarWhereInput[]
  }

  export type RestaurantOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<RestaurantOrderCreateWithoutItemsInput, RestaurantOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: RestaurantOrderCreateOrConnectWithoutItemsInput
    connect?: RestaurantOrderWhereUniqueInput
  }

  export type RestaurantOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<RestaurantOrderCreateWithoutItemsInput, RestaurantOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: RestaurantOrderCreateOrConnectWithoutItemsInput
    upsert?: RestaurantOrderUpsertWithoutItemsInput
    connect?: RestaurantOrderWhereUniqueInput
    update?: XOR<XOR<RestaurantOrderUpdateToOneWithWhereWithoutItemsInput, RestaurantOrderUpdateWithoutItemsInput>, RestaurantOrderUncheckedUpdateWithoutItemsInput>
  }

  export type CabinetAppointmentCreateNestedManyWithoutServiceInput = {
    create?: XOR<CabinetAppointmentCreateWithoutServiceInput, CabinetAppointmentUncheckedCreateWithoutServiceInput> | CabinetAppointmentCreateWithoutServiceInput[] | CabinetAppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutServiceInput | CabinetAppointmentCreateOrConnectWithoutServiceInput[]
    createMany?: CabinetAppointmentCreateManyServiceInputEnvelope
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
  }

  export type TenantWebsiteCreateNestedOneWithoutCabinetServicesInput = {
    create?: XOR<TenantWebsiteCreateWithoutCabinetServicesInput, TenantWebsiteUncheckedCreateWithoutCabinetServicesInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutCabinetServicesInput
    connect?: TenantWebsiteWhereUniqueInput
  }

  export type CabinetAppointmentUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<CabinetAppointmentCreateWithoutServiceInput, CabinetAppointmentUncheckedCreateWithoutServiceInput> | CabinetAppointmentCreateWithoutServiceInput[] | CabinetAppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutServiceInput | CabinetAppointmentCreateOrConnectWithoutServiceInput[]
    createMany?: CabinetAppointmentCreateManyServiceInputEnvelope
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
  }

  export type CabinetAppointmentUpdateManyWithoutServiceNestedInput = {
    create?: XOR<CabinetAppointmentCreateWithoutServiceInput, CabinetAppointmentUncheckedCreateWithoutServiceInput> | CabinetAppointmentCreateWithoutServiceInput[] | CabinetAppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutServiceInput | CabinetAppointmentCreateOrConnectWithoutServiceInput[]
    upsert?: CabinetAppointmentUpsertWithWhereUniqueWithoutServiceInput | CabinetAppointmentUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: CabinetAppointmentCreateManyServiceInputEnvelope
    set?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    disconnect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    delete?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    update?: CabinetAppointmentUpdateWithWhereUniqueWithoutServiceInput | CabinetAppointmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: CabinetAppointmentUpdateManyWithWhereWithoutServiceInput | CabinetAppointmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: CabinetAppointmentScalarWhereInput | CabinetAppointmentScalarWhereInput[]
  }

  export type TenantWebsiteUpdateOneRequiredWithoutCabinetServicesNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutCabinetServicesInput, TenantWebsiteUncheckedCreateWithoutCabinetServicesInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutCabinetServicesInput
    upsert?: TenantWebsiteUpsertWithoutCabinetServicesInput
    connect?: TenantWebsiteWhereUniqueInput
    update?: XOR<XOR<TenantWebsiteUpdateToOneWithWhereWithoutCabinetServicesInput, TenantWebsiteUpdateWithoutCabinetServicesInput>, TenantWebsiteUncheckedUpdateWithoutCabinetServicesInput>
  }

  export type CabinetAppointmentUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<CabinetAppointmentCreateWithoutServiceInput, CabinetAppointmentUncheckedCreateWithoutServiceInput> | CabinetAppointmentCreateWithoutServiceInput[] | CabinetAppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutServiceInput | CabinetAppointmentCreateOrConnectWithoutServiceInput[]
    upsert?: CabinetAppointmentUpsertWithWhereUniqueWithoutServiceInput | CabinetAppointmentUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: CabinetAppointmentCreateManyServiceInputEnvelope
    set?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    disconnect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    delete?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    update?: CabinetAppointmentUpdateWithWhereUniqueWithoutServiceInput | CabinetAppointmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: CabinetAppointmentUpdateManyWithWhereWithoutServiceInput | CabinetAppointmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: CabinetAppointmentScalarWhereInput | CabinetAppointmentScalarWhereInput[]
  }

  export type CabinetAppointmentCreateNestedManyWithoutClientInput = {
    create?: XOR<CabinetAppointmentCreateWithoutClientInput, CabinetAppointmentUncheckedCreateWithoutClientInput> | CabinetAppointmentCreateWithoutClientInput[] | CabinetAppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutClientInput | CabinetAppointmentCreateOrConnectWithoutClientInput[]
    createMany?: CabinetAppointmentCreateManyClientInputEnvelope
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
  }

  export type TenantWebsiteCreateNestedOneWithoutCabinetClientsInput = {
    create?: XOR<TenantWebsiteCreateWithoutCabinetClientsInput, TenantWebsiteUncheckedCreateWithoutCabinetClientsInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutCabinetClientsInput
    connect?: TenantWebsiteWhereUniqueInput
  }

  export type CabinetAppointmentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<CabinetAppointmentCreateWithoutClientInput, CabinetAppointmentUncheckedCreateWithoutClientInput> | CabinetAppointmentCreateWithoutClientInput[] | CabinetAppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutClientInput | CabinetAppointmentCreateOrConnectWithoutClientInput[]
    createMany?: CabinetAppointmentCreateManyClientInputEnvelope
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
  }

  export type CabinetAppointmentUpdateManyWithoutClientNestedInput = {
    create?: XOR<CabinetAppointmentCreateWithoutClientInput, CabinetAppointmentUncheckedCreateWithoutClientInput> | CabinetAppointmentCreateWithoutClientInput[] | CabinetAppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutClientInput | CabinetAppointmentCreateOrConnectWithoutClientInput[]
    upsert?: CabinetAppointmentUpsertWithWhereUniqueWithoutClientInput | CabinetAppointmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CabinetAppointmentCreateManyClientInputEnvelope
    set?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    disconnect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    delete?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    update?: CabinetAppointmentUpdateWithWhereUniqueWithoutClientInput | CabinetAppointmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CabinetAppointmentUpdateManyWithWhereWithoutClientInput | CabinetAppointmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CabinetAppointmentScalarWhereInput | CabinetAppointmentScalarWhereInput[]
  }

  export type TenantWebsiteUpdateOneRequiredWithoutCabinetClientsNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutCabinetClientsInput, TenantWebsiteUncheckedCreateWithoutCabinetClientsInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutCabinetClientsInput
    upsert?: TenantWebsiteUpsertWithoutCabinetClientsInput
    connect?: TenantWebsiteWhereUniqueInput
    update?: XOR<XOR<TenantWebsiteUpdateToOneWithWhereWithoutCabinetClientsInput, TenantWebsiteUpdateWithoutCabinetClientsInput>, TenantWebsiteUncheckedUpdateWithoutCabinetClientsInput>
  }

  export type CabinetAppointmentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<CabinetAppointmentCreateWithoutClientInput, CabinetAppointmentUncheckedCreateWithoutClientInput> | CabinetAppointmentCreateWithoutClientInput[] | CabinetAppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CabinetAppointmentCreateOrConnectWithoutClientInput | CabinetAppointmentCreateOrConnectWithoutClientInput[]
    upsert?: CabinetAppointmentUpsertWithWhereUniqueWithoutClientInput | CabinetAppointmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CabinetAppointmentCreateManyClientInputEnvelope
    set?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    disconnect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    delete?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    connect?: CabinetAppointmentWhereUniqueInput | CabinetAppointmentWhereUniqueInput[]
    update?: CabinetAppointmentUpdateWithWhereUniqueWithoutClientInput | CabinetAppointmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CabinetAppointmentUpdateManyWithWhereWithoutClientInput | CabinetAppointmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CabinetAppointmentScalarWhereInput | CabinetAppointmentScalarWhereInput[]
  }

  export type CabinetServiceCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<CabinetServiceCreateWithoutAppointmentsInput, CabinetServiceUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: CabinetServiceCreateOrConnectWithoutAppointmentsInput
    connect?: CabinetServiceWhereUniqueInput
  }

  export type CabinetClientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<CabinetClientCreateWithoutAppointmentsInput, CabinetClientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: CabinetClientCreateOrConnectWithoutAppointmentsInput
    connect?: CabinetClientWhereUniqueInput
  }

  export type TenantWebsiteCreateNestedOneWithoutCabinetAppointmentsInput = {
    create?: XOR<TenantWebsiteCreateWithoutCabinetAppointmentsInput, TenantWebsiteUncheckedCreateWithoutCabinetAppointmentsInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutCabinetAppointmentsInput
    connect?: TenantWebsiteWhereUniqueInput
  }

  export type CabinetServiceUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<CabinetServiceCreateWithoutAppointmentsInput, CabinetServiceUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: CabinetServiceCreateOrConnectWithoutAppointmentsInput
    upsert?: CabinetServiceUpsertWithoutAppointmentsInput
    connect?: CabinetServiceWhereUniqueInput
    update?: XOR<XOR<CabinetServiceUpdateToOneWithWhereWithoutAppointmentsInput, CabinetServiceUpdateWithoutAppointmentsInput>, CabinetServiceUncheckedUpdateWithoutAppointmentsInput>
  }

  export type CabinetClientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<CabinetClientCreateWithoutAppointmentsInput, CabinetClientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: CabinetClientCreateOrConnectWithoutAppointmentsInput
    upsert?: CabinetClientUpsertWithoutAppointmentsInput
    connect?: CabinetClientWhereUniqueInput
    update?: XOR<XOR<CabinetClientUpdateToOneWithWhereWithoutAppointmentsInput, CabinetClientUpdateWithoutAppointmentsInput>, CabinetClientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type TenantWebsiteUpdateOneRequiredWithoutCabinetAppointmentsNestedInput = {
    create?: XOR<TenantWebsiteCreateWithoutCabinetAppointmentsInput, TenantWebsiteUncheckedCreateWithoutCabinetAppointmentsInput>
    connectOrCreate?: TenantWebsiteCreateOrConnectWithoutCabinetAppointmentsInput
    upsert?: TenantWebsiteUpsertWithoutCabinetAppointmentsInput
    connect?: TenantWebsiteWhereUniqueInput
    update?: XOR<XOR<TenantWebsiteUpdateToOneWithWhereWithoutCabinetAppointmentsInput, TenantWebsiteUpdateWithoutCabinetAppointmentsInput>, TenantWebsiteUncheckedUpdateWithoutCabinetAppointmentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserServiceCreateWithoutUserInput = {
    id?: string
    notify?: boolean
    selectedAt?: Date | string
    service: ServiceCreateNestedOneWithoutUsersInput
  }

  export type UserServiceUncheckedCreateWithoutUserInput = {
    id?: string
    serviceId: string
    notify?: boolean
    selectedAt?: Date | string
  }

  export type UserServiceCreateOrConnectWithoutUserInput = {
    where: UserServiceWhereUniqueInput
    create: XOR<UserServiceCreateWithoutUserInput, UserServiceUncheckedCreateWithoutUserInput>
  }

  export type UserServiceCreateManyUserInputEnvelope = {
    data: UserServiceCreateManyUserInput | UserServiceCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type TenantWebsiteCreateWithoutUserInput = {
    id?: string
    slug: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentCreateNestedManyWithoutTenantInput
    service: ServiceCreateNestedOneWithoutWebsitesInput
  }

  export type TenantWebsiteUncheckedCreateWithoutUserInput = {
    id?: string
    slug: string
    serviceId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryUncheckedCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableUncheckedCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterUncheckedCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceUncheckedCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientUncheckedCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantWebsiteCreateOrConnectWithoutUserInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutUserInput, TenantWebsiteUncheckedCreateWithoutUserInput>
  }

  export type TenantWebsiteCreateManyUserInputEnvelope = {
    data: TenantWebsiteCreateManyUserInput | TenantWebsiteCreateManyUserInput[]
  }

  export type ChatSessionCreateWithoutUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUncheckedCreateWithoutUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionCreateOrConnectWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionCreateManyUserInputEnvelope = {
    data: ChatSessionCreateManyUserInput | ChatSessionCreateManyUserInput[]
  }

  export type UserServiceUpsertWithWhereUniqueWithoutUserInput = {
    where: UserServiceWhereUniqueInput
    update: XOR<UserServiceUpdateWithoutUserInput, UserServiceUncheckedUpdateWithoutUserInput>
    create: XOR<UserServiceCreateWithoutUserInput, UserServiceUncheckedCreateWithoutUserInput>
  }

  export type UserServiceUpdateWithWhereUniqueWithoutUserInput = {
    where: UserServiceWhereUniqueInput
    data: XOR<UserServiceUpdateWithoutUserInput, UserServiceUncheckedUpdateWithoutUserInput>
  }

  export type UserServiceUpdateManyWithWhereWithoutUserInput = {
    where: UserServiceScalarWhereInput
    data: XOR<UserServiceUpdateManyMutationInput, UserServiceUncheckedUpdateManyWithoutUserInput>
  }

  export type UserServiceScalarWhereInput = {
    AND?: UserServiceScalarWhereInput | UserServiceScalarWhereInput[]
    OR?: UserServiceScalarWhereInput[]
    NOT?: UserServiceScalarWhereInput | UserServiceScalarWhereInput[]
    id?: StringFilter<"UserService"> | string
    userId?: StringFilter<"UserService"> | string
    serviceId?: StringFilter<"UserService"> | string
    notify?: BoolFilter<"UserService"> | boolean
    selectedAt?: DateTimeFilter<"UserService"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type TenantWebsiteUpsertWithWhereUniqueWithoutUserInput = {
    where: TenantWebsiteWhereUniqueInput
    update: XOR<TenantWebsiteUpdateWithoutUserInput, TenantWebsiteUncheckedUpdateWithoutUserInput>
    create: XOR<TenantWebsiteCreateWithoutUserInput, TenantWebsiteUncheckedCreateWithoutUserInput>
  }

  export type TenantWebsiteUpdateWithWhereUniqueWithoutUserInput = {
    where: TenantWebsiteWhereUniqueInput
    data: XOR<TenantWebsiteUpdateWithoutUserInput, TenantWebsiteUncheckedUpdateWithoutUserInput>
  }

  export type TenantWebsiteUpdateManyWithWhereWithoutUserInput = {
    where: TenantWebsiteScalarWhereInput
    data: XOR<TenantWebsiteUpdateManyMutationInput, TenantWebsiteUncheckedUpdateManyWithoutUserInput>
  }

  export type TenantWebsiteScalarWhereInput = {
    AND?: TenantWebsiteScalarWhereInput | TenantWebsiteScalarWhereInput[]
    OR?: TenantWebsiteScalarWhereInput[]
    NOT?: TenantWebsiteScalarWhereInput | TenantWebsiteScalarWhereInput[]
    id?: StringFilter<"TenantWebsite"> | string
    slug?: StringFilter<"TenantWebsite"> | string
    userId?: StringFilter<"TenantWebsite"> | string
    serviceId?: StringFilter<"TenantWebsite"> | string
    siteName?: StringFilter<"TenantWebsite"> | string
    description?: StringNullableFilter<"TenantWebsite"> | string | null
    logo?: StringNullableFilter<"TenantWebsite"> | string | null
    coverImage?: StringNullableFilter<"TenantWebsite"> | string | null
    primaryColor?: StringFilter<"TenantWebsite"> | string
    config?: StringFilter<"TenantWebsite"> | string
    designTemplate?: StringFilter<"TenantWebsite"> | string
    isActive?: BoolFilter<"TenantWebsite"> | boolean
    createdAt?: DateTimeFilter<"TenantWebsite"> | Date | string
    updatedAt?: DateTimeFilter<"TenantWebsite"> | Date | string
  }

  export type ChatSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    update: XOR<ChatSessionUpdateWithoutUserInput, ChatSessionUncheckedUpdateWithoutUserInput>
    create: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    data: XOR<ChatSessionUpdateWithoutUserInput, ChatSessionUncheckedUpdateWithoutUserInput>
  }

  export type ChatSessionUpdateManyWithWhereWithoutUserInput = {
    where: ChatSessionScalarWhereInput
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatSessionScalarWhereInput = {
    AND?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
    OR?: ChatSessionScalarWhereInput[]
    NOT?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
    id?: StringFilter<"ChatSession"> | string
    userId?: StringFilter<"ChatSession"> | string
    title?: StringNullableFilter<"ChatSession"> | string | null
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
  }

  export type ChatMessageCreateWithoutSessionInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUncheckedCreateWithoutSessionInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput>
  }

  export type ChatMessageCreateManySessionInputEnvelope = {
    data: ChatMessageCreateManySessionInput | ChatMessageCreateManySessionInput[]
  }

  export type UserCreateWithoutChatSessionsInput = {
    id?: string
    email: string
    password: string
    companyName: string
    role?: string
    createdAt?: Date | string
    services?: UserServiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    websites?: TenantWebsiteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatSessionsInput = {
    id?: string
    email: string
    password: string
    companyName: string
    role?: string
    createdAt?: Date | string
    services?: UserServiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSessionInput, ChatMessageUncheckedUpdateWithoutSessionInput>
    create: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSessionInput, ChatMessageUncheckedUpdateWithoutSessionInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSessionInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    sessionId?: StringFilter<"ChatMessage"> | string
    role?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type UserUpsertWithoutChatSessionsInput = {
    update: XOR<UserUpdateWithoutChatSessionsInput, UserUncheckedUpdateWithoutChatSessionsInput>
    create: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatSessionsInput, UserUncheckedUpdateWithoutChatSessionsInput>
  }

  export type UserUpdateWithoutChatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: UserServiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    websites?: TenantWebsiteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: UserServiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatSessionCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutChatSessionsInput
  }

  export type ChatSessionUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatSessionCreateOrConnectWithoutMessagesInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
  }

  export type ChatSessionUpsertWithoutMessagesInput = {
    update: XOR<ChatSessionUpdateWithoutMessagesInput, ChatSessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    where?: ChatSessionWhereInput
  }

  export type ChatSessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatSessionWhereInput
    data: XOR<ChatSessionUpdateWithoutMessagesInput, ChatSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatSessionUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatSessionsNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    companyName: string
    role?: string
    createdAt?: Date | string
    services?: UserServiceCreateNestedManyWithoutUserInput
    websites?: TenantWebsiteCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    companyName: string
    role?: string
    createdAt?: Date | string
    services?: UserServiceUncheckedCreateNestedManyWithoutUserInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: UserServiceUpdateManyWithoutUserNestedInput
    websites?: TenantWebsiteUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: UserServiceUncheckedUpdateManyWithoutUserNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserServiceCreateWithoutServiceInput = {
    id?: string
    notify?: boolean
    selectedAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
  }

  export type UserServiceUncheckedCreateWithoutServiceInput = {
    id?: string
    userId: string
    notify?: boolean
    selectedAt?: Date | string
  }

  export type UserServiceCreateOrConnectWithoutServiceInput = {
    where: UserServiceWhereUniqueInput
    create: XOR<UserServiceCreateWithoutServiceInput, UserServiceUncheckedCreateWithoutServiceInput>
  }

  export type UserServiceCreateManyServiceInputEnvelope = {
    data: UserServiceCreateManyServiceInput | UserServiceCreateManyServiceInput[]
  }

  export type TenantWebsiteCreateWithoutServiceInput = {
    id?: string
    slug: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentCreateNestedManyWithoutTenantInput
    user: UserCreateNestedOneWithoutWebsitesInput
  }

  export type TenantWebsiteUncheckedCreateWithoutServiceInput = {
    id?: string
    slug: string
    userId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryUncheckedCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableUncheckedCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterUncheckedCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceUncheckedCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientUncheckedCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantWebsiteCreateOrConnectWithoutServiceInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutServiceInput, TenantWebsiteUncheckedCreateWithoutServiceInput>
  }

  export type TenantWebsiteCreateManyServiceInputEnvelope = {
    data: TenantWebsiteCreateManyServiceInput | TenantWebsiteCreateManyServiceInput[]
  }

  export type UserServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: UserServiceWhereUniqueInput
    update: XOR<UserServiceUpdateWithoutServiceInput, UserServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<UserServiceCreateWithoutServiceInput, UserServiceUncheckedCreateWithoutServiceInput>
  }

  export type UserServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: UserServiceWhereUniqueInput
    data: XOR<UserServiceUpdateWithoutServiceInput, UserServiceUncheckedUpdateWithoutServiceInput>
  }

  export type UserServiceUpdateManyWithWhereWithoutServiceInput = {
    where: UserServiceScalarWhereInput
    data: XOR<UserServiceUpdateManyMutationInput, UserServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type TenantWebsiteUpsertWithWhereUniqueWithoutServiceInput = {
    where: TenantWebsiteWhereUniqueInput
    update: XOR<TenantWebsiteUpdateWithoutServiceInput, TenantWebsiteUncheckedUpdateWithoutServiceInput>
    create: XOR<TenantWebsiteCreateWithoutServiceInput, TenantWebsiteUncheckedCreateWithoutServiceInput>
  }

  export type TenantWebsiteUpdateWithWhereUniqueWithoutServiceInput = {
    where: TenantWebsiteWhereUniqueInput
    data: XOR<TenantWebsiteUpdateWithoutServiceInput, TenantWebsiteUncheckedUpdateWithoutServiceInput>
  }

  export type TenantWebsiteUpdateManyWithWhereWithoutServiceInput = {
    where: TenantWebsiteScalarWhereInput
    data: XOR<TenantWebsiteUpdateManyMutationInput, TenantWebsiteUncheckedUpdateManyWithoutServiceInput>
  }

  export type UserCreateWithoutServicesInput = {
    id?: string
    email: string
    password: string
    companyName: string
    role?: string
    createdAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutUserInput
    websites?: TenantWebsiteCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServicesInput = {
    id?: string
    email: string
    password: string
    companyName: string
    role?: string
    createdAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    category?: string | null
    createdAt?: Date | string
    websites?: TenantWebsiteCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    category?: string | null
    createdAt?: Date | string
    websites?: TenantWebsiteUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutUsersInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutServicesInput = {
    update: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
  }

  export type UserUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    websites?: TenantWebsiteUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    websites?: TenantWebsiteUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceUpsertWithoutUsersInput = {
    update: XOR<ServiceUpdateWithoutUsersInput, ServiceUncheckedUpdateWithoutUsersInput>
    create: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutUsersInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutUsersInput, ServiceUncheckedUpdateWithoutUsersInput>
  }

  export type ServiceUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    websites?: TenantWebsiteUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    websites?: TenantWebsiteUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type RestaurantCategoryCreateWithoutTenantInput = {
    id?: string
    name: string
    order?: number
    isActive?: boolean
    dishes?: RestaurantDishCreateNestedManyWithoutCategoryInput
  }

  export type RestaurantCategoryUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    order?: number
    isActive?: boolean
    dishes?: RestaurantDishUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type RestaurantCategoryCreateOrConnectWithoutTenantInput = {
    where: RestaurantCategoryWhereUniqueInput
    create: XOR<RestaurantCategoryCreateWithoutTenantInput, RestaurantCategoryUncheckedCreateWithoutTenantInput>
  }

  export type RestaurantCategoryCreateManyTenantInputEnvelope = {
    data: RestaurantCategoryCreateManyTenantInput | RestaurantCategoryCreateManyTenantInput[]
  }

  export type RestaurantTableCreateWithoutTenantInput = {
    id?: string
    number: string
    capacity?: number | null
    isActive?: boolean
    orders?: RestaurantOrderCreateNestedManyWithoutTableInput
    waiter?: RestaurantWaiterCreateNestedOneWithoutTablesInput
  }

  export type RestaurantTableUncheckedCreateWithoutTenantInput = {
    id?: string
    number: string
    capacity?: number | null
    isActive?: boolean
    waiterId?: string | null
    orders?: RestaurantOrderUncheckedCreateNestedManyWithoutTableInput
  }

  export type RestaurantTableCreateOrConnectWithoutTenantInput = {
    where: RestaurantTableWhereUniqueInput
    create: XOR<RestaurantTableCreateWithoutTenantInput, RestaurantTableUncheckedCreateWithoutTenantInput>
  }

  export type RestaurantTableCreateManyTenantInputEnvelope = {
    data: RestaurantTableCreateManyTenantInput | RestaurantTableCreateManyTenantInput[]
  }

  export type RestaurantWaiterCreateWithoutTenantInput = {
    id?: string
    name: string
    pin: string
    isActive?: boolean
    createdAt?: Date | string
    tables?: RestaurantTableCreateNestedManyWithoutWaiterInput
  }

  export type RestaurantWaiterUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    pin: string
    isActive?: boolean
    createdAt?: Date | string
    tables?: RestaurantTableUncheckedCreateNestedManyWithoutWaiterInput
  }

  export type RestaurantWaiterCreateOrConnectWithoutTenantInput = {
    where: RestaurantWaiterWhereUniqueInput
    create: XOR<RestaurantWaiterCreateWithoutTenantInput, RestaurantWaiterUncheckedCreateWithoutTenantInput>
  }

  export type RestaurantWaiterCreateManyTenantInputEnvelope = {
    data: RestaurantWaiterCreateManyTenantInput | RestaurantWaiterCreateManyTenantInput[]
  }

  export type CabinetServiceCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    appointments?: CabinetAppointmentCreateNestedManyWithoutServiceInput
  }

  export type CabinetServiceUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    appointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutServiceInput
  }

  export type CabinetServiceCreateOrConnectWithoutTenantInput = {
    where: CabinetServiceWhereUniqueInput
    create: XOR<CabinetServiceCreateWithoutTenantInput, CabinetServiceUncheckedCreateWithoutTenantInput>
  }

  export type CabinetServiceCreateManyTenantInputEnvelope = {
    data: CabinetServiceCreateManyTenantInput | CabinetServiceCreateManyTenantInput[]
  }

  export type CabinetClientCreateWithoutTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: CabinetAppointmentCreateNestedManyWithoutClientInput
  }

  export type CabinetClientUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutClientInput
  }

  export type CabinetClientCreateOrConnectWithoutTenantInput = {
    where: CabinetClientWhereUniqueInput
    create: XOR<CabinetClientCreateWithoutTenantInput, CabinetClientUncheckedCreateWithoutTenantInput>
  }

  export type CabinetClientCreateManyTenantInputEnvelope = {
    data: CabinetClientCreateManyTenantInput | CabinetClientCreateManyTenantInput[]
  }

  export type CabinetAppointmentCreateWithoutTenantInput = {
    id?: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: CabinetServiceCreateNestedOneWithoutAppointmentsInput
    client: CabinetClientCreateNestedOneWithoutAppointmentsInput
  }

  export type CabinetAppointmentUncheckedCreateWithoutTenantInput = {
    id?: string
    serviceId: string
    clientId: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetAppointmentCreateOrConnectWithoutTenantInput = {
    where: CabinetAppointmentWhereUniqueInput
    create: XOR<CabinetAppointmentCreateWithoutTenantInput, CabinetAppointmentUncheckedCreateWithoutTenantInput>
  }

  export type CabinetAppointmentCreateManyTenantInputEnvelope = {
    data: CabinetAppointmentCreateManyTenantInput | CabinetAppointmentCreateManyTenantInput[]
  }

  export type UserCreateWithoutWebsitesInput = {
    id?: string
    email: string
    password: string
    companyName: string
    role?: string
    createdAt?: Date | string
    services?: UserServiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWebsitesInput = {
    id?: string
    email: string
    password: string
    companyName: string
    role?: string
    createdAt?: Date | string
    services?: UserServiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWebsitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWebsitesInput, UserUncheckedCreateWithoutWebsitesInput>
  }

  export type ServiceCreateWithoutWebsitesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    category?: string | null
    createdAt?: Date | string
    users?: UserServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutWebsitesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    category?: string | null
    createdAt?: Date | string
    users?: UserServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutWebsitesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutWebsitesInput, ServiceUncheckedCreateWithoutWebsitesInput>
  }

  export type RestaurantCategoryUpsertWithWhereUniqueWithoutTenantInput = {
    where: RestaurantCategoryWhereUniqueInput
    update: XOR<RestaurantCategoryUpdateWithoutTenantInput, RestaurantCategoryUncheckedUpdateWithoutTenantInput>
    create: XOR<RestaurantCategoryCreateWithoutTenantInput, RestaurantCategoryUncheckedCreateWithoutTenantInput>
  }

  export type RestaurantCategoryUpdateWithWhereUniqueWithoutTenantInput = {
    where: RestaurantCategoryWhereUniqueInput
    data: XOR<RestaurantCategoryUpdateWithoutTenantInput, RestaurantCategoryUncheckedUpdateWithoutTenantInput>
  }

  export type RestaurantCategoryUpdateManyWithWhereWithoutTenantInput = {
    where: RestaurantCategoryScalarWhereInput
    data: XOR<RestaurantCategoryUpdateManyMutationInput, RestaurantCategoryUncheckedUpdateManyWithoutTenantInput>
  }

  export type RestaurantCategoryScalarWhereInput = {
    AND?: RestaurantCategoryScalarWhereInput | RestaurantCategoryScalarWhereInput[]
    OR?: RestaurantCategoryScalarWhereInput[]
    NOT?: RestaurantCategoryScalarWhereInput | RestaurantCategoryScalarWhereInput[]
    id?: StringFilter<"RestaurantCategory"> | string
    tenantId?: StringFilter<"RestaurantCategory"> | string
    name?: StringFilter<"RestaurantCategory"> | string
    order?: IntFilter<"RestaurantCategory"> | number
    isActive?: BoolFilter<"RestaurantCategory"> | boolean
  }

  export type RestaurantTableUpsertWithWhereUniqueWithoutTenantInput = {
    where: RestaurantTableWhereUniqueInput
    update: XOR<RestaurantTableUpdateWithoutTenantInput, RestaurantTableUncheckedUpdateWithoutTenantInput>
    create: XOR<RestaurantTableCreateWithoutTenantInput, RestaurantTableUncheckedCreateWithoutTenantInput>
  }

  export type RestaurantTableUpdateWithWhereUniqueWithoutTenantInput = {
    where: RestaurantTableWhereUniqueInput
    data: XOR<RestaurantTableUpdateWithoutTenantInput, RestaurantTableUncheckedUpdateWithoutTenantInput>
  }

  export type RestaurantTableUpdateManyWithWhereWithoutTenantInput = {
    where: RestaurantTableScalarWhereInput
    data: XOR<RestaurantTableUpdateManyMutationInput, RestaurantTableUncheckedUpdateManyWithoutTenantInput>
  }

  export type RestaurantTableScalarWhereInput = {
    AND?: RestaurantTableScalarWhereInput | RestaurantTableScalarWhereInput[]
    OR?: RestaurantTableScalarWhereInput[]
    NOT?: RestaurantTableScalarWhereInput | RestaurantTableScalarWhereInput[]
    id?: StringFilter<"RestaurantTable"> | string
    tenantId?: StringFilter<"RestaurantTable"> | string
    number?: StringFilter<"RestaurantTable"> | string
    capacity?: IntNullableFilter<"RestaurantTable"> | number | null
    isActive?: BoolFilter<"RestaurantTable"> | boolean
    waiterId?: StringNullableFilter<"RestaurantTable"> | string | null
  }

  export type RestaurantWaiterUpsertWithWhereUniqueWithoutTenantInput = {
    where: RestaurantWaiterWhereUniqueInput
    update: XOR<RestaurantWaiterUpdateWithoutTenantInput, RestaurantWaiterUncheckedUpdateWithoutTenantInput>
    create: XOR<RestaurantWaiterCreateWithoutTenantInput, RestaurantWaiterUncheckedCreateWithoutTenantInput>
  }

  export type RestaurantWaiterUpdateWithWhereUniqueWithoutTenantInput = {
    where: RestaurantWaiterWhereUniqueInput
    data: XOR<RestaurantWaiterUpdateWithoutTenantInput, RestaurantWaiterUncheckedUpdateWithoutTenantInput>
  }

  export type RestaurantWaiterUpdateManyWithWhereWithoutTenantInput = {
    where: RestaurantWaiterScalarWhereInput
    data: XOR<RestaurantWaiterUpdateManyMutationInput, RestaurantWaiterUncheckedUpdateManyWithoutTenantInput>
  }

  export type RestaurantWaiterScalarWhereInput = {
    AND?: RestaurantWaiterScalarWhereInput | RestaurantWaiterScalarWhereInput[]
    OR?: RestaurantWaiterScalarWhereInput[]
    NOT?: RestaurantWaiterScalarWhereInput | RestaurantWaiterScalarWhereInput[]
    id?: StringFilter<"RestaurantWaiter"> | string
    tenantId?: StringFilter<"RestaurantWaiter"> | string
    name?: StringFilter<"RestaurantWaiter"> | string
    pin?: StringFilter<"RestaurantWaiter"> | string
    isActive?: BoolFilter<"RestaurantWaiter"> | boolean
    createdAt?: DateTimeFilter<"RestaurantWaiter"> | Date | string
  }

  export type CabinetServiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: CabinetServiceWhereUniqueInput
    update: XOR<CabinetServiceUpdateWithoutTenantInput, CabinetServiceUncheckedUpdateWithoutTenantInput>
    create: XOR<CabinetServiceCreateWithoutTenantInput, CabinetServiceUncheckedCreateWithoutTenantInput>
  }

  export type CabinetServiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: CabinetServiceWhereUniqueInput
    data: XOR<CabinetServiceUpdateWithoutTenantInput, CabinetServiceUncheckedUpdateWithoutTenantInput>
  }

  export type CabinetServiceUpdateManyWithWhereWithoutTenantInput = {
    where: CabinetServiceScalarWhereInput
    data: XOR<CabinetServiceUpdateManyMutationInput, CabinetServiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type CabinetServiceScalarWhereInput = {
    AND?: CabinetServiceScalarWhereInput | CabinetServiceScalarWhereInput[]
    OR?: CabinetServiceScalarWhereInput[]
    NOT?: CabinetServiceScalarWhereInput | CabinetServiceScalarWhereInput[]
    id?: StringFilter<"CabinetService"> | string
    tenantId?: StringFilter<"CabinetService"> | string
    name?: StringFilter<"CabinetService"> | string
    description?: StringNullableFilter<"CabinetService"> | string | null
    price?: FloatFilter<"CabinetService"> | number
    duration?: IntFilter<"CabinetService"> | number
    isActive?: BoolFilter<"CabinetService"> | boolean
    createdAt?: DateTimeFilter<"CabinetService"> | Date | string
  }

  export type CabinetClientUpsertWithWhereUniqueWithoutTenantInput = {
    where: CabinetClientWhereUniqueInput
    update: XOR<CabinetClientUpdateWithoutTenantInput, CabinetClientUncheckedUpdateWithoutTenantInput>
    create: XOR<CabinetClientCreateWithoutTenantInput, CabinetClientUncheckedCreateWithoutTenantInput>
  }

  export type CabinetClientUpdateWithWhereUniqueWithoutTenantInput = {
    where: CabinetClientWhereUniqueInput
    data: XOR<CabinetClientUpdateWithoutTenantInput, CabinetClientUncheckedUpdateWithoutTenantInput>
  }

  export type CabinetClientUpdateManyWithWhereWithoutTenantInput = {
    where: CabinetClientScalarWhereInput
    data: XOR<CabinetClientUpdateManyMutationInput, CabinetClientUncheckedUpdateManyWithoutTenantInput>
  }

  export type CabinetClientScalarWhereInput = {
    AND?: CabinetClientScalarWhereInput | CabinetClientScalarWhereInput[]
    OR?: CabinetClientScalarWhereInput[]
    NOT?: CabinetClientScalarWhereInput | CabinetClientScalarWhereInput[]
    id?: StringFilter<"CabinetClient"> | string
    tenantId?: StringFilter<"CabinetClient"> | string
    name?: StringFilter<"CabinetClient"> | string
    email?: StringNullableFilter<"CabinetClient"> | string | null
    phone?: StringNullableFilter<"CabinetClient"> | string | null
    notes?: StringNullableFilter<"CabinetClient"> | string | null
    createdAt?: DateTimeFilter<"CabinetClient"> | Date | string
    updatedAt?: DateTimeFilter<"CabinetClient"> | Date | string
  }

  export type CabinetAppointmentUpsertWithWhereUniqueWithoutTenantInput = {
    where: CabinetAppointmentWhereUniqueInput
    update: XOR<CabinetAppointmentUpdateWithoutTenantInput, CabinetAppointmentUncheckedUpdateWithoutTenantInput>
    create: XOR<CabinetAppointmentCreateWithoutTenantInput, CabinetAppointmentUncheckedCreateWithoutTenantInput>
  }

  export type CabinetAppointmentUpdateWithWhereUniqueWithoutTenantInput = {
    where: CabinetAppointmentWhereUniqueInput
    data: XOR<CabinetAppointmentUpdateWithoutTenantInput, CabinetAppointmentUncheckedUpdateWithoutTenantInput>
  }

  export type CabinetAppointmentUpdateManyWithWhereWithoutTenantInput = {
    where: CabinetAppointmentScalarWhereInput
    data: XOR<CabinetAppointmentUpdateManyMutationInput, CabinetAppointmentUncheckedUpdateManyWithoutTenantInput>
  }

  export type CabinetAppointmentScalarWhereInput = {
    AND?: CabinetAppointmentScalarWhereInput | CabinetAppointmentScalarWhereInput[]
    OR?: CabinetAppointmentScalarWhereInput[]
    NOT?: CabinetAppointmentScalarWhereInput | CabinetAppointmentScalarWhereInput[]
    id?: StringFilter<"CabinetAppointment"> | string
    tenantId?: StringFilter<"CabinetAppointment"> | string
    serviceId?: StringFilter<"CabinetAppointment"> | string
    clientId?: StringFilter<"CabinetAppointment"> | string
    appointmentDate?: DateTimeFilter<"CabinetAppointment"> | Date | string
    status?: StringFilter<"CabinetAppointment"> | string
    notes?: StringNullableFilter<"CabinetAppointment"> | string | null
    createdAt?: DateTimeFilter<"CabinetAppointment"> | Date | string
    updatedAt?: DateTimeFilter<"CabinetAppointment"> | Date | string
  }

  export type UserUpsertWithoutWebsitesInput = {
    update: XOR<UserUpdateWithoutWebsitesInput, UserUncheckedUpdateWithoutWebsitesInput>
    create: XOR<UserCreateWithoutWebsitesInput, UserUncheckedCreateWithoutWebsitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWebsitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWebsitesInput, UserUncheckedUpdateWithoutWebsitesInput>
  }

  export type UserUpdateWithoutWebsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: UserServiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWebsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: UserServiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceUpsertWithoutWebsitesInput = {
    update: XOR<ServiceUpdateWithoutWebsitesInput, ServiceUncheckedUpdateWithoutWebsitesInput>
    create: XOR<ServiceCreateWithoutWebsitesInput, ServiceUncheckedCreateWithoutWebsitesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutWebsitesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutWebsitesInput, ServiceUncheckedUpdateWithoutWebsitesInput>
  }

  export type ServiceUpdateWithoutWebsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutWebsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type RestaurantDishCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    image?: string | null
    isActive?: boolean
    order?: number
  }

  export type RestaurantDishUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    image?: string | null
    isActive?: boolean
    order?: number
  }

  export type RestaurantDishCreateOrConnectWithoutCategoryInput = {
    where: RestaurantDishWhereUniqueInput
    create: XOR<RestaurantDishCreateWithoutCategoryInput, RestaurantDishUncheckedCreateWithoutCategoryInput>
  }

  export type RestaurantDishCreateManyCategoryInputEnvelope = {
    data: RestaurantDishCreateManyCategoryInput | RestaurantDishCreateManyCategoryInput[]
  }

  export type TenantWebsiteCreateWithoutCategoriesInput = {
    id?: string
    slug: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: RestaurantTableCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentCreateNestedManyWithoutTenantInput
    user: UserCreateNestedOneWithoutWebsitesInput
    service: ServiceCreateNestedOneWithoutWebsitesInput
  }

  export type TenantWebsiteUncheckedCreateWithoutCategoriesInput = {
    id?: string
    slug: string
    userId: string
    serviceId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: RestaurantTableUncheckedCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterUncheckedCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceUncheckedCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientUncheckedCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantWebsiteCreateOrConnectWithoutCategoriesInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutCategoriesInput, TenantWebsiteUncheckedCreateWithoutCategoriesInput>
  }

  export type RestaurantDishUpsertWithWhereUniqueWithoutCategoryInput = {
    where: RestaurantDishWhereUniqueInput
    update: XOR<RestaurantDishUpdateWithoutCategoryInput, RestaurantDishUncheckedUpdateWithoutCategoryInput>
    create: XOR<RestaurantDishCreateWithoutCategoryInput, RestaurantDishUncheckedCreateWithoutCategoryInput>
  }

  export type RestaurantDishUpdateWithWhereUniqueWithoutCategoryInput = {
    where: RestaurantDishWhereUniqueInput
    data: XOR<RestaurantDishUpdateWithoutCategoryInput, RestaurantDishUncheckedUpdateWithoutCategoryInput>
  }

  export type RestaurantDishUpdateManyWithWhereWithoutCategoryInput = {
    where: RestaurantDishScalarWhereInput
    data: XOR<RestaurantDishUpdateManyMutationInput, RestaurantDishUncheckedUpdateManyWithoutCategoryInput>
  }

  export type RestaurantDishScalarWhereInput = {
    AND?: RestaurantDishScalarWhereInput | RestaurantDishScalarWhereInput[]
    OR?: RestaurantDishScalarWhereInput[]
    NOT?: RestaurantDishScalarWhereInput | RestaurantDishScalarWhereInput[]
    id?: StringFilter<"RestaurantDish"> | string
    categoryId?: StringFilter<"RestaurantDish"> | string
    name?: StringFilter<"RestaurantDish"> | string
    description?: StringNullableFilter<"RestaurantDish"> | string | null
    price?: FloatFilter<"RestaurantDish"> | number
    image?: StringNullableFilter<"RestaurantDish"> | string | null
    isActive?: BoolFilter<"RestaurantDish"> | boolean
    order?: IntFilter<"RestaurantDish"> | number
  }

  export type TenantWebsiteUpsertWithoutCategoriesInput = {
    update: XOR<TenantWebsiteUpdateWithoutCategoriesInput, TenantWebsiteUncheckedUpdateWithoutCategoriesInput>
    create: XOR<TenantWebsiteCreateWithoutCategoriesInput, TenantWebsiteUncheckedCreateWithoutCategoriesInput>
    where?: TenantWebsiteWhereInput
  }

  export type TenantWebsiteUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: TenantWebsiteWhereInput
    data: XOR<TenantWebsiteUpdateWithoutCategoriesInput, TenantWebsiteUncheckedUpdateWithoutCategoriesInput>
  }

  export type TenantWebsiteUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: RestaurantTableUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUpdateManyWithoutTenantNestedInput
    user?: UserUpdateOneRequiredWithoutWebsitesNestedInput
    service?: ServiceUpdateOneRequiredWithoutWebsitesNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: RestaurantTableUncheckedUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUncheckedUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUncheckedUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUncheckedUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RestaurantCategoryCreateWithoutDishesInput = {
    id?: string
    name: string
    order?: number
    isActive?: boolean
    tenant: TenantWebsiteCreateNestedOneWithoutCategoriesInput
  }

  export type RestaurantCategoryUncheckedCreateWithoutDishesInput = {
    id?: string
    tenantId: string
    name: string
    order?: number
    isActive?: boolean
  }

  export type RestaurantCategoryCreateOrConnectWithoutDishesInput = {
    where: RestaurantCategoryWhereUniqueInput
    create: XOR<RestaurantCategoryCreateWithoutDishesInput, RestaurantCategoryUncheckedCreateWithoutDishesInput>
  }

  export type RestaurantCategoryUpsertWithoutDishesInput = {
    update: XOR<RestaurantCategoryUpdateWithoutDishesInput, RestaurantCategoryUncheckedUpdateWithoutDishesInput>
    create: XOR<RestaurantCategoryCreateWithoutDishesInput, RestaurantCategoryUncheckedCreateWithoutDishesInput>
    where?: RestaurantCategoryWhereInput
  }

  export type RestaurantCategoryUpdateToOneWithWhereWithoutDishesInput = {
    where?: RestaurantCategoryWhereInput
    data: XOR<RestaurantCategoryUpdateWithoutDishesInput, RestaurantCategoryUncheckedUpdateWithoutDishesInput>
  }

  export type RestaurantCategoryUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantWebsiteUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type RestaurantCategoryUncheckedUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestaurantOrderCreateWithoutTableInput = {
    id?: string
    status?: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: RestaurantOrderItemCreateNestedManyWithoutOrderInput
  }

  export type RestaurantOrderUncheckedCreateWithoutTableInput = {
    id?: string
    status?: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: RestaurantOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type RestaurantOrderCreateOrConnectWithoutTableInput = {
    where: RestaurantOrderWhereUniqueInput
    create: XOR<RestaurantOrderCreateWithoutTableInput, RestaurantOrderUncheckedCreateWithoutTableInput>
  }

  export type RestaurantOrderCreateManyTableInputEnvelope = {
    data: RestaurantOrderCreateManyTableInput | RestaurantOrderCreateManyTableInput[]
  }

  export type TenantWebsiteCreateWithoutTablesInput = {
    id?: string
    slug: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentCreateNestedManyWithoutTenantInput
    user: UserCreateNestedOneWithoutWebsitesInput
    service: ServiceCreateNestedOneWithoutWebsitesInput
  }

  export type TenantWebsiteUncheckedCreateWithoutTablesInput = {
    id?: string
    slug: string
    userId: string
    serviceId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryUncheckedCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterUncheckedCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceUncheckedCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientUncheckedCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantWebsiteCreateOrConnectWithoutTablesInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutTablesInput, TenantWebsiteUncheckedCreateWithoutTablesInput>
  }

  export type RestaurantWaiterCreateWithoutTablesInput = {
    id?: string
    name: string
    pin: string
    isActive?: boolean
    createdAt?: Date | string
    tenant: TenantWebsiteCreateNestedOneWithoutWaitersInput
  }

  export type RestaurantWaiterUncheckedCreateWithoutTablesInput = {
    id?: string
    tenantId: string
    name: string
    pin: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type RestaurantWaiterCreateOrConnectWithoutTablesInput = {
    where: RestaurantWaiterWhereUniqueInput
    create: XOR<RestaurantWaiterCreateWithoutTablesInput, RestaurantWaiterUncheckedCreateWithoutTablesInput>
  }

  export type RestaurantOrderUpsertWithWhereUniqueWithoutTableInput = {
    where: RestaurantOrderWhereUniqueInput
    update: XOR<RestaurantOrderUpdateWithoutTableInput, RestaurantOrderUncheckedUpdateWithoutTableInput>
    create: XOR<RestaurantOrderCreateWithoutTableInput, RestaurantOrderUncheckedCreateWithoutTableInput>
  }

  export type RestaurantOrderUpdateWithWhereUniqueWithoutTableInput = {
    where: RestaurantOrderWhereUniqueInput
    data: XOR<RestaurantOrderUpdateWithoutTableInput, RestaurantOrderUncheckedUpdateWithoutTableInput>
  }

  export type RestaurantOrderUpdateManyWithWhereWithoutTableInput = {
    where: RestaurantOrderScalarWhereInput
    data: XOR<RestaurantOrderUpdateManyMutationInput, RestaurantOrderUncheckedUpdateManyWithoutTableInput>
  }

  export type RestaurantOrderScalarWhereInput = {
    AND?: RestaurantOrderScalarWhereInput | RestaurantOrderScalarWhereInput[]
    OR?: RestaurantOrderScalarWhereInput[]
    NOT?: RestaurantOrderScalarWhereInput | RestaurantOrderScalarWhereInput[]
    id?: StringFilter<"RestaurantOrder"> | string
    tableId?: StringFilter<"RestaurantOrder"> | string
    status?: StringFilter<"RestaurantOrder"> | string
    totalAmount?: FloatFilter<"RestaurantOrder"> | number
    createdAt?: DateTimeFilter<"RestaurantOrder"> | Date | string
    updatedAt?: DateTimeFilter<"RestaurantOrder"> | Date | string
  }

  export type TenantWebsiteUpsertWithoutTablesInput = {
    update: XOR<TenantWebsiteUpdateWithoutTablesInput, TenantWebsiteUncheckedUpdateWithoutTablesInput>
    create: XOR<TenantWebsiteCreateWithoutTablesInput, TenantWebsiteUncheckedCreateWithoutTablesInput>
    where?: TenantWebsiteWhereInput
  }

  export type TenantWebsiteUpdateToOneWithWhereWithoutTablesInput = {
    where?: TenantWebsiteWhereInput
    data: XOR<TenantWebsiteUpdateWithoutTablesInput, TenantWebsiteUncheckedUpdateWithoutTablesInput>
  }

  export type TenantWebsiteUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUpdateManyWithoutTenantNestedInput
    user?: UserUpdateOneRequiredWithoutWebsitesNestedInput
    service?: ServiceUpdateOneRequiredWithoutWebsitesNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUncheckedUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUncheckedUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUncheckedUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUncheckedUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RestaurantWaiterUpsertWithoutTablesInput = {
    update: XOR<RestaurantWaiterUpdateWithoutTablesInput, RestaurantWaiterUncheckedUpdateWithoutTablesInput>
    create: XOR<RestaurantWaiterCreateWithoutTablesInput, RestaurantWaiterUncheckedCreateWithoutTablesInput>
    where?: RestaurantWaiterWhereInput
  }

  export type RestaurantWaiterUpdateToOneWithWhereWithoutTablesInput = {
    where?: RestaurantWaiterWhereInput
    data: XOR<RestaurantWaiterUpdateWithoutTablesInput, RestaurantWaiterUncheckedUpdateWithoutTablesInput>
  }

  export type RestaurantWaiterUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantWebsiteUpdateOneRequiredWithoutWaitersNestedInput
  }

  export type RestaurantWaiterUncheckedUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantTableCreateWithoutWaiterInput = {
    id?: string
    number: string
    capacity?: number | null
    isActive?: boolean
    orders?: RestaurantOrderCreateNestedManyWithoutTableInput
    tenant: TenantWebsiteCreateNestedOneWithoutTablesInput
  }

  export type RestaurantTableUncheckedCreateWithoutWaiterInput = {
    id?: string
    tenantId: string
    number: string
    capacity?: number | null
    isActive?: boolean
    orders?: RestaurantOrderUncheckedCreateNestedManyWithoutTableInput
  }

  export type RestaurantTableCreateOrConnectWithoutWaiterInput = {
    where: RestaurantTableWhereUniqueInput
    create: XOR<RestaurantTableCreateWithoutWaiterInput, RestaurantTableUncheckedCreateWithoutWaiterInput>
  }

  export type RestaurantTableCreateManyWaiterInputEnvelope = {
    data: RestaurantTableCreateManyWaiterInput | RestaurantTableCreateManyWaiterInput[]
  }

  export type TenantWebsiteCreateWithoutWaitersInput = {
    id?: string
    slug: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentCreateNestedManyWithoutTenantInput
    user: UserCreateNestedOneWithoutWebsitesInput
    service: ServiceCreateNestedOneWithoutWebsitesInput
  }

  export type TenantWebsiteUncheckedCreateWithoutWaitersInput = {
    id?: string
    slug: string
    userId: string
    serviceId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryUncheckedCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableUncheckedCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceUncheckedCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientUncheckedCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantWebsiteCreateOrConnectWithoutWaitersInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutWaitersInput, TenantWebsiteUncheckedCreateWithoutWaitersInput>
  }

  export type RestaurantTableUpsertWithWhereUniqueWithoutWaiterInput = {
    where: RestaurantTableWhereUniqueInput
    update: XOR<RestaurantTableUpdateWithoutWaiterInput, RestaurantTableUncheckedUpdateWithoutWaiterInput>
    create: XOR<RestaurantTableCreateWithoutWaiterInput, RestaurantTableUncheckedCreateWithoutWaiterInput>
  }

  export type RestaurantTableUpdateWithWhereUniqueWithoutWaiterInput = {
    where: RestaurantTableWhereUniqueInput
    data: XOR<RestaurantTableUpdateWithoutWaiterInput, RestaurantTableUncheckedUpdateWithoutWaiterInput>
  }

  export type RestaurantTableUpdateManyWithWhereWithoutWaiterInput = {
    where: RestaurantTableScalarWhereInput
    data: XOR<RestaurantTableUpdateManyMutationInput, RestaurantTableUncheckedUpdateManyWithoutWaiterInput>
  }

  export type TenantWebsiteUpsertWithoutWaitersInput = {
    update: XOR<TenantWebsiteUpdateWithoutWaitersInput, TenantWebsiteUncheckedUpdateWithoutWaitersInput>
    create: XOR<TenantWebsiteCreateWithoutWaitersInput, TenantWebsiteUncheckedCreateWithoutWaitersInput>
    where?: TenantWebsiteWhereInput
  }

  export type TenantWebsiteUpdateToOneWithWhereWithoutWaitersInput = {
    where?: TenantWebsiteWhereInput
    data: XOR<TenantWebsiteUpdateWithoutWaitersInput, TenantWebsiteUncheckedUpdateWithoutWaitersInput>
  }

  export type TenantWebsiteUpdateWithoutWaitersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUpdateManyWithoutTenantNestedInput
    user?: UserUpdateOneRequiredWithoutWebsitesNestedInput
    service?: ServiceUpdateOneRequiredWithoutWebsitesNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutWaitersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUncheckedUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUncheckedUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUncheckedUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUncheckedUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RestaurantOrderItemCreateWithoutOrderInput = {
    id?: string
    dishId: string
    name: string
    price: number
    quantity: number
  }

  export type RestaurantOrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    dishId: string
    name: string
    price: number
    quantity: number
  }

  export type RestaurantOrderItemCreateOrConnectWithoutOrderInput = {
    where: RestaurantOrderItemWhereUniqueInput
    create: XOR<RestaurantOrderItemCreateWithoutOrderInput, RestaurantOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type RestaurantOrderItemCreateManyOrderInputEnvelope = {
    data: RestaurantOrderItemCreateManyOrderInput | RestaurantOrderItemCreateManyOrderInput[]
  }

  export type RestaurantTableCreateWithoutOrdersInput = {
    id?: string
    number: string
    capacity?: number | null
    isActive?: boolean
    tenant: TenantWebsiteCreateNestedOneWithoutTablesInput
    waiter?: RestaurantWaiterCreateNestedOneWithoutTablesInput
  }

  export type RestaurantTableUncheckedCreateWithoutOrdersInput = {
    id?: string
    tenantId: string
    number: string
    capacity?: number | null
    isActive?: boolean
    waiterId?: string | null
  }

  export type RestaurantTableCreateOrConnectWithoutOrdersInput = {
    where: RestaurantTableWhereUniqueInput
    create: XOR<RestaurantTableCreateWithoutOrdersInput, RestaurantTableUncheckedCreateWithoutOrdersInput>
  }

  export type RestaurantOrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: RestaurantOrderItemWhereUniqueInput
    update: XOR<RestaurantOrderItemUpdateWithoutOrderInput, RestaurantOrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<RestaurantOrderItemCreateWithoutOrderInput, RestaurantOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type RestaurantOrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: RestaurantOrderItemWhereUniqueInput
    data: XOR<RestaurantOrderItemUpdateWithoutOrderInput, RestaurantOrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type RestaurantOrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: RestaurantOrderItemScalarWhereInput
    data: XOR<RestaurantOrderItemUpdateManyMutationInput, RestaurantOrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type RestaurantOrderItemScalarWhereInput = {
    AND?: RestaurantOrderItemScalarWhereInput | RestaurantOrderItemScalarWhereInput[]
    OR?: RestaurantOrderItemScalarWhereInput[]
    NOT?: RestaurantOrderItemScalarWhereInput | RestaurantOrderItemScalarWhereInput[]
    id?: StringFilter<"RestaurantOrderItem"> | string
    orderId?: StringFilter<"RestaurantOrderItem"> | string
    dishId?: StringFilter<"RestaurantOrderItem"> | string
    name?: StringFilter<"RestaurantOrderItem"> | string
    price?: FloatFilter<"RestaurantOrderItem"> | number
    quantity?: IntFilter<"RestaurantOrderItem"> | number
  }

  export type RestaurantTableUpsertWithoutOrdersInput = {
    update: XOR<RestaurantTableUpdateWithoutOrdersInput, RestaurantTableUncheckedUpdateWithoutOrdersInput>
    create: XOR<RestaurantTableCreateWithoutOrdersInput, RestaurantTableUncheckedCreateWithoutOrdersInput>
    where?: RestaurantTableWhereInput
  }

  export type RestaurantTableUpdateToOneWithWhereWithoutOrdersInput = {
    where?: RestaurantTableWhereInput
    data: XOR<RestaurantTableUpdateWithoutOrdersInput, RestaurantTableUncheckedUpdateWithoutOrdersInput>
  }

  export type RestaurantTableUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantWebsiteUpdateOneRequiredWithoutTablesNestedInput
    waiter?: RestaurantWaiterUpdateOneWithoutTablesNestedInput
  }

  export type RestaurantTableUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestaurantOrderCreateWithoutItemsInput = {
    id?: string
    status?: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    table: RestaurantTableCreateNestedOneWithoutOrdersInput
  }

  export type RestaurantOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    tableId: string
    status?: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RestaurantOrderCreateOrConnectWithoutItemsInput = {
    where: RestaurantOrderWhereUniqueInput
    create: XOR<RestaurantOrderCreateWithoutItemsInput, RestaurantOrderUncheckedCreateWithoutItemsInput>
  }

  export type RestaurantOrderUpsertWithoutItemsInput = {
    update: XOR<RestaurantOrderUpdateWithoutItemsInput, RestaurantOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<RestaurantOrderCreateWithoutItemsInput, RestaurantOrderUncheckedCreateWithoutItemsInput>
    where?: RestaurantOrderWhereInput
  }

  export type RestaurantOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: RestaurantOrderWhereInput
    data: XOR<RestaurantOrderUpdateWithoutItemsInput, RestaurantOrderUncheckedUpdateWithoutItemsInput>
  }

  export type RestaurantOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    table?: RestaurantTableUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type RestaurantOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetAppointmentCreateWithoutServiceInput = {
    id?: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: CabinetClientCreateNestedOneWithoutAppointmentsInput
    tenant: TenantWebsiteCreateNestedOneWithoutCabinetAppointmentsInput
  }

  export type CabinetAppointmentUncheckedCreateWithoutServiceInput = {
    id?: string
    tenantId: string
    clientId: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetAppointmentCreateOrConnectWithoutServiceInput = {
    where: CabinetAppointmentWhereUniqueInput
    create: XOR<CabinetAppointmentCreateWithoutServiceInput, CabinetAppointmentUncheckedCreateWithoutServiceInput>
  }

  export type CabinetAppointmentCreateManyServiceInputEnvelope = {
    data: CabinetAppointmentCreateManyServiceInput | CabinetAppointmentCreateManyServiceInput[]
  }

  export type TenantWebsiteCreateWithoutCabinetServicesInput = {
    id?: string
    slug: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentCreateNestedManyWithoutTenantInput
    user: UserCreateNestedOneWithoutWebsitesInput
    service: ServiceCreateNestedOneWithoutWebsitesInput
  }

  export type TenantWebsiteUncheckedCreateWithoutCabinetServicesInput = {
    id?: string
    slug: string
    userId: string
    serviceId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryUncheckedCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableUncheckedCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterUncheckedCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientUncheckedCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantWebsiteCreateOrConnectWithoutCabinetServicesInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutCabinetServicesInput, TenantWebsiteUncheckedCreateWithoutCabinetServicesInput>
  }

  export type CabinetAppointmentUpsertWithWhereUniqueWithoutServiceInput = {
    where: CabinetAppointmentWhereUniqueInput
    update: XOR<CabinetAppointmentUpdateWithoutServiceInput, CabinetAppointmentUncheckedUpdateWithoutServiceInput>
    create: XOR<CabinetAppointmentCreateWithoutServiceInput, CabinetAppointmentUncheckedCreateWithoutServiceInput>
  }

  export type CabinetAppointmentUpdateWithWhereUniqueWithoutServiceInput = {
    where: CabinetAppointmentWhereUniqueInput
    data: XOR<CabinetAppointmentUpdateWithoutServiceInput, CabinetAppointmentUncheckedUpdateWithoutServiceInput>
  }

  export type CabinetAppointmentUpdateManyWithWhereWithoutServiceInput = {
    where: CabinetAppointmentScalarWhereInput
    data: XOR<CabinetAppointmentUpdateManyMutationInput, CabinetAppointmentUncheckedUpdateManyWithoutServiceInput>
  }

  export type TenantWebsiteUpsertWithoutCabinetServicesInput = {
    update: XOR<TenantWebsiteUpdateWithoutCabinetServicesInput, TenantWebsiteUncheckedUpdateWithoutCabinetServicesInput>
    create: XOR<TenantWebsiteCreateWithoutCabinetServicesInput, TenantWebsiteUncheckedCreateWithoutCabinetServicesInput>
    where?: TenantWebsiteWhereInput
  }

  export type TenantWebsiteUpdateToOneWithWhereWithoutCabinetServicesInput = {
    where?: TenantWebsiteWhereInput
    data: XOR<TenantWebsiteUpdateWithoutCabinetServicesInput, TenantWebsiteUncheckedUpdateWithoutCabinetServicesInput>
  }

  export type TenantWebsiteUpdateWithoutCabinetServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUpdateManyWithoutTenantNestedInput
    user?: UserUpdateOneRequiredWithoutWebsitesNestedInput
    service?: ServiceUpdateOneRequiredWithoutWebsitesNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutCabinetServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUncheckedUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUncheckedUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUncheckedUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUncheckedUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CabinetAppointmentCreateWithoutClientInput = {
    id?: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: CabinetServiceCreateNestedOneWithoutAppointmentsInput
    tenant: TenantWebsiteCreateNestedOneWithoutCabinetAppointmentsInput
  }

  export type CabinetAppointmentUncheckedCreateWithoutClientInput = {
    id?: string
    tenantId: string
    serviceId: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetAppointmentCreateOrConnectWithoutClientInput = {
    where: CabinetAppointmentWhereUniqueInput
    create: XOR<CabinetAppointmentCreateWithoutClientInput, CabinetAppointmentUncheckedCreateWithoutClientInput>
  }

  export type CabinetAppointmentCreateManyClientInputEnvelope = {
    data: CabinetAppointmentCreateManyClientInput | CabinetAppointmentCreateManyClientInput[]
  }

  export type TenantWebsiteCreateWithoutCabinetClientsInput = {
    id?: string
    slug: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentCreateNestedManyWithoutTenantInput
    user: UserCreateNestedOneWithoutWebsitesInput
    service: ServiceCreateNestedOneWithoutWebsitesInput
  }

  export type TenantWebsiteUncheckedCreateWithoutCabinetClientsInput = {
    id?: string
    slug: string
    userId: string
    serviceId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryUncheckedCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableUncheckedCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterUncheckedCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceUncheckedCreateNestedManyWithoutTenantInput
    cabinetAppointments?: CabinetAppointmentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantWebsiteCreateOrConnectWithoutCabinetClientsInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutCabinetClientsInput, TenantWebsiteUncheckedCreateWithoutCabinetClientsInput>
  }

  export type CabinetAppointmentUpsertWithWhereUniqueWithoutClientInput = {
    where: CabinetAppointmentWhereUniqueInput
    update: XOR<CabinetAppointmentUpdateWithoutClientInput, CabinetAppointmentUncheckedUpdateWithoutClientInput>
    create: XOR<CabinetAppointmentCreateWithoutClientInput, CabinetAppointmentUncheckedCreateWithoutClientInput>
  }

  export type CabinetAppointmentUpdateWithWhereUniqueWithoutClientInput = {
    where: CabinetAppointmentWhereUniqueInput
    data: XOR<CabinetAppointmentUpdateWithoutClientInput, CabinetAppointmentUncheckedUpdateWithoutClientInput>
  }

  export type CabinetAppointmentUpdateManyWithWhereWithoutClientInput = {
    where: CabinetAppointmentScalarWhereInput
    data: XOR<CabinetAppointmentUpdateManyMutationInput, CabinetAppointmentUncheckedUpdateManyWithoutClientInput>
  }

  export type TenantWebsiteUpsertWithoutCabinetClientsInput = {
    update: XOR<TenantWebsiteUpdateWithoutCabinetClientsInput, TenantWebsiteUncheckedUpdateWithoutCabinetClientsInput>
    create: XOR<TenantWebsiteCreateWithoutCabinetClientsInput, TenantWebsiteUncheckedCreateWithoutCabinetClientsInput>
    where?: TenantWebsiteWhereInput
  }

  export type TenantWebsiteUpdateToOneWithWhereWithoutCabinetClientsInput = {
    where?: TenantWebsiteWhereInput
    data: XOR<TenantWebsiteUpdateWithoutCabinetClientsInput, TenantWebsiteUncheckedUpdateWithoutCabinetClientsInput>
  }

  export type TenantWebsiteUpdateWithoutCabinetClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUpdateManyWithoutTenantNestedInput
    user?: UserUpdateOneRequiredWithoutWebsitesNestedInput
    service?: ServiceUpdateOneRequiredWithoutWebsitesNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutCabinetClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUncheckedUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUncheckedUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUncheckedUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUncheckedUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CabinetServiceCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    tenant: TenantWebsiteCreateNestedOneWithoutCabinetServicesInput
  }

  export type CabinetServiceUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type CabinetServiceCreateOrConnectWithoutAppointmentsInput = {
    where: CabinetServiceWhereUniqueInput
    create: XOR<CabinetServiceCreateWithoutAppointmentsInput, CabinetServiceUncheckedCreateWithoutAppointmentsInput>
  }

  export type CabinetClientCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantWebsiteCreateNestedOneWithoutCabinetClientsInput
  }

  export type CabinetClientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetClientCreateOrConnectWithoutAppointmentsInput = {
    where: CabinetClientWhereUniqueInput
    create: XOR<CabinetClientCreateWithoutAppointmentsInput, CabinetClientUncheckedCreateWithoutAppointmentsInput>
  }

  export type TenantWebsiteCreateWithoutCabinetAppointmentsInput = {
    id?: string
    slug: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientCreateNestedManyWithoutTenantInput
    user: UserCreateNestedOneWithoutWebsitesInput
    service: ServiceCreateNestedOneWithoutWebsitesInput
  }

  export type TenantWebsiteUncheckedCreateWithoutCabinetAppointmentsInput = {
    id?: string
    slug: string
    userId: string
    serviceId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: RestaurantCategoryUncheckedCreateNestedManyWithoutTenantInput
    tables?: RestaurantTableUncheckedCreateNestedManyWithoutTenantInput
    waiters?: RestaurantWaiterUncheckedCreateNestedManyWithoutTenantInput
    cabinetServices?: CabinetServiceUncheckedCreateNestedManyWithoutTenantInput
    cabinetClients?: CabinetClientUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantWebsiteCreateOrConnectWithoutCabinetAppointmentsInput = {
    where: TenantWebsiteWhereUniqueInput
    create: XOR<TenantWebsiteCreateWithoutCabinetAppointmentsInput, TenantWebsiteUncheckedCreateWithoutCabinetAppointmentsInput>
  }

  export type CabinetServiceUpsertWithoutAppointmentsInput = {
    update: XOR<CabinetServiceUpdateWithoutAppointmentsInput, CabinetServiceUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<CabinetServiceCreateWithoutAppointmentsInput, CabinetServiceUncheckedCreateWithoutAppointmentsInput>
    where?: CabinetServiceWhereInput
  }

  export type CabinetServiceUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: CabinetServiceWhereInput
    data: XOR<CabinetServiceUpdateWithoutAppointmentsInput, CabinetServiceUncheckedUpdateWithoutAppointmentsInput>
  }

  export type CabinetServiceUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantWebsiteUpdateOneRequiredWithoutCabinetServicesNestedInput
  }

  export type CabinetServiceUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetClientUpsertWithoutAppointmentsInput = {
    update: XOR<CabinetClientUpdateWithoutAppointmentsInput, CabinetClientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<CabinetClientCreateWithoutAppointmentsInput, CabinetClientUncheckedCreateWithoutAppointmentsInput>
    where?: CabinetClientWhereInput
  }

  export type CabinetClientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: CabinetClientWhereInput
    data: XOR<CabinetClientUpdateWithoutAppointmentsInput, CabinetClientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type CabinetClientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantWebsiteUpdateOneRequiredWithoutCabinetClientsNestedInput
  }

  export type CabinetClientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantWebsiteUpsertWithoutCabinetAppointmentsInput = {
    update: XOR<TenantWebsiteUpdateWithoutCabinetAppointmentsInput, TenantWebsiteUncheckedUpdateWithoutCabinetAppointmentsInput>
    create: XOR<TenantWebsiteCreateWithoutCabinetAppointmentsInput, TenantWebsiteUncheckedCreateWithoutCabinetAppointmentsInput>
    where?: TenantWebsiteWhereInput
  }

  export type TenantWebsiteUpdateToOneWithWhereWithoutCabinetAppointmentsInput = {
    where?: TenantWebsiteWhereInput
    data: XOR<TenantWebsiteUpdateWithoutCabinetAppointmentsInput, TenantWebsiteUncheckedUpdateWithoutCabinetAppointmentsInput>
  }

  export type TenantWebsiteUpdateWithoutCabinetAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUpdateManyWithoutTenantNestedInput
    user?: UserUpdateOneRequiredWithoutWebsitesNestedInput
    service?: ServiceUpdateOneRequiredWithoutWebsitesNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutCabinetAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUncheckedUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUncheckedUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUncheckedUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUncheckedUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserServiceCreateManyUserInput = {
    id?: string
    serviceId: string
    notify?: boolean
    selectedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type TenantWebsiteCreateManyUserInput = {
    id?: string
    slug: string
    serviceId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatSessionCreateManyUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserServiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notify?: BoolFieldUpdateOperationsInput | boolean
    selectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserServiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    notify?: BoolFieldUpdateOperationsInput | boolean
    selectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserServiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    notify?: BoolFieldUpdateOperationsInput | boolean
    selectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantWebsiteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUpdateManyWithoutTenantNestedInput
    service?: ServiceUpdateOneRequiredWithoutWebsitesNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUncheckedUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUncheckedUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUncheckedUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUncheckedUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUncheckedUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantWebsiteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManySessionInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserServiceCreateManyServiceInput = {
    id?: string
    userId: string
    notify?: boolean
    selectedAt?: Date | string
  }

  export type TenantWebsiteCreateManyServiceInput = {
    id?: string
    slug: string
    userId: string
    siteName: string
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    primaryColor?: string
    config?: string
    designTemplate?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserServiceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    notify?: BoolFieldUpdateOperationsInput | boolean
    selectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
  }

  export type UserServiceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notify?: BoolFieldUpdateOperationsInput | boolean
    selectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notify?: BoolFieldUpdateOperationsInput | boolean
    selectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantWebsiteUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUpdateManyWithoutTenantNestedInput
    user?: UserUpdateOneRequiredWithoutWebsitesNestedInput
  }

  export type TenantWebsiteUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: RestaurantCategoryUncheckedUpdateManyWithoutTenantNestedInput
    tables?: RestaurantTableUncheckedUpdateManyWithoutTenantNestedInput
    waiters?: RestaurantWaiterUncheckedUpdateManyWithoutTenantNestedInput
    cabinetServices?: CabinetServiceUncheckedUpdateManyWithoutTenantNestedInput
    cabinetClients?: CabinetClientUncheckedUpdateManyWithoutTenantNestedInput
    cabinetAppointments?: CabinetAppointmentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantWebsiteUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    designTemplate?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantCategoryCreateManyTenantInput = {
    id?: string
    name: string
    order?: number
    isActive?: boolean
  }

  export type RestaurantTableCreateManyTenantInput = {
    id?: string
    number: string
    capacity?: number | null
    isActive?: boolean
    waiterId?: string | null
  }

  export type RestaurantWaiterCreateManyTenantInput = {
    id?: string
    name: string
    pin: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type CabinetServiceCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type CabinetClientCreateManyTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetAppointmentCreateManyTenantInput = {
    id?: string
    serviceId: string
    clientId: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RestaurantCategoryUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dishes?: RestaurantDishUpdateManyWithoutCategoryNestedInput
  }

  export type RestaurantCategoryUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dishes?: RestaurantDishUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type RestaurantCategoryUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestaurantTableUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    orders?: RestaurantOrderUpdateManyWithoutTableNestedInput
    waiter?: RestaurantWaiterUpdateOneWithoutTablesNestedInput
  }

  export type RestaurantTableUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiterId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: RestaurantOrderUncheckedUpdateManyWithoutTableNestedInput
  }

  export type RestaurantTableUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestaurantWaiterUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: RestaurantTableUpdateManyWithoutWaiterNestedInput
  }

  export type RestaurantWaiterUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: RestaurantTableUncheckedUpdateManyWithoutWaiterNestedInput
  }

  export type RestaurantWaiterUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetServiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: CabinetAppointmentUpdateManyWithoutServiceNestedInput
  }

  export type CabinetServiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: CabinetAppointmentUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type CabinetServiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetClientUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: CabinetAppointmentUpdateManyWithoutClientNestedInput
  }

  export type CabinetClientUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: CabinetAppointmentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CabinetClientUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetAppointmentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: CabinetServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    client?: CabinetClientUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type CabinetAppointmentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetAppointmentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantDishCreateManyCategoryInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    image?: string | null
    isActive?: boolean
    order?: number
  }

  export type RestaurantDishUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantDishUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantDishUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantOrderCreateManyTableInput = {
    id?: string
    status?: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RestaurantOrderUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: RestaurantOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type RestaurantOrderUncheckedUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: RestaurantOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type RestaurantOrderUncheckedUpdateManyWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantTableCreateManyWaiterInput = {
    id?: string
    tenantId: string
    number: string
    capacity?: number | null
    isActive?: boolean
  }

  export type RestaurantTableUpdateWithoutWaiterInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    orders?: RestaurantOrderUpdateManyWithoutTableNestedInput
    tenant?: TenantWebsiteUpdateOneRequiredWithoutTablesNestedInput
  }

  export type RestaurantTableUncheckedUpdateWithoutWaiterInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    orders?: RestaurantOrderUncheckedUpdateManyWithoutTableNestedInput
  }

  export type RestaurantTableUncheckedUpdateManyWithoutWaiterInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestaurantOrderItemCreateManyOrderInput = {
    id?: string
    dishId: string
    name: string
    price: number
    quantity: number
  }

  export type RestaurantOrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantOrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantOrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CabinetAppointmentCreateManyServiceInput = {
    id?: string
    tenantId: string
    clientId: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetAppointmentUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: CabinetClientUpdateOneRequiredWithoutAppointmentsNestedInput
    tenant?: TenantWebsiteUpdateOneRequiredWithoutCabinetAppointmentsNestedInput
  }

  export type CabinetAppointmentUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetAppointmentUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetAppointmentCreateManyClientInput = {
    id?: string
    tenantId: string
    serviceId: string
    appointmentDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CabinetAppointmentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: CabinetServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    tenant?: TenantWebsiteUpdateOneRequiredWithoutCabinetAppointmentsNestedInput
  }

  export type CabinetAppointmentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CabinetAppointmentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}